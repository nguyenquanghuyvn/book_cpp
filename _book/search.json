[
  {
    "objectID": "c7_flow_error.html#conditional-flow-control-statement",
    "href": "c7_flow_error.html#conditional-flow-control-statement",
    "title": "8  Control flow and Error Handling",
    "section": "8.1 Conditional flow control statement",
    "text": "8.1 Conditional flow control statement\n\n8.1.1 If statements and blocks\nC++ have two kinds of conditional statement: if statement and switch statement.\nWe already worked with if statement in previous chapters, one thing to be noted here is that the author recommends to use the ‘{}’ for the statements, even if we just have single statement after if and/or else.\n\n\n8.1.2 Common if statement problem\n\nif_statements within other if statements:\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n\n    return 0;\n}\n\n\nThe ambiguity arises when there is an else statement:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n        \n    else std::cout << x << \" is negative\\n\"; #// else for which if?\n\n    return 0;\n}\n\n\nC++ understands else for the last unmatched if statement. We should use the block for being clear:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n    {\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n        else std::cout << x << \" is greater than 20\\n\"; #// else for which if?\n    }\n    else\n        std::cout << x << \" is negative\\n\";\n\n    return 0;\n}\n\n\nNested if statement can be flattened by either restructuring the logic or by using local operators:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    if (x < 0)\n        std::cout << x << \" is negative\\n\";\n    else if (x <= 20)\n        std::cout << x << \" is between 0 and 20\\n\";\n    else\n        std::cout << x << \" is greater than 20\";\n\n    return 0;\n}\n\n\n\n\n8.1.3 Switch statement basics\nThe idea behind a switch statement is that: an expression (condition) is evaluated to produce a value. If the expression’s value is equal to the value after any of case labels, the statements after the matching case label are executed. If there does not have any match, default label are executed instead.\n\n\n\n\n\n\n\nOne restriction: condition has to be in integral type.\nThe case follows by a constant expression.\nIf matching, first statements after case label start and then continues sequentially.\n\n\n\n\nHere is an example:\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        return;\n    case 2:\n        std::cout << \"Two\";\n        return;\n    case 3:\n        std::cout << \"Three\";\n        return;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n}\n\nint main()\n{\n    printDigitName(2);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nUsing the return in switch, the program ends when there is a match or at default. We can use break to tell the program stop at the point matching or default and jump to the next statement next to switch.\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        break;\n    case 2:\n        std::cout << \"Two\";\n        break;\n    case 3:\n        std::cout << \"Three\";\n        break;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n\n    std::cout << \"\\nOut of switch!\\n\";\n}\n\nint main()\n{\n    printDigitName(3);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nWhat does the execution of switch when we miss return or break statement? It will continue to the next case and have unexpected result.\nIf we intentionally omit the end statement after the case, we can use the attribute [[fallthrough]]:\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        break;\n    case 2:\n        std::cout << \"Two\";\n        [[fallthrough]];\n    case 3:\n        std::cout << \"Three\";\n        break;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n\n    std::cout << \"\\nOut of switch!\\n\";\n}\n\nint main()\n{\n    printDigitName(2);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nSequential case labels: we can use switch statements by placing multiple case labels in sequence:\n\n\nCode\nbool isVowel(char c)\n{\n    switch (c)\n    {\n        case 'a': // if c is 'a'\n        case 'e': // or if c is 'e'\n        case 'i': // or if c is 'i'\n        case 'o': // or if c is 'o'\n        case 'u': // or if c is 'u'\n        case 'A': // or if c is 'A'\n        case 'E': // or if c is 'E'\n        case 'I': // or if c is 'I'\n        case 'O': // or if c is 'O'\n        case 'U': // or if c is 'U'\n            return true;\n        default:\n            return false;\n    }\n}\n\n\nIf defining variables used in a case statement, do so in a block inside the case."
  },
  {
    "objectID": "c7_flow_error.html#goto-statements",
    "href": "c7_flow_error.html#goto-statements",
    "title": "8  Control flow and Error Handling",
    "section": "8.2 Goto statements",
    "text": "8.2 Goto statements\nThis is a type of unconditional jump. In C++, we use goto statement and the spot to jump by using statement label.\nHere is an example:\n\n\nCode\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    double x{};\n    int tryTime{ 0 };\n    \ntryHere:\n    std::cout << \"Enter a non-negative number: \";\n    std::cin >> x;\n    \n    if (x < 0.0 && tryTime < 5)\n    {\n        ++tryTime;\n        std::cout << \"You entered a negative number.\\n\";\n        goto tryHere;\n    }\n        \n    if (tryTime < 5)\n        std::cout << \"The square root of \" << x << \" is \" << std::sqrt(x) << '\\n';\n    else\n        std::cout << \"You cannot enter more than 5 times. Closing program.\\n\";\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nAvoid using goto statement"
  },
  {
    "objectID": "c7_flow_error.html#introduction-to-loops-and-while-statements",
    "href": "c7_flow_error.html#introduction-to-loops-and-while-statements",
    "title": "8  Control flow and Error Handling",
    "section": "8.3 Introduction to loops and while statements",
    "text": "8.3 Introduction to loops and while statements\nLoops are control flow statements that allow a group of code execute repeatedly until meeting defined condition.\nHere is an program that print integer number to 10:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int count{1};\n    while (count <= 100)\n    {\n        std::cout << count << ' ';\n        ++count;\n    }\n\n    std::cout << \"done!\\n\";\n\n    return 0;\n}\n\n\nIf the condition in while is always true, the program run infinitely or we have infinite loop.\nIntentional infinite loop: we can add the break, return, or goto statement to end the infinite loop.\nLoop variable:: to count how many times a loop has executed. This is also called counter\nIteration: each time loop executes. We write a program to count from 1 to 50, each line have 10 numbers:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int count{1};\n    while(count <= 50)\n    {\n        if (count < 10)\n        {\n            std::cout << '0';\n        }\n        \n        std::cout << count << ' ';\n        \n        if (count % 10 == 0)\n        {\n            std::cout << '\\n';\n        }\n        \n        ++count;\n    }\n    \n    return 0;\n}\n\n\n\n8.3.1 Nested loop\nA loop can be inside other loop. The inner loop can use outer loop’s counter. Here is an example:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int outer{ 1 };\n    while (outer <= 10)\n    {\n        int inner{ 1 };\n        while (inner <= outer)\n        {\n            std::cout << inner << ' ';\n            ++inner;\n        }\n        std::cout << '\\n';\n        ++outer;\n    }\n\n    return 0;\n}\n\n\nIn the exercise, we write a small program to print the characters from ‘a’ to ‘z’ and its ASCII code. From this, we need to recall the function static_cast<type>(variable) to transform characters to its integer:\n\n\nCode\n#include<iostream>\n\nint main()\n{\n    char myChar{ 'a' };\n    while (myChar <= 'z')\n    {\n        std::cout << myChar << ' ' << static_cast<int>(myChar) << '\\n';\n        ++myChar;\n    }\n\n    return 0;\n}\n\n\nThe next exercise ask us to print an inverse triangle:\n\n\nCode\n#|label: while-inverse-triangle\n\n#include <iostream>\n\nint main()\n{\n    int outer{ 5 };\n    while (outer >= 1)\n    {\n        int inner{ outer };\n        while ((inner >= 1))\n        {\n            std::cout << inner-- << ' ';\n            #//--inner;\n        }\n\n        std::cout << '\\n';\n        --outer;\n    }\n\n    return 0;\n}\n\n\nThe most exercise is to create a right-handside triangle:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int outer{ 1 };\n    while (outer <= 5)\n    {\n        int inner{ 5 };\n        \n        while (inner >= 1)\n        {\n            if (inner <= outer)\n                std::cout << inner << ' ';\n            else\n                std::cout << \"  \";\n            --inner;\n        }\n        \n        std::cout << '\\n';\n        outer++;\n    }\n    \n    return 0;\n}"
  },
  {
    "objectID": "c7_flow_error.html#do-while-statement",
    "href": "c7_flow_error.html#do-while-statement",
    "title": "8  Control flow and Error Handling",
    "section": "8.4 Do while statement",
    "text": "8.4 Do while statement\nThis is just like while loop but the statement always executes at least once. After the statement has been executed, the do-while loop checks the condition.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    // selection must be declared outside of the do-while so we can use it later\n    int selection{};\n\n    do\n    {\n        std::cout << \"Please make a selection: \\n\";\n        std::cout << \"1) Addition\\n\";\n        std::cout << \"2) Subtraction\\n\";\n        std::cout << \"3) Multiplication\\n\";\n        std::cout << \"4) Division\\n\";\n        std::cin >> selection;\n    }\n    while (selection != 1 && selection != 2 &&\n        selection != 3 && selection != 4);\n\n    // do something with selection here\n    // such as a switch statement\n\n    std::cout << \"You selected option #\" << selection << '\\n';\n\n    return 0;\n}\n\n\nThe author recommend favor while loops over do-while when given equal choice."
  },
  {
    "objectID": "c7_flow_error.html#for-statements",
    "href": "c7_flow_error.html#for-statements",
    "title": "8  Control flow and Error Handling",
    "section": "8.5 For statements",
    "text": "8.5 For statements\nIn this session, we learn about the classic for statements with the form: for (init-statement; condition; end-expression) statements.\nWe can easily link to the while statement:\n\n\nCode\ninit_statement;\nwhile(condition)\n{\n    statement;\n    end_expression;\n}\n\n\nWe can write a very simple for loop:\n\n\nCode\nint main()\n{\n    for (int count{ 1 }; count <= 10; ++count)\n        std::cout << count << ' ';\n    \n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nWe can easily change to while statement:\n\n\nCode\nint main()\n{\n    {\n        int count{1};\n        while (count <= 10)\n        {\n            std::cout << count << ' ';\n            ++count\n        }\n    }\n    \n    std::cout << '\\n';\n}\n\n\nWe can define multiple counters:\n\n\nCode\n#include \"io.h\"\n#include <iostream>\n\nint main()\n{\n\n    for (int x{ 0 }, y{ 9 }; x < 10; ++x, --y)\n        std::cout << x << ' ' << y << '\\n';\n    \n    return 0;\n}\n\n\nLoop can nest in other loop:\n\n\nCode\nvoid charNumber()\n{\n    for (char c{ 'a' }; c <= 'h'; ++c)\n    {\n        std::cout << c;\n        \n        for (int i{ 0 }; i < 4; i++)\n        {\n            std::cout << i;\n        }\n\n        std::cout << '\\n';\n    }\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\n\nFor statements are the mostly important used loop in C++.\nPrefer for loop over while loop when there is an obvious loop variable.\nPrefer while loop over for loops when there is no obvious loop variable."
  },
  {
    "objectID": "c7_flow_error.html#break-and-continue",
    "href": "c7_flow_error.html#break-and-continue",
    "title": "8  Control flow and Error Handling",
    "section": "8.6 Break and continue",
    "text": "8.6 Break and continue\nbreak statement terminates the switch or loop, and execution continue at the first statement beyond the switch or loop.\nreturn statement terminate the entire function that the loop is within, and execution continues at point where the function was called.\n\n8.6.1 Continue\nContinue statement tells the program end current iteration, and continue next iteration.\nThe author advise to use the break, continue statement or early return when they simplify the loop logic."
  },
  {
    "objectID": "c7_flow_error.html#sec-halts",
    "href": "c7_flow_error.html#sec-halts",
    "title": "8  Control flow and Error Handling",
    "section": "8.7 Halts",
    "text": "8.7 Halts\nThe last category of flow control statement is halt: terminates the program.\n\n8.7.1 The std::exit() function\nIt terminates the program normally. The term normal termination means that the program exits in an expected way; it does not imply about whether the program was successful or not.\nstd::exit() cleans up some static storage objects, returned back to OS.\nThe program does not execute any statements after std::exit().\nstd::exit() does not clean up local variables in the current function or up in the call stack.\nFunction std::atexit() take the arguments as functions to remember to do the clean up when we call std::exit().\n\n\n8.7.2 std::abort()\nThis function ends the program abnormally. It means that the program has some kind of unusual runtime error and could not continue to run.\n\n\nCode\n#include <cstdlib> // for std::abort()\n#include <iostream>\n\nint main()\n{\n    std::cout << 1 << '\\n';\n    std::abort();\n\n    // The following statements never execute\n    std::cout << 2 << '\\n';\n\n    return 0;\n}\n\n\nIt does not clean up anything.\n\n\n\n\n\n\nOnly use a halt if there is no safe way to return normally from the main function."
  },
  {
    "objectID": "c7_flow_error.html#introduction-to-testing-the-code",
    "href": "c7_flow_error.html#introduction-to-testing-the-code",
    "title": "8  Control flow and Error Handling",
    "section": "8.8 Introduction to testing the code",
    "text": "8.8 Introduction to testing the code\n\n8.8.1 Test your programs in small pieces\nWe should write small functions (or classes), and then compile and test immediately. This test is call unit testing; each unit test assures a correct-particular behavior of that unit.\nThese are some method to test your unit code:\n\n8.8.1.1 Informal testing\nYou write your function and run it with some inputs to see whether it runs as expected or not.\nWe have a function that check whether a character is lower Vowel, then we add some character to see that it works well\n\n\nCode\n#include \"io.h\"\n#include <iomanip>\n#include <iostream>\n\nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << isVowvel('0') << '\\n';\n\n    return 0;\n}\n\n\n\n\n8.8.1.2 Preserving your tests\nInstead of testing informal, we can write a program to test the unit function.\n\n\nCode\nvoid testVowel()\n{\n    std::cout << \"Choose 'a': \" << isVowvel('a') << '\\n';\n    std::cout << \"Choose 'b': \" << isVowvel('b') << '\\n';\n}"
  },
  {
    "objectID": "c7_flow_error.html#common-semantic-errors-in-c",
    "href": "c7_flow_error.html#common-semantic-errors-in-c",
    "title": "8  Control flow and Error Handling",
    "section": "8.9 Common semantic errors in C++",
    "text": "8.9 Common semantic errors in C++\nSemantic errors means that the codes do not do what we intended, and it leads to undefined behavior. There are some common semantic errors:\n\nConditional logic errors: errors occurs when the programmer incorrectly codes the logic of a conditional statement or loop condition.\nInfinite loop\nOff-by-one errors: counter are not correctly condition\nIncorrect operator precedence\nInteger division\nAccidental null statements\nNot using compound statement when one is required"
  },
  {
    "objectID": "c7_flow_error.html#detecting-and-handling-errors",
    "href": "c7_flow_error.html#detecting-and-handling-errors",
    "title": "8  Control flow and Error Handling",
    "section": "8.10 Detecting and handling errors",
    "text": "8.10 Detecting and handling errors\nMost errors occur due to faulty assumptions made by the programmer and/or lack of proper error detection/handling:\n\nAssume about return value\nAssume that user give correct input\nAssume that function is called correctly\n\nThus, we need to learn about error handling strategies (what to do when things go wrong) inside a function.\nFunctions may fail for many reasons and there is no best way to handle an error. There are 4 general strategies that can be used:\n\n8.10.1 Handling the error within the function\nWe correct the error in the same function which the error occurred so that the error can be contained and corrected without impacting any code outside function:\n\n\nCode\nvoid printDivision(int numerator, int demonator)\n{\n    if (demonator != 0)\n        std::cout << static_cast<double>(numerator) / demonator << '\\n';\n    else\n        std::cerr << \"Error: Could not divide by zero\\n\";\n}\n\n\n\n\n\n\n\n\nThe handling print the error message out, and then the program continue to run the next statements in the caller.\nWhen we added a halt, it stops entire program.\n\n\n\n\n\n8.10.2 Passing error back to the caller\nAs the above handling, the called function does not return anything to the calling function. If we want to pass the error to caller function, we should create a handling that return a value so that the caller function knows whether the called function runs correctly or not.\n\n\n8.10.3 Fatal errors\nIn some case, the error is severe that we have to stop the program (non-recoverable), we can use the halt statement such as std::exit():\n\n\nCode\nvoid printDivision(int numerator, int demonator)\n{\n    if (demonator != 0)\n        std::cout << static_cast<double>(numerator) / demonator << '\\n';\n    else\n    {\n        std::cerr << \"Error: Could not divide by zero\\n\";\n        std::exit(1);\n    }\n}"
  },
  {
    "objectID": "c7_flow_error.html#stdcin-and-handling-invalid-input",
    "href": "c7_flow_error.html#stdcin-and-handling-invalid-input",
    "title": "8  Control flow and Error Handling",
    "section": "8.11 std::cin and handling invalid input",
    "text": "8.11 std::cin and handling invalid input\nA robust program anticipate the misuse from users and provide way to handle those program at the first place.\n\n8.11.0.1 std::cin, buffers, and extraction\nstd::cin let user enter a value. This value is then stored temporarily inside of std::cin and waits for extracting to a variable. They call it buffer. The operator>> is an extraction to get the value in buffer into the variable. Normally, a value or a character is taken out, if there is still information in the buffer, that information is still there for the next extraction.\nFor example, if there is “5a” in buffer and we extract to variable x, then x = ‘5’ and ‘a’ is in the buffer for the next extraction.\nWe write a program to illustrate the following error cases:\n\n\nCode\n#include <iostream>\n\ndouble getDouble()\n{\n    std::cout << \"Enter a double value: \";\n    double x{};\n    std::cin >> x;\n    return x;\n}\n\nchar getOperator()\n{\n    std::cout << \"Enter one of the following: +, -, *, or /: \";\n    char op{};\n    std::cin >> op;\n    return op;\n}\n\nvoid printResult(double x, char operation, double y)\n{\n    switch (operation)\n    {\n    case '+':\n        std::cout << x << \" + \" << y << \" is \" << x + y << '\\n';\n        break;\n    case '-':\n        std::cout << x << \" - \" << y << \" is \" << x - y << '\\n';\n        break;\n    case '*':\n        std::cout << x << \" * \" << y << \" is \" << x * y << '\\n';\n        break;\n    case '/':\n        std::cout << x << \" / \" << y << \" is \" << x / y << '\\n';\n        break;\n    }\n}\n\nint main()\n{\n    double x{ getDouble() };\n    char operation{ getOperator() };\n    double y{ getDouble() };\n\n    printResult(x, operation, y);\n\n    return 0;\n}\n\n\n\n\n8.11.0.2 Error case 1: Input extraction succeeds but the input is meaningless to the program\nFor example, users enter x = 5, y = 2 and operator = ‘k’. These inputs are attracted successfully to variable but we cannot operate the function.\nWe solve this case by doing input validation:\n\n\nCode\nhar getOperator()\n{\n    while (true)\n    {\n        std::cout << \"Enter one of the following: +, -, *, or /: \";\n        char op{};\n        std::cin >> op;\n\n        switch (op)\n        {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n            return op;\n        default:\n            std::cerr << \"Error: Operator is not valid. Please try again.\\n\";\n        }\n    }\n}\n\n\n\n\n8.11.0.3 Error case 2: Extraction succeeds but with extraneous input\nFor example, user enters 5*7, the programs run and return 35 but does not lead user continue enter the input because *7\\n is stored in buffer for the following operator>>.\nTo solve this error, we have to tell the program ignore all the following character until the next \\n. In C++, we use the function std::cin.ignore(num_char_to_ignore, \\n) or better is std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n)\n\n\nCode\nvoid ignoreLine()\n{\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n}\n\n\nThen call the function in get input function:\n\n\nCode\ndouble getDouble()\n{\n    std::cout << \"Enter a double: \";\n    double x{};\n    std::cin >> x;\n    ignoreLine();\n    \n    return x;\n}\n\n\n\n\n8.11.0.4 Error case 3: Extraction fails\nThis case happens when we enter a double value by a value with different type eg.: a. The operator>> cannot cover it to a double, so it let a in the buffer and goes into fail mode. Then, further requests for input extraction will silently fail. Thus, the output prompt still prints, but the input prompt is skipped, and we get stuck in infinite loop.\nWe solve the problem by:\n\nTest whether the std::cin is fail: !std::cin\nIf it is fail, put it back to normal state: std::cin.clear()\nFlush the buffer so we can enter the new value: ignoreLine()\n\n\n\nCode\nif (!std::cin)\n{\n    std::cin.clear();   #// put back to normal mode\n    ignoreLine();       #// and remove bad input\n}\n\n\n\n\n8.11.0.5 Error case 4: Extraction succeeds but the user overflows a numeric value"
  },
  {
    "objectID": "c7_flow_error.html#assert-and-static_assert",
    "href": "c7_flow_error.html#assert-and-static_assert",
    "title": "8  Control flow and Error Handling",
    "section": "8.12 Assert and static_assert",
    "text": "8.12 Assert and static_assert\nReturn to the program:\n\n\nCode\nvoid printDivision(int numerator, int demonator)\n{\n    if (demonator != 0)\n        std::cout << static_cast<double>(numerator) / demonator << '\\n';\n    else\n    {\n        std::cerr << \"Error: Could not divide by zero\\n\";\n    }\n}\n\n\nThe program checks whether we divide a number by a zero. This is a semantic error and will cause the program to crash down.\nWe link to the session Section 8.7 for ideas on std::exit() and std//abort().\n\nIf we skip the offending statements, the error fails silently. This is bad for programming because we do not know where the error message is and how the conditions that triggered the error message.\nIf we terminate the program by std::exit(), we loses our call stack and any debugging information. std::abort() is a better option for such cases when the we can start debugging at the point where the program aborted.\n\n\n8.12.0.1 Precondition, Invariant, Postcondition\nIt is any condition that must always be true prior to the execution of codes’ component.\nInvariant is a condition must be true while some component is executing\nPostcondition is something that must be true after the execution of some component of code.\n\n\n8.12.1 Assertions\nAn assertion is an expression that will be true unless there is a bug in a program. If the expression is true, the assertion statement does nothing, otherwise, an error message is displayed and the program is terminated (via std::abort()). The error message contains: failed as text, name of code file, and the line number of the assertion.\nTo use assertion, we include header assert. Let look at the following codes:\n\n\nCode\n#include <cassert>\n#include <cmath>\n#include <iostream>\n\n    double calculateTimeUntilObjectHitsGround(double initialHeight, double gravity)\n    {\n        assert(gravity > 0.0);\n\n        if (initialHeight <= 0.0)\n        {\n            return 0.0;\n        }\n\n        return std::sqrt((2.0 * initialHeight) / gravity);\n    }\n\n\n\nMake the assert statements be descriptive:\n\n\n\nCode\nassert(found && \"Car could not be found in database\")\n\n#// If `found == false`, then FALSE && TRUE is FALSE,  this trigger assert\n\n\n\n8.12.1.1 Asserts and Error handling\nAssertions: to catch the programming errors by documenting something that should never happen. If it does happen, the the programmer made an error somewhere, it identifies and fixes. It does not allow recovery from errors.\nError handling: gracefully handle case that could happen (rarely). There may or may not be recoverable, but the program’s users may encounter them.\n\n\n8.12.1.2 static_assert\nA static_assert checks the condition at the compile-time. It formula is static_assert(condition, diagnostic_message). ## Introduction to random numer generation\nComputer are generally incapable of generating truly random numbers. It simulates randomness using an algorithm.\n\n\n\n8.12.2 Algorithms and state\n\n8.12.2.1 Algorithm:\n\nIt is an instruction’s sequence to solve a demand and provide useful results.\nIt is reusable\nIn C++, algorithms are typically implemented as reusable functions.\n\nHere is an example:\n\n\nCode\nint plusOne()\n    {\n        static int s_state{ 3 };\n\n        ++s_state;\n\n        return s_state;\n    }\n\n\nAn algorithm is stateful if it retains some information across calls. A stateless algorithm does not store any information. Our plusOne() is stateful because it creates a static variable that is used through its call.\nThe plusOne() is deterministic: given input, it will always produce the same output.\n\n\n\n8.12.3 Pseudo-random number generators (PRNGs)\nThis is a very simple PRNGs:\n\n\nCode\n#include \"random.h\"\n\nint LCG16()\n{\n    static int s_state{ 5323 };\n    s_state = 8253729 * s_state + 2396403;\n\n    return s_state % 32768;\n}\n\n\nThis function returns the same random sequence.\n\n8.12.3.1 Seeding a PRNG\nThe sequence of “random number” is not random. It is based on the initial state. The same initial state will generate same output sequence.\nWhen PRNG is instantiated, an initial value called a random seed can be provided to the initial state of the PRNG.\n\n\n8.12.3.2 What makes a good PRNG?\n\nThe PRNG should generate each number with approximately same probability.\nThe method by which the next number in the sequence should be unpredictable.\nIt should represent the distribution of number\nIt should have a high period for all seed\n\nAll PRNG are periodic: the sequence of numbers will repeated itself. The length of sequence before a PRNG begins to repeat itself is known as the period."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\nCode\n1 + 1\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "C1_Introduction.html#sec-statements",
    "href": "C1_Introduction.html#sec-statements",
    "title": "2  Introduction to C++",
    "section": "2.1 Statements",
    "text": "2.1 Statements\nStatements are the instructions that cause the program to perform some actions. Most of the statements end with semicolon."
  },
  {
    "objectID": "C1_Introduction.html#function",
    "href": "C1_Introduction.html#function",
    "title": "2  Introduction to C++",
    "section": "2.2 Function",
    "text": "2.2 Function\nIn C++, statements are typically grouped into units called functions. Function is a collection of statements that execute sequentially (in order, from top to bottom).\nFunctions are written to do a specific tasks."
  },
  {
    "objectID": "C1_Introduction.html#syntax-and-syntax-error",
    "href": "C1_Introduction.html#syntax-and-syntax-error",
    "title": "2  Introduction to C++",
    "section": "2.3 Syntax and syntax error",
    "text": "2.3 Syntax and syntax error\nSyntax is the rules how the programs must be constructed in order to be considered valid. If we violate a rule, the compiler will complain and issue a syntax error.\nProgram’s compilation will only complete once all syntax errors are resolved."
  },
  {
    "objectID": "C1_Introduction.html#comments",
    "href": "C1_Introduction.html#comments",
    "title": "2  Introduction to C++",
    "section": "2.4 Comments",
    "text": "2.4 Comments\nA comment is a programmer-readable note inserted directly into a source code of the program (compiler ignores the comments).\nSingle-line comments: // symbol begins a C++ single-line comment.\nMulti-line comments: /* and */ pair of symbols denotes a multi-line comment.\nProper use of comments\n\nDescribe what the library, program, or functions, do. These are typically placed on the top of the file or library.\nSecond, inside the lib, program, or function, comments are used to describe how the code is going to accomplish the goal.\nThird, at the statement level, comments can describe why the code is doing something. The bad statement comment describe what the code is doing.\n\nComments are good way to remind the reason a programmer made one decision instead of another.\n\n\n\n\n\n\nBest practice\n\n\n\n\n\nComment your code liberally, and write your comments as if speakings to someone who has no idea what the code does. Don’t assume that you’ll remember why you mad specific choices.\n\n\n\nYou can also comment out the code block if:\n\nYou’re working on a new piece of code that won’t compile yet.\nYou have written a new code that results the errors and you do not have time to fix it.\nTo find the source of the errors.\nYou want to replace one piece of code with another piece of code.\n\nSummary\n\nAt the library, program, or function level, use comments to describe what.\nInside them, use comments to describe how.\nAt the statement level, use comments to describe why."
  },
  {
    "objectID": "C1_Introduction.html#sec-intro_var",
    "href": "C1_Introduction.html#sec-intro_var",
    "title": "2  Introduction to C++",
    "section": "2.5 Objects and Variables",
    "text": "2.5 Objects and Variables"
  },
  {
    "objectID": "C1_Introduction.html#data",
    "href": "C1_Introduction.html#data",
    "title": "2  Introduction to C++",
    "section": "2.6 Data",
    "text": "2.6 Data\nIn Section 2.1, statements inside function perform actions that generate whatever result the program was designed to produce.\nBut, how do programs actually produce results?: bref, by manipulating data.\nIn computing, data is any information that can be moved, processed and stored by computer.\n\n\n\n\n\n\nKey insight\n\n\n\n\n\nPrograms are collections of instructions that manipulate data to produce a desired results.\n\n\n\nA program can acquire data to work in many ways: file, database, network, user providing input on keyboard, or from the programmer putting data directly into a source code.\nData on computer is typically stored in a efficient format (and thus is not human readable).\n\n2.6.1 Objects and variables\n\nA single piece of data stored in memory somewhere is called value.\nAn object is a region of storage that has a value and other associated properties. We use the object to store and retrieve values.\nObjects can be named or unnamed. A named object is called variable, the name of object is call identifier.\n\n\n\n2.6.2 Variable instantiation\nTo create a variable, we have to define it. Here is an example of defining a variable named x:\n\n\nCode\nint x;\n\n\nWhen the program run, it will instantiate the variable: object will be created and assigned a memory address. Variable must be instantiated before they can be used to store value.\n\n\n2.6.3 Data types\nVariables are named region of storage that can store value. A data type tells the compiler what type of value the variable will be store.\n\n\n2.6.4 Define multiple variables\nWe can define muliple variables in one statement by separating them by ,.\n\n\nCode\nint a, b;\n\n\nBut, variables of different types must be defined in separate statements:\n\n\nCode\nint a, double b;  # false\nint a; double b;  # correct\n\n# Correct and recommended\nint a;\ndouble b;\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nAvoid defining multiple variables of the same type in a simple statement. Instead, define each variable in a separate statement on it own line"
  },
  {
    "objectID": "C1_Introduction.html#variable-assignment-and-initialization",
    "href": "C1_Introduction.html#variable-assignment-and-initialization",
    "title": "2  Introduction to C++",
    "section": "2.7 Variable assignment and initialization",
    "text": "2.7 Variable assignment and initialization\nIn previous session Section 2.5, we know how to define a variable. In this session, we’ll explore how to actually put values into variables and use those values.\nRecall the variable’s definitions:\n\n\nCode\nint x;\nint y;\nint z;\n\n\n\n2.7.1 Variable assignment\nAfter variable has been defined, you can give it a value by using =, copy assignment or assignment.\n\n\nCode\n#include <iostream>\n\nint main() {\n  \n  int width;\n  width = 5;  // copy assignment of value 5 into variable width\n\n  width = 7;\n  \n  return 0;\n}\n\n\n\n\n2.7.2 Initialization\nWith initialization, we can define and assign value to variable as the same time. There are many ways to initiate:\n\n\nCode\nint a;\nint a = 5;  #copy initialization\nint c( 6 )  # direct initialization\n\n# List initialization methods\nint d { 7 };\nint e = { 8 };\nint f {}\n\n\n\n2.7.2.1 Default initialization\nWe do not provide any initialization value.\n\n\n2.7.2.2 Copy initialization\nWith =: copy the value on the right-hand side of the equals into the variable being created. It does not use much in modern C++.\n\n\n2.7.2.3 Direct initialization\nSimilar to copy initialization, not popular in modern C++.\n\n\n2.7.2.4 List initialization\nThis is the modern way to initialize. Prior to this, some types of initialization require using the direct one, and other types required indirect one. The list initialization introduce to provide more consistent initialization syntax.\nList initialization disallows “narrowing conversion”: return errors if we initialize a variable using a value that the variable cannot safely hold:\n\n\nCode\nint width { 4.5};   # return error\n\n\n\n\n\n\n\n\nBest practice\n\n\n\n\nFavor list initialization whenever possible.\nInitialize your variables upon creation."
  },
  {
    "objectID": "C1_Introduction.html#introduction-to-iostream-cout-cin-and-endl",
    "href": "C1_Introduction.html#introduction-to-iostream-cout-cin-and-endl",
    "title": "2  Introduction to C++",
    "section": "2.8 Introduction to iostream: cout, cin, and endl",
    "text": "2.8 Introduction to iostream: cout, cin, and endl\n\n2.8.1 The input and output (io) library\nio library is part of C++ standard library that works with inpur and output. We use the functionality in iostream to get input from keyboard and output data to console.\nWe use the library by including it:\n\n\nCode\n#include <iostream>\n\n\nOne of the most useful is std::cout: send data to the console to be printed as text\n\n\nCode\n#include <iostream>\n\nint main()\n{\n  std::cout << \"Hello World!\\n\";\n  \n  return 0;\n}\n\n\nIt can print a number too:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n  std::cout << 4;\n  \n  return 0;\n}\n\n\nIt can print value of a variable:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n  int x{ 5 };\n  std::cout << x;\n  \n  return 0;\n}\n\n\nTo print more than one thing in the same line:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    std::cout << \"x is equal to \" << x;\n\n    return 0;\n}\n\n\nUse std::endl to make the cursor in the next line.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    std::cout << \"Hi!\" << std::endl;\n    std::cout << \"My name is Huy.\" << std::endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nOutput a newline whenever a line of output is complete.\n\n\n\n\n2.8.2 std::cout is buffered\nStatements request that output be sent to the console. However, output is typically not sent to the console immediately. Instead, the requested output gets in line, and is stored in a region of memory set aside to collect later, called buffer. Periodically, buffer is flushed, all data is transferred to its destination.\n\n\n2.8.3 std::endl vs \\n\nstd::endl move the cursor to the next line and flushes the buffer. Sometimes, we do not need to flush the buffer and prefer the system do it periodically.\nThus, use of \\n is preferred instead:\n\n\n\n\n\n\nBest practice\n\n\n\nPrefer \\n over std::endl when ouputing text to the console.\n\n\n\n\n2.8.4 std::cin\nstd::cin reads the data from keyboard using extraction operator >>.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter a number: \";\n    \n    int x{ };\n    std::cin >> x;\n\n    std::cout << \"You endtered: \" << x << '\\n';\n    return 0;\n}\n\n\nWe can input many variables in the same line:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter two numbers separated by a space: \";\n    \n    int x{ };\n    int y{ };\n    std::cin >> x >> y;\n\n    std::cout << \"You entered \" << x << \" and \" << y << \".\\n\";\n    std::cout << \"Thank you!\\n\";\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nInitialize variable first, then use std::in."
  },
  {
    "objectID": "C1_Introduction.html#uninitialized-variables-and-undefined-behavior",
    "href": "C1_Introduction.html#uninitialized-variables-and-undefined-behavior",
    "title": "2  Introduction to C++",
    "section": "2.9 Uninitialized variables and undefined behavior",
    "text": "2.9 Uninitialized variables and undefined behavior\nC++ does not initialize the variable automatically. Thus, when a variable is given a memory address to use to store data, the default value of that variable is whatever value happens to already be in that memory address.\nLet be clear that:\n\nInitialization = the object is given a known value at the point of definition.\nAssignment = The object is given a known value beyond the point of definition\nUninitialized = The object has not been given a known value yet.\n\nIn some case, we do not know what the value printed from the following code because uninitialized x is given any value.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x;\n    std::cout << x << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nUsing uninitialized is one of the most common mistakes\n\n\n\n\n2.9.1 Undefined behavior\nUninitialized variables are one example of undefined behavoir: we cannot know the results, or they can change, be incorrect, sometime correct, or crash."
  },
  {
    "objectID": "C1_Introduction.html#basic-formatting",
    "href": "C1_Introduction.html#basic-formatting",
    "title": "2  Introduction to C++",
    "section": "2.10 Basic formatting",
    "text": "2.10 Basic formatting\nThe recommendations for basic formatting:\n\nIt fine to use either tab or spaces for indentation.\nFunction braces can be:\n\n\n\nCode\nint main() {\n}\n\n\nor\n\n\nCode\nint main() \n{\n}\n\n\nThe author recommended the later.\n\nEach statement should start one tab from the opening space.\nLine should not be too long. Typically, 80 characters is the maximum length in a line.\nIf line is too long, split with an operator (eg. +, -). The operator should be placed at the beginning of the next line.\nUse whitespaces to make the code easier to read."
  },
  {
    "objectID": "C1_Introduction.html#literals-and-operators",
    "href": "C1_Introduction.html#literals-and-operators",
    "title": "2  Introduction to C++",
    "section": "2.11 Literals and operators",
    "text": "2.11 Literals and operators\n\n2.11.1 Literals\nLiteral is a fixed value that has been inserted directly into the source code.\n\n\n2.11.2 Operators\nOperator is the specific operation to be performed.\n\n\n2.11.3 Return values and side effects\nAn operator that has some observable effect beyond producing return value is said to have a side effect. For example, x = 5 is evaluated, side effect is to assign 5 to x; the changed value of x is observable, or std::cout << too."
  },
  {
    "objectID": "C1_Introduction.html#expression",
    "href": "C1_Introduction.html#expression",
    "title": "2  Introduction to C++",
    "section": "2.12 Expression",
    "text": "2.12 Expression\nExpression is a combination of literals, variables, operators, and function calls that calculates a single value.\nThe process of executing an expression is called evaluation. The single value is called result.\nExpressions do not end in a semicolon, and cannot be compiled by themselves (they must exist within a statement), example that\n\n\nCode\nint x{ 2 + 3 } ;\n\n\n2 + 3 is an expression and do not need a semicolon.\nExpressions also involve operators with side effects:\n\n\nCode\nx = 5;\nx = 2 + 3;\nstd::cout << x;\n\n\n\n2.12.1 Expression statement\nExpression cannot compile by itself. We can add = to make it compile. We call this expression statement, an expression following by a semicolon.\n\n\n2.12.2 Useless expression statements\nWe can make an expression without assigning or having any side effect, such that\n\n\nCode\n2 * 3"
  },
  {
    "objectID": "C1_Introduction.html#developing-first-program",
    "href": "C1_Introduction.html#developing-first-program",
    "title": "2  Introduction to C++",
    "section": "2.13 Developing first program",
    "text": "2.13 Developing first program\n\n2.13.1 Multiply by 2\n\n\n\n\n\n\nBest practice\n\n\n\nNew programmers often try to write an entire program all at once, and then get overwhelmed when it produces a lot of errors. A better strategy is to add one piece at a time, make sure it compiles, and test it. Then when you’re sure it’s working, move on to the next piece.\n\n\nThere are many solutions, from bad to good. Let take time to find the good one (not override input value, avoid complexity).\n\nWe should firstly try to make the program work\nThen, spend time to cleanup the code.\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n    \n    int num{ };\n    std::cin >> num;\n    \n    std::cout << \"Double \" << num << \" is: \" << num * 2 << \".\\n\";\n    std::cout << \"Triple \" << num << \" is: \" << num * 3 << \".\\n\";\n\n    return 0;\n}"
  },
  {
    "objectID": "C2_function_file.html#introduction-to-functions",
    "href": "C2_function_file.html#introduction-to-functions",
    "title": "3  Funtions and Files",
    "section": "3.1 Introduction to functions",
    "text": "3.1 Introduction to functions\nA function is a reusable sequence of statements designed to do a particular job. Function allows us to split the program into small, modular chunks which are easier to organize, test, and use. Besides the standard library of C++, we can write our own function, called user-defined function.\nWhen a program is executing the statements sequentially inside one function and encounters a function call. A function call is an expression that tells CPU to interrupt the current function and execute another function. The CPU put a bookmark at the current point of execution, and then calls the function.\nThe function initiating the function call is the caller, the other is called function.\n\n3.1.1 An example of a user-defined function\nThe general syntax of function:\n\n\nCode\n#| label: func_syntax\nreturnType functionName() # This is function header\n{\n  # This is body of the function\n}\n\n\nThe first line is function header telling the compile that the function exists.\n\nIn this session, returnType of int for main() and void otherwise.\nfunctionName is name of user-defined function.\n\nLet see the example function:\n\n\nCode\n#| label: func_doPrint\n\n#include <iostream>     // for std::cout\n\n// Definition of user-defined function doPrint()\nvoid doPrint()\n{\n    std::cout << \"In doPrint() \\n\";\n}\n\nint main()\n{\n    std::cout << \"Starting main() \\n\";\n    doPrint();\n    std::cout << \"Ending main() \\n\";\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDo not forget to include parentheses () after the function’s name when making a function call.\n\n\n\n\nFunction can be called more than one time in a caller.\nAny functions can call any other functions:\n\n\n\nCode\n#| label: func_call_func\n\n#include <iostream>     // for std::cout\n\n// Definition of user-defined function doPrint()\nvoid doB()\n{\n    std::cout << \"In doB() \\n\";\n}\n\nvoid doA()\n{\n    std::cout << \"Starting doA()\\n\";\n    doB();\n    std::cout << \"Ending doA()\\n\";\n}\n\nint main()\n{\n    std::cout << \"Starting main() \\n\";\n    doA();\n    std::cout << \"Ending main() \\n\";\n\n    return 0;\n}\n\n\n\nNested functions are not supported: we cannot decide a function inside another function.\n\n\n\nCode\n#include <iostream>\n\nint main() \n{\n  void foo()  # Illegal: this function is nested inside function main()\n  {\n    std::cout << \"foo!\\n\";\n  }\n  \n  foo();\n  return 0;\n}\n\n\nThe right way to write is\n\n\nCode\nvoid foo() \n{\n    std::cout << \"foo!\\n\";\n}\n\nint main()\n{\n    foo();\n    return 0;\n}\n\n\n\n\n3.1.2 Function return values (value-returning functions)\nIf we want to write a program that get number from user, then double it and return value to the console, we can start with:\n\n\nCode\n#include <iostream>     // for std::cout\n\nint main()\n{\n    // get a value from user\n    std::cout << \"Enter an integer: \";\n    int num{};\n    std::cin >> num;\n\n    // print the value doubled\n    std::cout << num << \" doubled is: \" << num * 2 << '\\n';\n\n    return 0;\n}\n\n\nWe can also write a function that get value from user and let main() calls that function to double it:\n\n\nCode\n#include <iostream>     // for std::cout\n\n#| label: cod_problem\nvoid getValueFromUser()\n{\n    std::cout << \"Enter an integer: \";\n    int input{};\n    std::cin >> input;\n}\n\nint main()\n{\n    getValueFromUser();\n\n    int num{};\n\n    std::cout << num << \" double is: \" << num * 2 << '\\n';\n\n    return 0;\n}\n\n\nWhile this program is a good solution, it always returns 0 because the value from getValueFromUser() is not stored. We need that function return a value.\nThe function return a value require two conditions:\n\nDefine the return type before the name of the function.\nA return statement in the body of the function. The function exits immediately, and a copy of return value backs to the caller. This is return by value process.\n\nLet look at an example:\n\n\nCode\n#include <iostream>\n\nint returnValueFive()\n{\n  return 5;\n}\n\nint main()\n{\n  std::cout << returnValueFive() << '\\n';\n  std::cout << returnValueFive() + 2 << '\\n';\n  \n  returnValueFive();\n  \n  return 0;\n}\n\n\n\n\n\n\n\n\nWhen a called function returns a value, the caller may decide to use that value in an expression or statement(e.g by assigning it to a variable, or sending it to std::cout).\n\n\n\n\n\n3.1.3 Fixing our challange program\nNow, we return to the problem and use the code:\n\n\nCode\n#include <iostream>\n\nint getValueFromUser() // this function now returns an integer value\n{\n    std::cout << \"Enter an integer: \";\n    int input{};\n    std::cin >> input;\n\n    return input; // return the value the user entered back to the caller\n}\n\nint main()\n{\n    int num { getValueFromUser() }; // initialize num with the return value of getValueFromUser()\n\n    std::cout << num << \" doubled is: \" << num * 2 << '\\n';\n\n    return 0;\n}\n\n\n\n\n3.1.4 Revisiting main()\nWhen we run a program, the operating system calls the function main(). It executes the main() from the top to bottom sequentially. Finally, main() returns an integer value (usually 0), and the program terminates. The return value from mmain() is called status code, and indicates that the program is successful or fail.\n\n\n\n\n\n\nBest practice\n\n\n\n\nThe main function should return the value 0 if the program an normally.\nMake sure the functions with non-void return types return a value in all cases.\nFailure to return a value from a value-returning function will cause undefined behavior.\n\n\n\n\n\n\n\n\n\n\nFunction main will implicitly return 0 if no return statement is provided. Thus, it is recommended to explicitly state the return value.\nFunction can only return a single value. It can return not only literal, but also a variable or a call to function that return single value.\nThe function author can decide what the return value means (status code, single value). It is good to document the function with a comment indicating what the return values mean.\n\n\n\n\n\n\n3.1.5 Reusing functions\nWe can illustrate a good case for function reuse:\n\n\nCode\n#include <iostream>\n\n// Create a function that return an integer value from user's keyboard\nint main()\n{\n    int x{};\n    std::cout << \"Enter an integer: \";\n    std::cin >> x;\n\n    int y{};\n    std::cout << \"Enter second integer: \";\n    std::cin >> y;\n\n    std::cout << x << \" + \" << y << \" = \" << x + y << '\\n';\n\n    return 0;\n}\n\n\nThe central tenets of good programming: Don’t Repeat Yourself (DRY). Let create a function:\n\n\nCode\n#include <iostream>\n\n// Create a function that return an integer value from user's keyboard\nint getValueFromUser()\n{\n    int input{};\n    std::cout << \"Enter an integer: \";\n    std::cin >> input;\n\n    return input;\n\n}\n\n// main function return the sum of two integers from user\nint main()\n{\n    int x{ getValueFromUser() };\n    int y{ getValueFromUser() };\n\n    std::cout << x << \" + \" << y << \" = \" << x + y << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nDon’t repeat yourself. IF you need to do something more than once time, consider how to modify the code to remove as much as redundancy as possible."
  },
  {
    "objectID": "C2_function_file.html#void-functions",
    "href": "C2_function_file.html#void-functions",
    "title": "3  Funtions and Files",
    "section": "3.2 Void functions",
    "text": "3.2 Void functions\nFunctions are not required to return a value to the caller, we use the return type of void. For example:\n\n\nCode\n#include <iostream>\n\nvoid printHi()\n{\n    std::cout << \"Hi!\\n\";\n}\n\nint main()\n{\n    printHi();\n\n    return 0;\n}\n\n\nThe function printHi() prints “Hi!”, but does not need to return anything back to the caller. A function that does not return a value is called a non-value returning function (void-function).\n\n\n\n\n\n\nBest practice\n\n\n\nDo not put a return statement at the end of a non-value returning function.\n\n\n\nVoid functions can’t be used in expression that require a value\nConsider the following program:\n\n\nCode\n#include <iostream>\n\nvoid printHi()\n{\n    std::cout << \"Hi!\\n\";\n}\n\nint main()\n{\n    printHi();\n\n    std::cout << printHi();\n\n    return 0;\n}\n\n\nAn error occurs because the printHi() does not return value so it cannot provide the value to std::cout to print out.\nReturning a value from a void function is a compile error.\n\nEarly return\n\na return statement that is not the last statement in a function is called an early return. For example:\n\n\n\n\nCode\n#include <iostream>\n\nvoid print()\n{\n    std::cout << \"A\";\n\n    return;\n\n    std::cout << \"B\";\n}\n\nint main()\n{\n    print();\n\n    return 0;\n}\n\n\nThe program returns “A” because it does not reach to second statements in `print()."
  },
  {
    "objectID": "C2_function_file.html#introduction-to-function-parameters-and-arguments",
    "href": "C2_function_file.html#introduction-to-function-parameters-and-arguments",
    "title": "3  Funtions and Files",
    "section": "3.3 Introduction to function parameters and arguments",
    "text": "3.3 Introduction to function parameters and arguments\n\n3.3.1 The problem\nWe start by the codes:\n\n\nCode\n#include <iostream>\n\nvoid print()\n{\n    std::cout << \"A\";\n\n    return;\n\n    std::cout << \"B\";\n}\n\nint main()\n{\n    print();\n\n    return 0;\n}\n\n\nWe want to have a function that prints a doubled number:\n\n\nCode\n#include <iostream>\n\nint getValueFromUser()\n{\n    std::cout << \"Enter an integer: \";\n    int input{};\n    std::cin >> input;\n\n    return input;\n}\n\nvoid printDouble()\n{\n    std::cout << num << \" doubled is: \" << num * 2 << '\\n';\n}\n\nint main()\n{\n    int num{ getValueFromUser() };\n\n    std::cout << num << \" doubled is: \" << num * 2 << '\\n';\n\n    return 0;\n}\n\n\nThe compiler does not know the definition of num in the function. Then, we can\n\n\nCode\n#include <iostream>\n\nint getValueFromUser()\n{\n    std::cout << \"Enter an integer: \";\n    int input{};\n    std::cin >> input;\n\n    return input;\n}\n\nvoid printDouble()\n{\n    int num{};\n    std::cout << num << \" doubled is: \" << num * 2 << '\\n';\n}\n\nint main()\n{\n    int num{ getValueFromUser() };\n\n    printDouble();\n\n    return 0;\n}\n\n\nThe function run normally, but always returns 0 because function printDouble() does not access the input from user. Thus, we need some way to pass the value of variable to printDouble().\n\n\n3.3.2 Function parameters and arguments\nA function parameter: a variable used in header of a function, identically to variables defined inside the function, one difference: they are initialized with a value provided by the caller of the function.\nAn argument is a value that is passed from the caller to the function when a function call is made:\n\n\nCode\nint main()\n{\n    doPrint();\n    printValue(10);\n    add(2, 3);\n\n    return 0;\n}\n\n\nUse the commas for separation multiple arguments, and parameters.\nPass by value: when a function is called, all of the parameters are created as variables, and the value of each of the arguments is copied into the matching parameters.\n\n\nCode\n// This function takes one parameter named x\n// The caller will supply the value of x\nvoid printValue(int x, int y)\n{\n    std::cout << x << '\\n';\n    std::cout << y << '\\n';\n}\n\nint main()\n{\n    printValue(10, 20);\n\n    return 0;\n}\n\n\nNow, we come back to our challenge program:\n\n\nCode\n#include <iostream>\n\nint getValueFromUser()\n{\n    std::cout << \"Enter an integer: \";\n    int input{};\n    std::cin >> input;\n\n    return input;\n}\n\nvoid printDouble(int input)\n{\n    std::cout << input << \" doubled is: \" << input * 2 << '\\n';\n}\n\nint main()\n{\n    int num{ getValueFromUser() };\n    printDouble(num);\n\n    // printDouble(getValueFromUser());\n\n    return 0;\n}\n\n\nThe arguments can be also the expression, the variable:\n\n\nCode\n#include <iostream>\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\nint multiply(int z, int w)\n{\n    return z * w;\n}\n\nint main()\n{\n    std::cout << add(5, 6) << '\\n';\n    std::cout << add(2 + 3, 3 * 4) << '\\n';\n\n    int a{ 5 };\n    std::cout << add(a, a) << '\\n';\n\n    std::cout << add(2, multiply(2, a)) << '\\n';\n    std::cout << multiply(add(1, 3), multiply(2, 3)) << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "C2_function_file.html#sec-localScope",
    "href": "C2_function_file.html#sec-localScope",
    "title": "3  Funtions and Files",
    "section": "3.4 Introduction to local scope",
    "text": "3.4 Introduction to local scope\n\n3.4.1 Local variables\nFunction parameters as well as all variables defined inside the function body, are local variables.\nLocal variables are created at the point of definition and destroyed no earlier than the end of the set of the curly braces in which they are defined. We have definition of object’s lifetime to be the time between its creation and destruction which happen when the program is running (calling runtime), not at compile time.\n\n\nCode\nint add(int x, int y)\n{\n    int z{ x + y };\n\n    return z;\n} // z, y, and x destroyed here\n\n\nHere is an example:\n\n\nCode\n#include <iostream>\n\nvoid doSomething()\n{\n    std::cout << \"Hello!\\n\";\n}\n\nint main()\n{\n    int x{ 0 };\n    doSomething();\n\n    return 0;\n} // x's lifetime ends here\n\n\n\n\n3.4.2 Local scope\nAn identifiers’ scope determines where the identifier can be accessed within the source code. When an identifiers can be accessed, it is in scope, while it we cannot access, it is out of scope. Scope is compile-time property.\nA local variables’ scope begins at the point of value definition, and stops at the end of the set of curly braces in which it is defined. Local variables defined in one function are also not in scope in other functions that are called.\nHere is an example:\n\n\nCode\n#include <iostream>\n\n// x is not in scope anywhere in this function\nvoid doSomething()\n{\n    std::cout << \"Hello!\\n\";\n}\n\nint main()\n{\n    // x can not be used here because it's not in scope yet\n\n    int x{ 0 }; // x enters scope here and can now be used within this function\n\n    doSomething();\n\n    return 0;\n} // x goes out of scope here and can no longer be used\n\n\n\n\n\n\n\n\n\nOut of scope: an identifier cannot be accessed anywhere within the code\nGoing out of scope: for objects, an object goes out of the scope at the end of the scope. A local variable’s lifetime ends at the point where it goes out of scope.\nNot all types of variable are destroyed when they go out of scope.\n\n\n\n\nAnother example:\n\n\nCode\n#include <iostream>\n\nint add(int x, int y) // x and y are created and enter scope here\n{\n    // x and y are visible/usable within this function only\n    return x + y;\n} // y and x go out of scope and are destroyed here\n\nint main()\n{\n    int a{ 5 }; // a is created, initialized, and enters scope here\n    int b{ 6 }; // b is created, initialized, and enters scope here\n\n    // a and b are usable within this function only\n    std::cout << add(a, b) << '\\n'; // calls function add() with x=5 and y=6\n\n    return 0;\n} // b and a go out of scope and are destroyed here\n\n\n\n\n\n\n\n\nKey insight\n\n\n\nNames used for function parameters or variables declared in a function body only visible within the function that declares them. Local variables within a function can be named without regard for the names of variables in other functions. This helps keep functions independent.\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nDefine the local variables as close to their first use as reasonable."
  },
  {
    "objectID": "C2_function_file.html#why-functiona-are-useful-and-how-to-use-them-effectively",
    "href": "C2_function_file.html#why-functiona-are-useful-and-how-to-use-them-effectively",
    "title": "3  Funtions and Files",
    "section": "3.5 Why functiona are useful, and how to use them effectively",
    "text": "3.5 Why functiona are useful, and how to use them effectively\n\n3.5.1 Why use functions?\n\nOrganization:\n\nSimpler the main() function\nA function is a mini-program that we can write separately\nHelp us to have more manageable chunks\n\nRe-usability:\n\nFunction can be called many times within a program\nFollow “Do not repeat yourself” to minimize the copy/paste error\nCan be shared with other program\n\nTesting:\n\nFunctions reduces code redundancy, so less code to test\nFunction is self-contained, when it is tested, we do not need to test it again unless we change it.\nMake easier to find bugs\n\nExtensibility:\n\nWhen we need to extend the program to handle case it didn’t handle before, function allow us to make change in one place\n\nAbstraction:\n\nWe only need: name, inputs, outputs and where it lives.\nDo not need to know how it works, what other code it’s dependent\nReduce the amount of knowledge\n\n\n\n\n3.5.2 Effectively using functions\n\nWhen there are repeated group of statements\nGenerally perform one and only one task"
  },
  {
    "objectID": "C2_function_file.html#forward-declarations-and-definitions",
    "href": "C2_function_file.html#forward-declarations-and-definitions",
    "title": "3  Funtions and Files",
    "section": "3.6 Forward declarations and definitions",
    "text": "3.6 Forward declarations and definitions\nWe start by the simple program:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n    return 0;\n}\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\n\nThe compiler returns error: identifier add is not found. In the program, we defined add after main, and compiler reads the code sequentially so it cannot find add in main. There are two ways to address the issu:\n\n3.6.1 Reorder the function definitions\nWe defined add before main:\n\n\nCode\n#include <iostream>\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\nint main()\n{\n    std::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n    return 0;\n}\n\n\nIt is good in the program. But in larger program, it is difficult to know which functions call which functions. For example, A calls B and B also calls A; we have trouble to find the appropriate order of functions. The second option will solve this problem.\n\n\n3.6.2 Use a forward declaration\nA forward declaration allows us to tell the compiler about the existence of a function before we define the function’s body. The compiler encounter a call to the function, it will understanding and check whether we are calling function correctly, it doesn’t know how or where the function is defined1.\nHere is an example of forward function declaration:\n\n\nCode\n#include <iostream>\n\nint add(int x, int y);\n\nint main()\n{\n    std::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n    return 0;\n}\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\n\nForward declaration also helps to read the code from different files.\n\n\n3.6.3 Declaration and definition\nA definition actually implement (for function or types) or instantiates (for variables) the identifier.\n\n\nCode\nint add(int x, int y)    // implement function add()\n{\n  int x{ }  // instantiates variable\n}\n\n\nA definition is needed to satisfy the linker. The one definition rule (ODR):\n\nWithin a file, a function, a variable, type, or template can only have one definition.\nWithin a given program, a variable or normal function can only have one definition\nTypes, templates, inline functions, and inline variables are allowed to have identical definitions in different files"
  },
  {
    "objectID": "C2_function_file.html#programs-with-multiple-code-files",
    "href": "C2_function_file.html#programs-with-multiple-code-files",
    "title": "3  Funtions and Files",
    "section": "3.7 Programs with multiple code files",
    "text": "3.7 Programs with multiple code files\nWe can create a another code file in the Solution Explorer. The code file contains the function called in main code file. Remember to declare the function in main source code so that the compiler checks and passes successfully.\nAfter compiling, the program will link on the compiled files in the solution to execute.\nIn the project, we created a code file named Add.cpp to define the function add.\n\n\nCode\n# In the add.cpp\nint add(int x, int y)\n{\n    return x + y;\n}\n\n\nTogether with the code file:\n\n\nCode\n# In the main source code\n#include <iostream>\n\nint add(int x, int y);\n\nint main()\n{\n    std::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\nBecause the compiler compiles each code file individually, each code files that uses std::cout, std::cin needs to #include<iostream>. Similarly, we includes other libraries if we use the functions in them.\nWhenever you create a new code (.cpp) file, you will need to add it to your project so that it gets compiled."
  },
  {
    "objectID": "C2_function_file.html#naming-collisions-and-an-introfuction-to-namespaces",
    "href": "C2_function_file.html#naming-collisions-and-an-introfuction-to-namespaces",
    "title": "3  Funtions and Files",
    "section": "3.8 Naming collisions and an introfuction to namespaces",
    "text": "3.8 Naming collisions and an introfuction to namespaces\nC++ requires that all identifiers be non-ambiguous, otherwise the program produces an error as name collision. If the names conflict in the same file, there is a compile error; if it is in the separate files in the same program, there is a linker error.\nC++ provides plenty of mechanisms for avoiding naming collisions.\n\nLocal scopes: keep local variables defined inside functions from conflicting with each other\nBut local scopes does not work for function names.\n\n\n3.8.1 Namespace\nNamespace is a region that allows us to declare names inside of it for the purpose of disambiguation; it provides a scope region called namespace scope.\n\n\n\n\n\n\n\nA name declared in a namespace will not be mistaken for an identical name declared in another scope.\nWithin a namespace, all names are unique.\nNamespace often groups related identifiers in a large project to avoid collide with other identifiers.\n\n\n\n\n\n3.8.1.1 The global namespace\nAny name that is not defined inside a class, function, or a namespace is considered to be part of an implicitly defined namespace, global namespace.\nOnly declaration and definition statements can appear in the global namespace. We can define variable in the global namespace, but this should generally be avoided.. Let read carefully the example code below:\n\n\nCode\n#include <iostream> // handled by preprocessor\n\n# All of the following statements are part of the global namespace\nvoid foo();    # okay: function forward declaration in the global namespace\nint x;         # compiles but strongly discouraged: uninitialized variable definition in the global namespace\nint y { 5 };   # compiles but discouraged: variable definition with initializer in the global namespace\nx = 5;         # compile error: executable statements are not allowed in the global namespace\n\nint main()     # okay: function definition in the global namespace\n{\n    return 0;\n}\n\nvoid goo();    # okay: another function forward declaration in the global namespace\n\n\n\n\n3.8.1.2 The std namespace\nWe usually typed std::cout: we tell the compiler to search for the function cout inside the namespace std. This approach avoid any collide with any functions in other library or namespace.\n\n\n\n\n\n\nWhen you use an identifier that is defined a namespace (such as the std namespace), you have to tell the compiler that the identifier lives inside the namespace.\n\n\n\n\n\n\n\n\n\nAvoid using-directives (such as using namespace std;) at the top of your program or in header files. They vioalate the reason why namespace were added in the firest place."
  },
  {
    "objectID": "C2_function_file.html#introduction-to-the-preprocessor",
    "href": "C2_function_file.html#introduction-to-the-preprocessor",
    "title": "3  Funtions and Files",
    "section": "3.9 Introduction to the preprocessor",
    "text": "3.9 Introduction to the preprocessor\nEach code file goes through a preprocessing phase; a program called preprocessor make various changes to the text of the code file.\nThis phase works with the #include, #define. When we use #include, the preprocessor copies all the files to the compiler."
  },
  {
    "objectID": "C2_function_file.html#header-files",
    "href": "C2_function_file.html#header-files",
    "title": "3  Funtions and Files",
    "section": "3.10 Header files",
    "text": "3.10 Header files\nWhat do we do if we want to store all the declaration in one files? That the important role of header file (extension .h).\nHeader file contains the function and variable declarations, not definitions. We can create our own header file (paired with the function code) and #include nameOfFile.h in the main and in the functions that declared in the header file.\n\n\n\n\n\n\nBest practice\n\n\n\n\nUse a .h suffix when naming your header files.\nIf a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).\nSource files should #include their paired header file (if one exists).\nUse double quotes to include header files that you’ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you’ve installed elsewhere on your system.\nWhen including a header file from the standard library, use the version without the .h extension if it exists. User-defined headers should still use a .h extension.\nEach file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.\nEach header file should have a specific job, and be as independent as possible. For example, you might put all your declarations related to functionality A in A.h and all your declarations related to functionality B in B.h. That way if you only care about A later, you can just include A.h and not get any of the stuff related to B.\nBe mindful of which headers you need to explicitly include for the functionality that you are using in your code files\nEvery header you write should compile on its own (it should #include every dependency it needs)\nOnly #include what you need (don’t include everything just because you can).\nDo not #include .cpp files.\n\n\n\nThe author discuss the use of Header Guard helps to avoid the problem of collission between files in the program when creating headers."
  },
  {
    "objectID": "C2_function_file.html#how-to-design-your-first-programs",
    "href": "C2_function_file.html#how-to-design-your-first-programs",
    "title": "3  Funtions and Files",
    "section": "3.11 How to design your first programs",
    "text": "3.11 How to design your first programs\nThe most important to remember is to design the program before you start coding. It is like architecture. A little up-front planning saves both time and frustation in th long run.\n\n3.11.1 Design step 1: Define your goal\nShould address the goal in one or two sentences, often useful to express this as a user-facting outcome. Example:\n\nAllow the user to organize a list of names and associated phone numbers\nModel how long it takes for a ball dropped off a tower to hit the ground\n\n\n\n3.11.2 Design step 2: Define requirements\nThis focuses on the “what”, not the “how”. For example:\n\nPhone numbers should be saved, so they can be recalled later\nThe program should produce results within 10 seconds of the user submitting their request\n\nA single problem may yield many requirements, and the solution is not “done” until it satisfies all of them.\n\n\n3.11.3 Design step 3: Define your tools, targets, and backup plan\nAs a new programmer, the answers are simple:\n\nWriting a program for own use\nOn own system\nUsing IDE purchased or downloaded\n\n\n\n3.11.4 Design step 4: Break hard problems down into easy problems\nTry split the complex task to sub-task and continuing define smaller sub-task until they are manageable.\n\n\n3.11.5 Design step 5: Figure out the sequence of events\nThen, we determine how to link all tasks together. For example, if we are writing a calculator, we might do things in this order:\n\nGet first number from user\nRecognize the operator from user\nGet second number from user\nCalculate result\nPrint result back to user\n\nThen, we can implement them\n\n\n3.11.6 Implementation step 1: Outlining the main function\nDo not worry about input and outphut for the time being\n\n\nCode\nint main() {\n  // Get first number from user\n      // getUserNumer();\n  \n  // Recognize the operator from user\n      // getMathOperation()\n  \n  //  Get second number from user\n      // getUserNumer();\n  \n  // Calculate result\n      // calculateResult();\n  \n  //  Print result\n      // printResult();\n  \n  return 0;\n}\n\n\n\n\n3.11.7 Implementation step 2: Implement each function\nIn this step, for each function, we do three things:\n\nDefine the function prototypes (input, output)\nWrite the function\nTest the function\n\n\n\nCode\n#include <iostream>\n\nint getUserNumber() {\n\n    std::cout << \"Enter an integer: \";\n    \n    int number{};\n    std::cin >> number;\n\n    return number;\n}\n\nint main() {\n\n    // Get first number from user\n    int value{ getUserNumber() };\n    std::cout << value << '\\n';     //debug code\n\n    // Recognize the operator from user\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDo not implement your entire program in one go. Work on it in steps, testing each step along the way before proceeding.\n\n\n\n\n\n3.11.8 Implementation step 3: Final testing\nOnce your program is “finished”, the last step is to test the whole program and ensure it works as intended. If it doesn’t work, fix it.\n\n\n\n\n\n\nWord of advice\n\n\n\n\nKeep your programs simple to start: make your first goal as simple as possible.\nAdd features over time: Once you have your simple program working and working well, then you can add features to it\nFocus on one area at a time: Focus on one task at a time\nTest each piece of code as you go.\nDo not invest in perfecting early code\n\n\n\nThe good news is that once you become comfortable with all of these concepts, they will start coming more naturally to you. Eventually you will get to the point where you can write entire functions without any pre-planning at all."
  },
  {
    "objectID": "c3_data_type.html#introduction-to-fundamental-data-types",
    "href": "c3_data_type.html#introduction-to-fundamental-data-types",
    "title": "4  Fundamental Data Types",
    "section": "4.1 Introduction to fundamental data types",
    "text": "4.1 Introduction to fundamental data types\n\n\n\n\n\n\nRecall\n\n\n\nVariable is a names of a piece of memory that we will store a certain type of information (data) into.\n\n\nAll data on a computer is just a sequence of bits, we use a data type to tell the compiler how to interpret the contents of memory in some meaningful way.\nWhen we give an object a value, the compiler and CPU covert it to bit and store in a memory; when we consult the value, the bit is recovered to the human-readable format.\n\n4.1.1 Fundamental data types\nTable belows summray the data types in C++:\n\n\n\nFigure 4.1: Data types\n\n\n\n\n4.1.2 Void\nVoid means no type. Then, a variables cannot be defined with a type of void.\nvoid uses with function does not return value.\n\n\nCode\n#include<iostream>\n\nvoid writeValue(int x)\n{\n  std::cout << \"The value is: \" << x << '\\n';\n}\n\n\nIf we return value, compiler returns error.\n\n\n4.1.3 Object sizes and the size of operator\n\n\nCode\n#| label: typeSize\n\n#include <iostream>\n\nint main()\n{\n    std::cout << \"bool:\\t\\t\" << sizeof(bool) << \" bytes\\n\";\n    std::cout << \"char:\\t\\t\" << sizeof(char) << \" bytes\\n\";\n    std::cout << \"wchar_t:\\t\" << sizeof(wchar_t) << \" bytes\\n\";\n    std::cout << \"char16_t:\\t\" << sizeof(char16_t) << \" bytes\\n\";\n    std::cout << \"char32_t:\\t\" << sizeof(char32_t) << \" bytes\\n\";\n    std::cout << \"short:\\t\\t\" << sizeof(short) << \" bytes\\n\";\n    std::cout << \"int:\\t\\t\" << sizeof(int) << \" bytes\\n\";\n    std::cout << \"long:\\t\\t\" << sizeof(long) << \" bytes\\n\";\n    std::cout << \"long long:\\t\" << sizeof(long long) << \" bytes\\n\";\n    std::cout << \"float:\\t\\t\" << sizeof(float) << \" bytes\\n\";\n    std::cout << \"double:\\t\\t\" << sizeof(double) << \" bytes\\n\";\n    std::cout << \"long double:\\t\" << sizeof(long double) << \" bytes\\n\";\n\n    return 0;\n}\n\n\n\n\n4.1.4 Signed intgeger\nSigned integer is integer with sign operator. These are the conventional definition of interger:\n\n\nCode\nshort s;            // short int\nint i;\nlong l;           // long int\nlong long ll;     // long long int \n\n\n\n\n4.1.5 Floating point numbers\nFor floating numbers, we have the appropriate value; std::cout displays from 6 to 8 digits. We can override this format by use std::setprecision(#digits) from headers iomanip.\nThe precision does not only impact the fractional number, they impact any number with too many significant digits:\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    float f{ 123456789.0f };\n    std::cout << std::setprecision(9);\n    std::cout << f << '\\n';\n\n    return 0;\n}\n\n#> 123456792\n\n\nIn the example, 1234567892 is greater than 123456789. The value of 123456789.0 has 10 significant digits, but float values typically have 7 digits of precision, then we lost precision\n\n\n\n\n\n\nBest practice\n\n\n\nFavor double over float type.\n\n\n\n\n4.1.6 Rounding errors makes floating point comparision tricky\nFloating point numbers are tricky to work due to non-obvious differences between binary and decimal. The fraction 0.1, in binary, 0.1 represented by infinite sequence 0.00011001100110011… Thus, we assign 0.1 to floating point number, we run into rounding errors.\nLet see the following code:\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    double d{ 0.1 };\n    std::cout << d << '\\n'; // use default cout precision of 6\n    std::cout << std::setprecision(17);\n    std::cout << d << '\\n';\n\n    return 0;\n}\n\n#> 0.1\n#> 0.10000000000001\n\n\nThe double type guarantee precision for 16 digits, when there are more than that, there is not precision. Another one\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    std::cout << std::setprecision(17);\n\n    double d1{ 1.0 };\n    std::cout << d1 << '\\n';\n\n    double d2{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; // should equal 1.0\n    std::cout << d2 << '\\n';\n\n    return 0;\n}\n\n#> 1\n#> 0.999999999999999999999999\n\n\n\n\n4.1.7 Boolean values\nBoolean type takes only two value: ‘true’ or ‘false’. In C++, the system represents it as an integer which 0 for ‘false’ and 1 for ‘true’. If we want to print the values rather than number, we have to use the function std::boolalpha.\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    std::cout << true << '\\n';\n    std::cout << false << '\\n';\n\n    std::cout << std::boolalpha;\n\n    std::cout << true << '\\n';\n    std::cout << false << '\\n';\n\n    return 0;\n}\n\n#> 1\n#> 0\n#> true\n#> false\n\n\nThis is similar to the get information from user:\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    std::cout << \"Enter a boolean value: \";\n    \n    bool b{};\n    std::cin >> b;\n    \n    std::cout << \"You enter: \" << b << '\\n';\n\n    return 0;\n}\n\n#> Enter a Boolean value: true\n#> You entered: 0\n\n\nWe can do:\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    std::cout << \"Enter a boolean value: \";\n    \n    bool b{};\n    std::cin >> std::boolalpha;\n    std::cin >> b;\n    \n    std::cout << \"You enter: \" << b << '\\n';\n\n    return 0;\n}\n\n\n\n4.1.7.1 Boolean return value\nWe can create a function that return boolean value:\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nbool isEqual(int x, int y) {\n    return (x == y);\n}\n\nint getInteger() {\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    return x;\n}\nint main() {\n    \n    int x{ getInteger() };\n    int y{ getInteger() };\n\n    std::cout << std::boolalpha;\n    std::cout << \"Does \" << x << \" equal \" << y << \"?\\n\";\n    std::cout << isEqual(x, y) << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "c3_data_type.html#introduction-to-if-statement",
    "href": "c3_data_type.html#introduction-to-if-statement",
    "title": "4  Fundamental Data Types",
    "section": "4.2 Introduction to if statement",
    "text": "4.2 Introduction to if statement\nConditional statement is common in programming language; they allow us to implement conditional behavior into our programs.\nThe simplest type of conditional statement in C++ is if statement, following the form:\n\nif (condition) true_statement;\n\n\n\n\n\n\n\nIf statements only conditionally execute a single statement. We talk about how to conditionally execute multiple statements in lesson 7.2 – If statements and blocks."
  },
  {
    "objectID": "c3_data_type.html#chars",
    "href": "c3_data_type.html#chars",
    "title": "4  Fundamental Data Types",
    "section": "4.3 Chars",
    "text": "4.3 Chars"
  },
  {
    "objectID": "c3_data_type.html#an-introduction-to-explicit-type-conversion-via-the-static_cast-operator",
    "href": "c3_data_type.html#an-introduction-to-explicit-type-conversion-via-the-static_cast-operator",
    "title": "4  Fundamental Data Types",
    "section": "4.4 An introduction to explicit type conversion via the static_cast operator",
    "text": "4.4 An introduction to explicit type conversion via the static_cast operator\nIf we want to explicitly change the type of data, we can use static_cast<new_type>(expression).1\n\n\nCode\n#include <iostream>\n\nvoid print(int x)\n{\n    std::cout << x;\n}\n\nint main()\n{\n    print( static_cast<int>(5.5) ); // explicitly convert double value 5.5 to an int\n\n    return 0;\n}\n\n\nWe can use this to covert chart to int:\n\n\nCode\n#include <iostream>\n\nint main() {\n    \n    char ch{ 'a' };\n    std::cout << ch << '\\n';\n\n    std::cout << ch << \" has value \" << static_cast<int>(ch) << '\\n';\n\n    return 0;\n}\n\n\nAnother exercise:\n\n\nCode\nint main() {\n    \n    std::cout << \"Please enter a single character: \";\n    char ch{};\n    std::cin >> ch;\n\n    std::cout << \"You entered '\" << ch << \"'\" << \", which has ASCII code \" << static_cast<int>(ch);\n\n    return 0;\n}"
  },
  {
    "objectID": "c3_data_type.html#const-variables-and-symbolic-constants",
    "href": "c3_data_type.html#const-variables-and-symbolic-constants",
    "title": "4  Fundamental Data Types",
    "section": "4.5 Const variables and symbolic constants",
    "text": "4.5 Const variables and symbolic constants\nConst variable: initialized variable with value and cannot assign different values later.\nLet look the code to create a const variable:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    const double gravity{ 9.8 };\n    gravity = 9.9;\n\n    return 0;\n}\n\n#> Error    C3892   'gravity': you cannot assign to a variable that is const\n\n\nAge example:\n\n\nCode\n#include <iostream>\n\nint main() \n{\n  std::cout << \"Enter your age: \";\n  \n  int age{};\n  std::cin >> age;\n  \n  const int constAge { age };\n  \n  age = 5         //okie\n  constAge = 6    // error: constAge is constant\n  \n  return 0;\n}\n\n\nWe can set the const for parameter, but do not prefer to do that."
  },
  {
    "objectID": "c3_data_type.html#compile-time-constants-constant-expressions-and-constexpr",
    "href": "c3_data_type.html#compile-time-constants-constant-expressions-and-constexpr",
    "title": "4  Fundamental Data Types",
    "section": "4.6 Compile-time constants, constant expressions, and constexpr",
    "text": "4.6 Compile-time constants, constant expressions, and constexpr\nConstant expression is an expression that can be evaluated by the compiler at compile time.\nCompile-time constant: a constant whose value is known at compile-time.\n\n\n\n\n\n\nA const variable is a compile-time constant if its initializer is a constant expression.\nEvaluating const expression takes longer at compile time, but saves time at runtime.\n\n\n\nRuntime const: every const variable initialized with a non-constant expression is a runtime constant. Runtime constants are constants whose initialization values are not known until runtime.\n\n4.6.1 The constexpr keyword\nCompile always implicitly keep track of const variables to know whether it’s a runtime or compile-time const. A variable can only be compile-time const.\nLet read the example:\n\n\nCode\n// constexpr uses\n    constexpr double gravity{ 9.8 };    // ok: 9.8 is a const expression\n    constexpr int sum{ 4 + 5 };         //ok\n    constexpr int something{ sum };     // ok: sum is const expression\n\n    std::cout << \"Enter you age: \";\n    int age{};\n    std::cin >> age;\n\n    constexpr int myAge{ age };     // compile error: age is not const expression\n    constexpr int f{ five() };      // compile error: return value of five() is not constant expression\n\n\n\n\n\n\n\n\nBest practice\n\n\n\n\nAny variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as constexpr.\nAny variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as const."
  },
  {
    "objectID": "c3_data_type.html#literals",
    "href": "c3_data_type.html#literals",
    "title": "4  Fundamental Data Types",
    "section": "4.7 Literals",
    "text": "4.7 Literals\nLiterals are unnamed values inserted directly into the code. For example:\n\n\nCode\nreturn 5;\nboot myNameIsAlex{ true };\nstd::cout << 3.4;\n\n\nLike objects, all literals have type. There type is in"
  },
  {
    "objectID": "c3_data_type.html#string",
    "href": "c3_data_type.html#string",
    "title": "4  Fundamental Data Types",
    "section": "4.8 String",
    "text": "4.8 String\nAn example of string is \"Hello world?\\n\"; a sequence of characters. String is not natural in C++ language. We use std::string to work with string by including the header <string> in the header\nHere is an example:\n\n\nCode\n#include <string>\n#include <iostream>\n\nint main()\n{\n    //std::string name{};       // empty string\n    std::string name{ \"Huy\" };      // initialized with value\n    name = \"Quang\";\n\n    std::string myID{ \"45\" };\n\n    std::cout << \"My name is \" << name << '\\n';\n\n    std::string empty{};\n    std::cout << '[' << empty << ']';\n\n    return 0;\n}\n\n\n\n4.8.1 String input with std::cin\nUsing strings with std::cin my yield some surprises. Let see the example:\n\n\nCode\n#include <string>\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter your full name: \";\n    std::string name{};\n    std::cin >> name;\n\n    std::cout << \"Enter your age: \";\n    std::string age{};\n    std::cin >> age;\n\n    std::cout << \"Your name is \" << name << \" and your age is \" << age << '\\n';\n\n    return 0;\n}\n\n#> Input: Quang Huy\n#> Your name is Quang and your age is Huy\n\n\nNormally, the >>operator only extract the string before first space, and the rest is stored for the next >>operator.\nTo get the full string input, it is better to use std::getline():\n\n\nCode\n#include <string>\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter your full name: \";\n    std::string name{};\n    std::getline(std::cin >> std::ws, name);\n\n    std::cout << \"Enter your age: \";\n    std::string age{};\n    std::getline(std::cin >> std::ws, age);\n\n    std::cout << \"Your name is \" << name << \" and your age is \" << age << '\\n';\n\n    return 0;\n}\n\n\nThe input manipulator std::ws tells std::in ignore any leading whitespace (spaces, tabs, newlines) in the string. Here is another example:\n\n\nCode\n#include <string>\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Pick 1 or 2: \";\n    int choice{};\n    std::cin >> choice;\n\n    std::cout << \"Now enter your name: \";\n    std::string name{};\n    std::getline(std::cin >> std::ws, name);        // no std::ws here\n    std::cout << \"Hello \" << name << \", you chose \" << choice << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nIf using std::getline() to read strings, use std::cin >> std::ws input manipulator to ignore leading whitespace.\n\n\n\n\n4.8.2 String length\nWe use the length() function to return the string’s length. In C++, the length function is nested in std::string, it is written as std::string::length() in documentation. Thus, length() is not normal standalone function, it is called member function.\n\n\n\n\n\n\nKey insight\n\n\n\nWith normal function, we call function(object). With member function, we call object.function().\n\n\nlength() return unsigned integral value, to assign it to integer value, we have to use static_cast<type><name.length()>. We can also use ssize(name) to get the length as a signed integer.2\n\n\n\n\n\n\nBest practice\n\n\n\nDo not pass std::string by value, as making copies of std::string is expensive. Prefer std::string_view parameters.\n\n\n\n\n4.8.3 Literals for std::string\nWe can create string literals with type std::string by using s suffix after the double-quote string literal.\nHere is the exercise from this session:\n\n\nCode\n#include <iostream>\n#include <string>\n#include <string_view>\n\nint main()\n{\n    std::cout << \"Enter your full name: \";\n    std::string name{};\n    std::getline(std::cin >> std::ws, name);\n\n    std::cout << \"Enter your age: \";\n    int age{};\n    std::cin >> age;\n\n    //std::cout << \"Your age + length of your name is: \" << age + static_cast<int>(name.length());\n\n    int letters{ static_cast<int>(name.length()) };\n    std::cout << \"Your age + length of your name is: \" << age + letters << '\\n';\n    \n  return 0;\n}"
  },
  {
    "objectID": "c3_data_type.html#introduction-to-stdstring_view",
    "href": "c3_data_type.html#introduction-to-stdstring_view",
    "title": "4  Fundamental Data Types",
    "section": "4.9 Introduction to std::string_view",
    "text": "4.9 Introduction to std::string_view\nWhen use std:string, it creates a copy of the string, this is inefficient. Thus, from C++ 17, there is std::string_view from string_view header that provide read-only access to an existing string, not a copy of a string.\nHere is an example:\n\n\nCode\n#include <iostream>\n#include <string>\n#include <string_view>\n\nvoid printSV(std::string_view str)\n{\n    std::cout << str << '\\n';\n}\nint main()\n{\n    std::string_view s{ \"Hello world!\" };\n    printSV(s);\n\n    return 0;\n}\n\n\nUnlike std::string, std::string_view support constexpr:\n\n\n\n\n\n\n\nReturning a std::string_view from a function is usually a bad idea. We will explore why in lesson 11.7 – std::string_view (part 2). For now, avoid doing so.\nThe chapter summary can be found at https://www.learncpp.com/cpp-tutorial/chapter-4-summary-and-quiz/"
  },
  {
    "objectID": "c4_debug.html#syntax-and-semantic-errors",
    "href": "c4_debug.html#syntax-and-semantic-errors",
    "title": "5  Debugging C++ Programs",
    "section": "5.1 Syntax and semantic errors",
    "text": "5.1 Syntax and semantic errors\n\nSoftware errors are prevalent. It’s easy to make them, and it’s hard to find them\n\nTwo catergories of errors:\n\nSyntax error: write a statement that is not valid according to the grammar of C++ (missing semicolons, using undeclared variables, missing braces, etc…). A compiler will catch these errors, so we identify and fix them. For example:\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout < \"Hi there\"; << x << '\\n'; // invalid operator (<), extraneous semicolon, undeclared variable (x)\n    return 0 // missing semicolon at end of statement\n}\n\n\n\nSemantic error occurs when a statement is syntactically valid, does not do what the we want.\n\nSometimes it cause the program to crash\n\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int a { 10 };\n    int b { 0 };\n    std::cout << a << \" / \" << b << \" = \" << a / b << '\\n'; // division by 0 is undefined\n    return 0;\n}\n\n\n\nOr wrong value\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x;\n    std::cout << x << '\\n'; // Use of uninitialized variable leads to undefined result\n\n    return 0;\n}\n\n\n\nOr\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    return 0; // function returns here\n\n    std::cout << \"Hello, world!\\n\"; // so this never executes\n}"
  },
  {
    "objectID": "c4_debug.html#the-debugging-process",
    "href": "c4_debug.html#the-debugging-process",
    "title": "5  Debugging C++ Programs",
    "section": "5.2 The debugging process",
    "text": "5.2 The debugging process\nGenerally, there are 5 steps:\n\nFind the root cause of the problem\nEnsure you understand why the issue is occuring\nDetermine how you’ll fix the issue\nRepair the issue causing the problem\nRetest to ensure the problem has been fixed and no new problems have emerged\n\n\n5.2.1 Debugger\nA debugger is a computer program that allows the programmer to control how another program executes and examine the program state while that program is running. For example, a programmer can use debugger to execute a program line by line, examining the value of variables along the way.\nThe advantage:\n\nThe ability to precisely control execution of program\nTo view the program state\n\n\n\n\n\n\n\nDo not neglect learning to use a debugger. As your programs get more complicated, the amount of time you spend learning to use the integrated debugger effectively will pale in comparison to amount of time you save finding and fixing issues.\n\n\n\n\n\n5.2.2 The call stack\nThe call stack is a list of all active functions that have been called to get to the current point of execution. It includes an entry for each function called, as well as which line code will be returned to when the function returns. Whenever a new functions is called, that function is added to the top of the call stack."
  },
  {
    "objectID": "c5_operators.html#introduction",
    "href": "c5_operators.html#introduction",
    "title": "6  Operators",
    "section": "6.1 Introduction",
    "text": "6.1 Introduction\nAn operation is an mathematical calculation involving zero or more input values (called operand) to produce a new value. The specific operation to be performed is denoted by a construct (symbol or pair of symbols: +, -, “*”, “/”, ….) called an operator.\nOperator precedence:\n\nIn the compound expression (including more than 1 operators), C++ use the rule of operator precedence. Each operator is assigned one level, the higher level operator will be evaluate first.\nWhen the operators have the same level, C++ uses operator associativity that indicates whether the it analyzes from left-to-right or right-to-left.\nWe can use the pasteurization for explicitly say the order of the operator\n\n\n\n\n\n\n\nBest practice\n\n\n\nUse parentheses to make it clear how a non-trivial expression should evaluate (even if they are technically unnecessary).\n\n\nFor example\n\n\nCode\nx = (y + z + w);   // instead of this\nx = y + z + w;     // it's okay to do this\n\nx = ((y || z) && w); // instead of this\nx = (y || z) && w;   // it's okay to do this\n\nx = (y *= z); // expressions with multiple assignments still benefit from parenthesis\n\n\n\n\n\n\n\n\nIn many cases, the operands in a compound expression may evaluate in any order. This includes function calls and the arguments to those function calls.\n\n\n\nWe can have the mistakes that the compiler chooses the order differs from what we want:\n\n\nCode\n#include <iostream>\n\nint getValue()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    return x;\n}\nint main()\n{\n    std::cout << getValue() + (getValue() * getValue());\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nOutside of the operator precedence and associativity rules, assume that the parts of an expression could evaluate in any order. Ensure that the expressions you write are not dependent on the order of evaluation of those parts.\n\n\nExample for best practice:\n\n\nCode\n#include <iostream>\n\nint getValue()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    return x;\n}\nint main()\n{\n    int a{ getValue() };\n    int b{ getValue() };\n    int c{ getValue() };\n\n    std::cout << a + (b * c);\n\n    return 0;\n}"
  },
  {
    "objectID": "c5_operators.html#arithmetic-operators",
    "href": "c5_operators.html#arithmetic-operators",
    "title": "6  Operators",
    "section": "6.2 Arithmetic operators",
    "text": "6.2 Arithmetic operators\nThere are two unary arithmetic operators:\n\n\n\nUnary Arithmetic\n\n\nThe binary arithmetic operators:\n\n\n\nBinary Arithmetic\n\n\nArithmetic assignment operators\n\n\n\nArithmetic Assignment operators"
  },
  {
    "objectID": "c5_operators.html#incrementdecrements-operators-and-side-effects",
    "href": "c5_operators.html#incrementdecrements-operators-and-side-effects",
    "title": "6  Operators",
    "section": "6.3 Increment/decrements operators, and side effects",
    "text": "6.3 Increment/decrements operators, and side effects\n\n\n\nIncrement/decrement operators\n\n\nLet have an example:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    int y{ 5 };\n\n    std::cout << x << ' ' << y << '\\n';\n    std::cout << ++x << ' ' << --y << '\\n'; // prefix make the calculation \n                                           //  and assign directly\n    std::cout << x << ' ' << y << '\\n';\n\n    std::cout << x++ << ' ' << y-- << '\\n'; // postfix creates a copy, calcul, \n                                            // and return the copy\n    std::cout << x << ' ' << y << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nStrongly favor the prefix version.\n\n\n\n6.3.1 Side effects can cause undefined behavior\n\nA function or expression is said to have a side effect if has some obervable effect beyond producing a return value.\n\nCommon examples are assignment value of objects, doing input, output,… Most of the time, side effects are useful:\n\n\nCode\nx = 5;\n++x;\nstd::cout << x\n\n\nHowever, side effects can also lead to unexpected results:\n\n\nCode\nint add(int x, int y)\n{\n    return x + y;\n}\n\nint main()\n{\n    int x{ 5 };\n    \n    int value{ add(x, ++x) };\n    std::cout << value << '\\n'; // value depends on how the above line evaluates\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\nC++ does not define the order of evaluation for function arguments or the operands of operators.\nDon’t use a variable that has a side effect applied to it more than once in a given statement. If you do, the result may be undefined."
  },
  {
    "objectID": "c5_operators.html#comma-and-conditional-operators",
    "href": "c5_operators.html#comma-and-conditional-operators",
    "title": "6  Operators",
    "section": "6.4 Comma and conditional operators",
    "text": "6.4 Comma and conditional operators\n\n\n\nComma operator\n\n\nThe comma operator allows us to evaluate multiple expressions wherever a single expression is allowed.\nIn almost every case, a statement written using the comma operator would be better written as a separate statements.\n\n\n\n\n\n\nBest practice\n\n\n\nAvoid using the comma operator, except within for loops\n\n\n\n6.4.1 Comma as a separator\nIn C++, comma symbol is often used as a separator, and does not invoke the comma operator:\n\n\nCode\nvoid foo(int x, int y) // Comma used to separate parameters in function definition\n{\n    add(x, y); // Comma used to separate arguments in function call\n    constexpr int z{ 3 }, w{ 5 }; // Comma used to separate multiple variables being defined on the same line (don't do this)\n}\n\n\n\n\n6.4.2 Conditional operator\n\n\n\nConditional operator\n\n\nAlways parenthesize the conditional part of the conditional operator, and consider parenthesizing the whole thing as well.\n\n6.4.2.1 The conditional operator evaluates as an expression\nBecause the conditional operator operands are expressions rather than statements, the conditional operator can be used in some places where if/else cannot.\n\n\n\n\n\n\nThe type of expressions in conditional operator must match or be convertible.\n\n\n\nThe conditional operator gives us a convenient way to compact some if/else statements. It’s most useful when we need a conditional initializer (or assignment) for a variable, or to pass a conditional value to a function."
  },
  {
    "objectID": "c5_operators.html#relational-operators-and-floating-point-comparisons",
    "href": "c5_operators.html#relational-operators-and-floating-point-comparisons",
    "title": "6  Operators",
    "section": "6.5 Relational operators and floating point comparisons",
    "text": "6.5 Relational operators and floating point comparisons\n\n\n\nRelational Operators\n\n\nComparison of calculated floating point values can be problematic.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    double d1{ 100.0 - 99.99 }; // should equal 0.01 mathematically\n    double d2{ 10.0 - 9.99 }; // should equal 0.01 mathematically\n\n    if (d1 == d2)\n        std::cout << \"d1 == d2\" << '\\n';\n    else if (d1 > d2)\n        std::cout << \"d1 > d2\" << '\\n';\n    else if (d1 < d2)\n        std::cout << \"d1 < d2\" << '\\n';\n\n    return 0;\n}\n#> d1 > d2  : error\n\n\nAvoid using operator== and operator!= to compare floating point values if there is any chance those values have been calculated."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#compound-statements",
    "href": "c6_scope_duration_linkage.html#compound-statements",
    "title": "7  Scope, duration and linkage",
    "section": "7.1 Compound statements",
    "text": "7.1 Compound statements\nCompound statement (block):\n\nZero, one, or more statement that compiler treats as simple statement\nBetween “{}”, not need semicolon at the and of “}”\nBe anywhere when the single statement is valid\n\nFunction cannot be nested inside other function, but block can. Then we have\n\nOuter block: enclosing one\nInner block: nested one\n\nBlock is very useful with if statements: replace single statement with a block. For example,\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n    int value{};\n    std::cin >> value;\n\n    if (value >= 0)\n    {\n        std::cout << value << \" is a positive integer (or zero)\\n\";\n        std::cout << \"Double this number is \" << value * 2 << '\\n';\n    }\n    else\n    {\n        std::cout << value << \" is a negative integer\\n\";\n        std::cout << \"The positive of \" << value << \" is \" << -value << '\\n';\n        std::cout << \"Then, its double is \" << (-value) * 2 << '\\n';\n    }\n\n    return 0;\n}\n\n\nNesting level or nesting depth is the maximum numbers of nested blocks inside at any point in the function. For example,\n\n\nCode\n#include <iostream>\n\nint main()\n{ // block 1, nesting level 1\n    std::cout << \"Enter an integer: \";\n    int value {};\n    std::cin >> value;\n\n    if (value >  0)\n    { // block 2, nesting level 2\n        if ((value % 2) == 0)\n        { // block 3, nesting level 3\n            std::cout << value << \" is positive and even\\n\";\n        }\n        else\n        { // block 4, also nesting level 3\n            std::cout << value << \" is positive and odd\\n\";\n        }\n    }\n\n    return 0;\n}\n\n\nThere are 4 blocks, and nesting level is 3.\n\n\n\n\n\n\nBest practice\n\n\n\nKeep the nesting level of our functions to 3 or less. If greater, think to re-factor the function into sub-ones."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#user-defined-namespaces-and-the-scope-resolution-operator",
    "href": "c6_scope_duration_linkage.html#user-defined-namespaces-and-the-scope-resolution-operator",
    "title": "7  Scope, duration and linkage",
    "section": "7.2 User-defined namespaces and the scope resolution operator",
    "text": "7.2 User-defined namespaces and the scope resolution operator\nThe better way to solve the name collisions is to put our functions in our own namespaces eg, standard library moved into std namespace.\n\n7.2.1 Define our own namespaces\nWe define namespace by using statement namespace\nin foo.cpp file:\n\n\nCode\nnamespace foo\n{\n    int doSomething(int x, int y)\n    {\n        return x - y;\n    }\n}\n\n\nin goo.cpp file:\n\n\nCode\nnamespace goo\n{\n    int doSomething(int x, int y)\n    {\n        return x - y;\n    }\n}\n\n\nin main.cpp:\n\n\nCode\n#include <iostream>\n\nint doSomething(int x, int y);\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    std::cout << doSomething(4, 3) << '\\n';\n    \n    return 0;\n}\n\n\nRunning the program, there is “LINK ERROR”: cannot find the doSomething in global namespace because it is in either foo or goo namespace.\n=> Solve this problem by: scope resolution or using statements\n\n7.2.1.1 Accessing namespace with the scope resolution operator (::)\nWe use the operator (::) to tell exactly whose namespace of the called function. For example in main.cpp\n\n\nCode\n#include <iostream>\n\nint doSomething(int x, int y);\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    std::cout << foo::doSomething(4, 3) << '\\n';\n    \n    return 0;\n}\n\n\nIf an identifier inside a namespace is used, without scope resolution, the compiler finds inside the namespace, if it cannot find, it goes to each containing namespace in sequence to find, the global namespace being checked last.\n\n\nCode\n#include <iostream>\n\nvoid print() // this print lives in the global namespace\n{\n    std::cout << \" there\\n\";\n}\n\nnamespace foo\n{\n    void print() // this print lives in the foo namespace\n    {\n        std::cout << \"Hello\";\n    }\n\n    void printHelloThere()\n    {\n        print(); // calls print() in foo namespace\n        ::print(); // calls print() in global namespace\n    }\n}\n\nint main()\n{\n    foo::printHelloThere();\n\n    return 0;\n}\n\n\nIf we define namsepace in different files to main.cpp:\n\nCreate header file for the namespace. For example, namespace foo:\n\n\n\nCode\n#ifndef FOO_H\n#define FOO_H\n\nnamespace foo\n{\n    int add(int x, int y);\n\n    int substract(int x, int y);\n\n}\n\n#endif\n\n\n\nInclude the header into the namespace file foo.cpp:\n\n\n\nCode\n#include \"foo.h\"\n\nnamespace foo\n{\n    int add(int x, int y)\n    {\n        return x + y;\n    }\n\n    int substract(int x, int y)\n    {\n        return x - y;\n    }\n}\n\n\n\nAdd header to main.cpp:\n\n\n\nCode\n#include \"foo.h\"\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    std::cout << foo::add(4, 3) << '\\n';\n    std::cout << foo::substract(10, 7) << '\\n';\n    \n    return 0;\n}\n\n\nNamespace can be nested in other namespace by declaration namespace foo::goo.\n\n\n7.2.1.2 Namespace aliases\nFor nested namespace, C++ allow to name the namespace for shortenning:\n\n\nCode\n#include <iostream>\n\nnamespace foo::goo\n{\n  int add(int x, int y)\n  {\n    return x + y;\n  }\n}\n\nint main()\n{\n  namespace active = foo::goo;  // active refers to foo::go\n  \n  std::cout << active::add(1, 2) << '\\n'; // This is really foo::goo::add()\n  \n  return 0;\n}\n\n\n\n\n\n\n\n\n\nIn general, we should avoid deeply nested namespaces.\nWe can separate application-specific code from code that might be reusable later .For example, one namespace for math: math::, language and localization: lang::\nWhen sharing the code, should put it in a namespace."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#local-variables",
    "href": "c6_scope_duration_linkage.html#local-variables",
    "title": "7  Scope, duration and linkage",
    "section": "7.3 Local variables",
    "text": "7.3 Local variables\nLocal variables have a block scope: in scope from point of definition to the end of the block they are defined within.\n\n\nCode\n#|label: block-scope\n\n#include <iostream>\n\nint main()\n{\n    int i{ 5 };         // i enters scope\n    double d{ 4.0 };   // d enters scope\n\n    return 0;\n}   // d and i go out of scope here.\n\n\nAll variable names within a scope must be unique.\nA local variable has a lifetime, called storage duration. This determine when and how a variable will be created and detroyed.\nLocal variable has automatic storage duration: created and detroyed within the block\n=> local variable == automatic variable.\nWe can define variables inside nested block:\n\nThey enters the scope at time of definition and go out at the end of the nested block. So do their lifetimes.\nThus, it cannot be found from outer block\nBut, variable in outer block can be used inside nested block.\n\n\n\nCode\n#include <iostream>\n\nint main()\n{ // outer block\n\n    int x { 5 }; // x enters scope and is created here\n\n    { // nested block\n        int y { 7 }; // y enters scope and is created here\n\n        // x and y are both in scope here\n        std::cout << x << \" + \" << y << \" = \" << x + y << '\\n';\n    } // y goes out of scope and is destroyed here\n\n    // y can not be used here because it is out of scope in this block\n\n    return 0;\n} // x goes out of scope and is destroyed here\n\n\nVariable should be defined in the most limited scope: inside the nested block that uses it.\n\n\n\n\n\n\nDefine variables in the most limited existing scope. Avoid creating new blocks whose only purpose is to limit the scope of variables."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#introduction-to-global-variables",
    "href": "c6_scope_duration_linkage.html#introduction-to-global-variables",
    "title": "7  Scope, duration and linkage",
    "section": "7.4 Introduction to global variables",
    "text": "7.4 Introduction to global variables\nWe define a variable outside of a function, this one is global variable. By convention:\n\nIt is under the #include and above any function.\nConsider using prefix ‘g’ or ‘g_’ for global variables.\n\nIts properties:\n\nHas global scope (global namespace scope)\nUses anywhere in the file\nCreated when the program starts and detroyed when it ends => static duration So, it is static variable.\nZero-initialized by default1.\nGlobal variable can be defined as constant, but we have to initialize it:\n\n\n\nCode\nconst int g_x;  //error: no default initialized\n\nconst int g_w{1}; // ok\n\n\n\n\n\n\n\n\nWe should avoid to use non-constant global variables."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#varaible-shadowing-name-hiding",
    "href": "c6_scope_duration_linkage.html#varaible-shadowing-name-hiding",
    "title": "7  Scope, duration and linkage",
    "section": "7.5 Varaible shadowing (name hiding)",
    "text": "7.5 Varaible shadowing (name hiding)\nWhen outer block and inner block have a variable with same name, the nested variable “hides” the outer variable when they are both in scope. This is called name hiding or shadowing.\nThe same applies to global variable, but global variable is a part of namespace so we can use ::prefix to indicate using global variable.\n\n\n\n\n\n\nAvoid variable shadowing"
  },
  {
    "objectID": "c6_scope_duration_linkage.html#internal-linkage",
    "href": "c6_scope_duration_linkage.html#internal-linkage",
    "title": "7  Scope, duration and linkage",
    "section": "7.6 Internal linkage",
    "text": "7.6 Internal linkage\nAn identifer’s linkage determines whether the other declarations of that name refer to the same object or not.\n\nLocal variable does not have linkage.\nGlobal variable has internal and external linkage\n\nAn internal linkage is seen and used within a single file.\nA global variable has external linkage as default, so we define internal linkage by use static ....\nBut const global variable or constexpr global variable are internal linkage by default.\n\n\nCode\nstatic int g_x{};   // internal linkage\nconst int g_y{ 2 }; // internal linkage by default\nconstexpr int g_z{ 3 }; //internal linkage by default\n\n\n\nThe one-definition rule and internal linkage\nOne-definition rule says that an object or function cannot have more than one definition, either within a file or a program. But, internal object are defined in different files are considered to be independent entities.\nWe can apply the same to function by using static:\n\n\nCode\n# This function is declared as static, and can now be used only within this file\n# Attempts to access it from another file via a function forward declaration will\n# fail\n\n[[maybe_unused]] static int add(int x, int y)\n{\n    return x + y;\n}"
  },
  {
    "objectID": "c6_scope_duration_linkage.html#external-linkage-and-variable-forward-declarations",
    "href": "c6_scope_duration_linkage.html#external-linkage-and-variable-forward-declarations",
    "title": "7  Scope, duration and linkage",
    "section": "7.7 External linkage and variable forward declarations",
    "text": "7.7 External linkage and variable forward declarations\nIdentifier with external linkage can be used and seen from its file and other code files (via a forward declaration).\n\nFunction have external linkage by default so we can use a forward declaration\nNon-const global variable are external by default\nConst global variable defined through extern keyword\nTo use global variable in other file, we also forward declaration like in function,\n\nThe following code are example of using external linkage for global variable (const and non-const one). First, we have global variable in one source file a.cpp:\n\n\nCode\nint g_x{ 3 };                   #// internal by default\nextern const int g_y { 4 };     #// okie\nextern constexpr int g_z{3};    #// can, but useless\n\n\nWe use them in the main.cpp by their declarations:\n\n\nCode\n#include <iostream>\n\nint g_x;                   #// internal by default\nextern const int g_y;     #// okie\nextern constexpr int g_z;    #// can, but useless\n\nint main()\n{\n    std::cout << g_x << '\\n'; // prints 2\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDo not use extern keyword if we define an unitialized non-const global variable. C++ will think it is a declaration.\n\n\n\nWe should be clear about file scope and global scope: all global variable can be used within the file that defines them; if it can be seen by other files too, it has global scope (with proper declarations)."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#why-non-const-global-variables-are-evil",
    "href": "c6_scope_duration_linkage.html#why-non-const-global-variables-are-evil",
    "title": "7  Scope, duration and linkage",
    "section": "7.8 Why (non-const) global variables are evil",
    "text": "7.8 Why (non-const) global variables are evil\n\nTheir values can be changed by any function that is called => Make program state is unpredictable.\nA function that utilizes nothing but its parameters and has no side effects is perfectly modular.\nModularity helps both in understanding what a program does, as well as reusability.\nGlobal variables make the program less modular.\n\n\n\n\n\n\n\nUse local variables instead of global variables whenever possible."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#sec-sharConstVar",
    "href": "c6_scope_duration_linkage.html#sec-sharConstVar",
    "title": "7  Scope, duration and linkage",
    "section": "7.9 Sharing global constants across multiple files",
    "text": "7.9 Sharing global constants across multiple files\n\nCreate a .cpp file for a constants namespace includes all the const global variables.\nCreate a header file for that namespace\nInclude the header file in other files using the constants\n\nThis solution has downside. The compiler does not evaluate the const global variables at compile-time because it only recognizes the declarations. There may impact the performance maximization. To have a better solution, C++17 introduce a new keyword inline that allow an object can be defined in different files without violating the one definition rule.\n\n\nCode\n#> In constant.cpp\n\n#include \"constant.h\"\n\nnamespace constants\n{\n    extern const double pi{ 3.14159 };\n    extern const double avogadro{ 6.0221413e23 };\n    extern const double myGravity{ 9.2 };\n}\n\n#> In constant.h\n\n#ifndef CONSTANT_H\n#define CONSTANT_H\n\nnamespace constants\n{\n    extern const double pi;\n    extern const double avogadro;\n    extern const double myGravity;\n}\n\n#endif // !CONSTANT_H\n\n#> In main.Cpp\n\n#include \"constant.h\"\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter a radius: \";\n    int radius{};\n    std::cin >> radius;\n\n    std::cout << \"The circumfence is \" << 2.0 * radius * constants::pi << '\\n';\n\n    return 0;\n}\n\n\n\n7.9.1 Global constants as inline variables\nIn C++, the term inline has evolved to mean “multiple definitions are allowed”. An inline variable is one that is allowed to be defined in multiple files without violating one definition rule.\nInline variables have two primary restrictions that must be obeyed:\n\nAll definitions of the inline variable must be identical.\nThe inline variable definitions (not a forward declaration) must be present in any file that uses the variable.\n\nWe see the differences with the sharing constant global variables mentioned at the session’s beginning:\n\nFor inline const var, we do not need to have separate .cpp file for header because we define (not only declare) all in the header file.\n\n\n\nCode\n# In constants.h\n\n#ifndef CONSTANTS_H\n#define CONSTANTS_H\nnamespace constants\n{\n  inline constexpr double pi{3.14159};\n  inline constexpr double avogadro{6.0221413e23};\n}\n\n#endif\n\n# In main cpp\n\n#include \"constants.h\"\n\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter a radius: \";\n    int radius{};\n    std::cin >> radius;\n\n    std::cout << \"The circumference is: \" << 2.0 * radius * constants::pi << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nIf you need global constants and your compiler is C++17 capable, prefer defining inline constexpr global variables in a header file."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#static-local-variables",
    "href": "c6_scope_duration_linkage.html#static-local-variables",
    "title": "7  Scope, duration and linkage",
    "section": "7.10 Static local variables",
    "text": "7.10 Static local variables\nLocal variable, by its definition, has the scope within its block or automatic duration. When we want a local variable exists in whole the program, we use static local variables by adding static before local variable’s definition.\nLet have the examples:\n\n\nCode\n#include <iostream>\n\nvoid incrementAndPrint()\n{\n    int value{ 1 };\n    ++value;\n    std::cout << value << '\\n';\n}\n\nint main()\n{\n    incrementAndPrint();\n    incrementAndPrint();\n    incrementAndPrint();\n\n    return 0;\n}\n\n#> 2\n#> 2\n#> 2\n\n\nNow, we modify for static local variable:\n\n\nCode\n#label: static-local-var\n\n#include <iostream>\n\nvoid incrementAndPrint()\n{\n    static int value{ 1 };\n    ++value;\n    std::cout << value << '\\n';\n}\n\nint main()\n{\n    incrementAndPrint();\n    incrementAndPrint();\n    incrementAndPrint();\n\n    return 0;\n}\n#> 2\n#> 3\n#> 4\n\n\nWe use static local variable to keep track of variable like IDs for object.\n\n7.10.1 Static local constants\n\n\n\n\n\n\nAvoid static local variables unless the variable never needs to be reset"
  },
  {
    "objectID": "c6_scope_duration_linkage.html#using-declarations-and-using-directives",
    "href": "c6_scope_duration_linkage.html#using-declarations-and-using-directives",
    "title": "7  Scope, duration and linkage",
    "section": "7.11 Using declarations and using directives",
    "text": "7.11 Using declarations and using directives"
  },
  {
    "objectID": "c6_scope_duration_linkage.html#inline-function",
    "href": "c6_scope_duration_linkage.html#inline-function",
    "title": "7  Scope, duration and linkage",
    "section": "7.12 Inline function",
    "text": "7.12 Inline function\nCodes of called function are expanded in caller. Modern compiler decides this."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#constexpr-and-consteval-functions",
    "href": "c6_scope_duration_linkage.html#constexpr-and-consteval-functions",
    "title": "7  Scope, duration and linkage",
    "section": "7.13 Constexpr and consteval functions",
    "text": "7.13 Constexpr and consteval functions\nA constexpr function: can be evaluated at compile-time. Simply by supplying constexpr keyword in front of the return type.\n\n\nCode\n#include <iostream>\n\nconstexpr int greater(int x, int y)\n{\n    return (x > y ? x : y);\n}\n\nint main()\n{\n    constexpr int x{ 5 };\n    constexpr int y{ 6 };\n\n    constexpr int g{ greater(x, y) };\n\n    std::cout << g << \" is greater!\\n\";\n\n    return 0;\n}\n\n\nTo be a constexpr function, a function has to:\n\nHave a constexpr return type\nDo not have any non-constexpr functions\n\nConstexpr function can be evaluated at runtime."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#chapter-summary",
    "href": "c6_scope_duration_linkage.html#chapter-summary",
    "title": "7  Scope, duration and linkage",
    "section": "7.14 Chapter summary",
    "text": "7.14 Chapter summary\nA compound statement or block is a group of statements is treated as a single statement by compiler."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "9  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\nMarkdown allows you to write using an easy-to-read, easy-to-write plain text format.\n\n\nCode\n1 + 1"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  }
]