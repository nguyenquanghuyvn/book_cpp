[
  {
    "objectID": "c7_flow_error.html",
    "href": "c7_flow_error.html",
    "title": "2  Control flow introduction",
    "section": "",
    "text": "In C++, CPU run the program from the beginning of main() function to its end. This running follows a sequence called execution path. There are types of path:\n\nStraight-line program: take tge same path every time they are run\nC++ provides different control flow statements: allow us to change the normal execution path through the program.One example of the control flow is if statements.\nBranching: when control flow statement causes execution point to change to a non-sequential statement.\n\nFigure Figure 2.1 below show the categories of flow control statement:\n\n\n\nFigure 2.1: Categories of flow control statements"
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\nCode\n1 + 1\n\n\n[1] 2\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "3  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\nMarkdown allows you to write using an easy-to-read, easy-to-write plain text format.\n\n1 + 1\n\n[1] 2"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "c7_flow_error.html#if-statements-and-blocks",
    "href": "c7_flow_error.html#if-statements-and-blocks",
    "title": "2  Control flow introduction",
    "section": "2.2 If statements and blocks",
    "text": "2.2 If statements and blocks\nC++ have two kinds of conditional statement: if statement and switch statement.\nWe already worked with if statement in previous chapters, one thing to be noted here is that the author recommends to use the ‘{}’ for the statements, even if we just have single statement after if and/or else.\n\n2.2.1 Common if statement problem\n\nif_statements within other if statements:\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n\n    return 0;\n}\n\n\nThe ambiguity arises when there is an else statement:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n        \n    else std::cout << x << \" is negative\\n\"; #// else for which if?\n\n    return 0;\n}\n\n\nC++ understands else for the last unmatched if statement. We should use the block for being clear:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n    {\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n        else std::cout << x << \" is greater than 20\\n\"; #// else for which if?\n    }\n    else\n        std::cout << x << \" is negative\\n\";\n\n    return 0;\n}\n\n\nNested if statement can be flattened by either restructuring the logic or by using local operators:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    if (x < 0)\n        std::cout << x << \" is negative\\n\";\n    else if (x <= 20)\n        std::cout << x << \" is between 0 and 20\\n\";\n    else\n        std::cout << x << \" is greater than 20\";\n\n    return 0;\n}"
  },
  {
    "objectID": "c7_flow_error.html#switch-statement-basics",
    "href": "c7_flow_error.html#switch-statement-basics",
    "title": "2  Control flow introduction",
    "section": "2.3 Switch statement basics",
    "text": "2.3 Switch statement basics\nThe idea behind a switch statement is that: an expression (condition) is evaluated to produce a value. If the expression’s value is equal to the value after any of case labels, the statements after the matching case label are executed. If there does not have any match, default label are executed instead.\n\n\n\n\n\n\nNote\n\n\n\n\nOne restriction: condition has to be in integral type.\nThe case follows by a constant expression.\nIf matching, first statements after case label start and then continues sequentially.\n\n\n\nHere is an example:\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        return;\n    case 2:\n        std::cout << \"Two\";\n        return;\n    case 3:\n        std::cout << \"Three\";\n        return;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n}\n\nint main()\n{\n    printDigitName(2);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nUsing the return in switch, the program ends when there is a match or at default. We can use break to tell the program stop at the point matching or default and jump to the next statement next to switch.\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        break;\n    case 2:\n        std::cout << \"Two\";\n        break;\n    case 3:\n        std::cout << \"Three\";\n        break;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n\n    std::cout << \"\\nOut of switch!\\n\";\n}\n\nint main()\n{\n    printDigitName(3);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nWhat does the execution of switch when we miss return or break statement? It will continue to the next case and have unexpected result.\nIf we intentionally omit the end statement after the case, we can use the attribute [[fallthrough]]:\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        break;\n    case 2:\n        std::cout << \"Two\";\n        [[fallthrough]];\n    case 3:\n        std::cout << \"Three\";\n        break;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n\n    std::cout << \"\\nOut of switch!\\n\";\n}\n\nint main()\n{\n    printDigitName(2);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nSequential case labels: we can use switch statements by placing multiple case labels in sequence:\n\n\nCode\nbool isVowel(char c)\n{\n    switch (c)\n    {\n        case 'a': // if c is 'a'\n        case 'e': // or if c is 'e'\n        case 'i': // or if c is 'i'\n        case 'o': // or if c is 'o'\n        case 'u': // or if c is 'u'\n        case 'A': // or if c is 'A'\n        case 'E': // or if c is 'E'\n        case 'I': // or if c is 'I'\n        case 'O': // or if c is 'O'\n        case 'U': // or if c is 'U'\n            return true;\n        default:\n            return false;\n    }\n}\n\n\nIf defining variables used in a case statement, do so in a block inside the case."
  },
  {
    "objectID": "c7_flow_error.html#conditional-flow-control-statement",
    "href": "c7_flow_error.html#conditional-flow-control-statement",
    "title": "2  Control flow introduction",
    "section": "2.1 Conditional flow control statement",
    "text": "2.1 Conditional flow control statement\n\n2.1.1 If statements and blocks\nC++ have two kinds of conditional statement: if statement and switch statement.\nWe already worked with if statement in previous chapters, one thing to be noted here is that the author recommends to use the ‘{}’ for the statements, even if we just have single statement after if and/or else.\n\n\n2.1.2 Common if statement problem\n\nif_statements within other if statements:\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n\n    return 0;\n}\n\n\nThe ambiguity arises when there is an else statement:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n        \n    else std::cout << x << \" is negative\\n\"; #// else for which if?\n\n    return 0;\n}\n\n\nC++ understands else for the last unmatched if statement. We should use the block for being clear:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n    {\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n        else std::cout << x << \" is greater than 20\\n\"; #// else for which if?\n    }\n    else\n        std::cout << x << \" is negative\\n\";\n\n    return 0;\n}\n\n\nNested if statement can be flattened by either restructuring the logic or by using local operators:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    if (x < 0)\n        std::cout << x << \" is negative\\n\";\n    else if (x <= 20)\n        std::cout << x << \" is between 0 and 20\\n\";\n    else\n        std::cout << x << \" is greater than 20\";\n\n    return 0;\n}\n\n\n\n\n2.1.3 Switch statement basics\nThe idea behind a switch statement is that: an expression (condition) is evaluated to produce a value. If the expression’s value is equal to the value after any of case labels, the statements after the matching case label are executed. If there does not have any match, default label are executed instead.\n\n\n\n\n\n\nNote\n\n\n\n\nOne restriction: condition has to be in integral type.\nThe case follows by a constant expression.\nIf matching, first statements after case label start and then continues sequentially.\n\n\n\nHere is an example:\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        return;\n    case 2:\n        std::cout << \"Two\";\n        return;\n    case 3:\n        std::cout << \"Three\";\n        return;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n}\n\nint main()\n{\n    printDigitName(2);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nUsing the return in switch, the program ends when there is a match or at default. We can use break to tell the program stop at the point matching or default and jump to the next statement next to switch.\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        break;\n    case 2:\n        std::cout << \"Two\";\n        break;\n    case 3:\n        std::cout << \"Three\";\n        break;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n\n    std::cout << \"\\nOut of switch!\\n\";\n}\n\nint main()\n{\n    printDigitName(3);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nWhat does the execution of switch when we miss return or break statement? It will continue to the next case and have unexpected result.\nIf we intentionally omit the end statement after the case, we can use the attribute [[fallthrough]]:\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        break;\n    case 2:\n        std::cout << \"Two\";\n        [[fallthrough]];\n    case 3:\n        std::cout << \"Three\";\n        break;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n\n    std::cout << \"\\nOut of switch!\\n\";\n}\n\nint main()\n{\n    printDigitName(2);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nSequential case labels: we can use switch statements by placing multiple case labels in sequence:\n\n\nCode\nbool isVowel(char c)\n{\n    switch (c)\n    {\n        case 'a': // if c is 'a'\n        case 'e': // or if c is 'e'\n        case 'i': // or if c is 'i'\n        case 'o': // or if c is 'o'\n        case 'u': // or if c is 'u'\n        case 'A': // or if c is 'A'\n        case 'E': // or if c is 'E'\n        case 'I': // or if c is 'I'\n        case 'O': // or if c is 'O'\n        case 'U': // or if c is 'U'\n            return true;\n        default:\n            return false;\n    }\n}\n\n\nIf defining variables used in a case statement, do so in a block inside the case."
  },
  {
    "objectID": "c7_flow_error.html#goto-statements",
    "href": "c7_flow_error.html#goto-statements",
    "title": "2  Control flow introduction",
    "section": "2.2 Goto statements",
    "text": "2.2 Goto statements\nThis is a type of unconditional jump. In C++, we use goto statement and the spot to jump by using statement label.\nHere is an example:\n\n\nCode\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    double x{};\n    int tryTime{ 0 };\n    \ntryHere:\n    std::cout << \"Enter a non-negative number: \";\n    std::cin >> x;\n    \n    if (x < 0.0 && tryTime < 5)\n    {\n        ++tryTime;\n        std::cout << \"You entered a negative number.\\n\";\n        goto tryHere;\n    }\n        \n    if (tryTime < 5)\n        std::cout << \"The square root of \" << x << \" is \" << std::sqrt(x) << '\\n';\n    else\n        std::cout << \"You cannot enter more than 5 times. Closing program.\\n\";\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nTip\n\n\n\nAvoid using goto statement"
  },
  {
    "objectID": "c7_flow_error.html#introduction-to-loops-and-while-statements",
    "href": "c7_flow_error.html#introduction-to-loops-and-while-statements",
    "title": "2  Control flow introduction",
    "section": "2.3 Introduction to loops and while statements",
    "text": "2.3 Introduction to loops and while statements"
  }
]