[
  {
    "objectID": "c7_flow_error.html#conditional-flow-control-statement",
    "href": "c7_flow_error.html#conditional-flow-control-statement",
    "title": "8  Control flow and Error Handling",
    "section": "8.1 Conditional flow control statement",
    "text": "8.1 Conditional flow control statement\n\nIf statements and blocks\nC++ have two kinds of conditional statement: if statement and switch statement.\nWe already worked with if statement in previous chapters, one thing to be noted here is that the author recommends to use the ‘{}’ for the statements, even if we just have single statement after if and/or else.\n\n\nCommon if statement problem\n\nif_statements within other if statements:\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n\n    return 0;\n}\n\n\nThe ambiguity arises when there is an else statement:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n        \n    else std::cout << x << \" is negative\\n\"; #// else for which if?\n\n    return 0;\n}\n\n\nC++ understands else for the last unmatched if statement. We should use the block for being clear:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n    {\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n        else std::cout << x << \" is greater than 20\\n\"; #// else for which if?\n    }\n    else\n        std::cout << x << \" is negative\\n\";\n\n    return 0;\n}\n\n\nNested if statement can be flattened by either restructuring the logic or by using local operators:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    if (x < 0)\n        std::cout << x << \" is negative\\n\";\n    else if (x <= 20)\n        std::cout << x << \" is between 0 and 20\\n\";\n    else\n        std::cout << x << \" is greater than 20\";\n\n    return 0;\n}\n\n\n\n\nSwitch statement basics\nThe idea behind a switch statement is that: an expression (condition) is evaluated to produce a value. If the expression’s value is equal to the value after any of case labels, the statements after the matching case label are executed. If there does not have any match, default label are executed instead.\n\n\n\n\n\n\n\nOne restriction: condition has to be in integral type.\nThe case follows by a constant expression.\nIf matching, first statements after case label start and then continues sequentially.\n\n\n\n\nHere is an example:\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        return;\n    case 2:\n        std::cout << \"Two\";\n        return;\n    case 3:\n        std::cout << \"Three\";\n        return;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n}\n\nint main()\n{\n    printDigitName(2);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nUsing the return in switch, the program ends when there is a match or at default. We can use break to tell the program stop at the point matching or default and jump to the next statement next to switch.\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        break;\n    case 2:\n        std::cout << \"Two\";\n        break;\n    case 3:\n        std::cout << \"Three\";\n        break;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n\n    std::cout << \"\\nOut of switch!\\n\";\n}\n\nint main()\n{\n    printDigitName(3);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nWhat does the execution of switch when we miss return or break statement? It will continue to the next case and have unexpected result.\nIf we intentionally omit the end statement after the case, we can use the attribute [[fallthrough]]:\n\n\nCode\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n    switch (x)\n    {\n    case 1:\n        std::cout << \"One\";\n        break;\n    case 2:\n        std::cout << \"Two\";\n        [[fallthrough]];\n    case 3:\n        std::cout << \"Three\";\n        break;\n    default:\n        std::cout << \"Unknown\";\n        break;\n    }\n\n    std::cout << \"\\nOut of switch!\\n\";\n}\n\nint main()\n{\n    printDigitName(2);\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nSequential case labels: we can use switch statements by placing multiple case labels in sequence:\n\n\nCode\nbool isVowel(char c)\n{\n    switch (c)\n    {\n        case 'a': // if c is 'a'\n        case 'e': // or if c is 'e'\n        case 'i': // or if c is 'i'\n        case 'o': // or if c is 'o'\n        case 'u': // or if c is 'u'\n        case 'A': // or if c is 'A'\n        case 'E': // or if c is 'E'\n        case 'I': // or if c is 'I'\n        case 'O': // or if c is 'O'\n        case 'U': // or if c is 'U'\n            return true;\n        default:\n            return false;\n    }\n}\n\n\nIf defining variables used in a case statement, do so in a block inside the case."
  },
  {
    "objectID": "c7_flow_error.html#goto-statements",
    "href": "c7_flow_error.html#goto-statements",
    "title": "8  Control flow and Error Handling",
    "section": "8.2 Goto statements",
    "text": "8.2 Goto statements\nThis is a type of unconditional jump. In C++, we use goto statement and the spot to jump by using statement label.\nHere is an example:\n\n\nCode\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n    double x{};\n    int tryTime{ 0 };\n    \ntryHere:\n    std::cout << \"Enter a non-negative number: \";\n    std::cin >> x;\n    \n    if (x < 0.0 && tryTime < 5)\n    {\n        ++tryTime;\n        std::cout << \"You entered a negative number.\\n\";\n        goto tryHere;\n    }\n        \n    if (tryTime < 5)\n        std::cout << \"The square root of \" << x << \" is \" << std::sqrt(x) << '\\n';\n    else\n        std::cout << \"You cannot enter more than 5 times. Closing program.\\n\";\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nAvoid using goto statement"
  },
  {
    "objectID": "c7_flow_error.html#introduction-to-loops-and-while-statements",
    "href": "c7_flow_error.html#introduction-to-loops-and-while-statements",
    "title": "8  Control flow and Error Handling",
    "section": "8.3 Introduction to loops and while statements",
    "text": "8.3 Introduction to loops and while statements\nLoops are control flow statements that allow a group of code execute repeatedly until meeting defined condition.\nHere is an program that print integer number to 10:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int count{1};\n    while (count <= 100)\n    {\n        std::cout << count << ' ';\n        ++count;\n    }\n\n    std::cout << \"done!\\n\";\n\n    return 0;\n}\n\n\nIf the condition in while is always true, the program run infinitely or we have infinite loop.\nIntentional infinite loop: we can add the break, return, or goto statement to end the infinite loop.\nLoop variable:: to count how many times a loop has executed. This is also called counter\nIteration: each time loop executes. We write a program to count from 1 to 50, each line have 10 numbers:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int count{1};\n    while(count <= 50)\n    {\n        if (count < 10)\n        {\n            std::cout << '0';\n        }\n        \n        std::cout << count << ' ';\n        \n        if (count % 10 == 0)\n        {\n            std::cout << '\\n';\n        }\n        \n        ++count;\n    }\n    \n    return 0;\n}\n\n\n\nNested loop\nA loop can be inside other loop. The inner loop can use outer loop’s counter. Here is an example:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int outer{ 1 };\n    while (outer <= 10)\n    {\n        int inner{ 1 };\n        while (inner <= outer)\n        {\n            std::cout << inner << ' ';\n            ++inner;\n        }\n        std::cout << '\\n';\n        ++outer;\n    }\n\n    return 0;\n}\n\n\nIn the exercise, we write a small program to print the characters from ‘a’ to ‘z’ and its ASCII code. From this, we need to recall the function static_cast<type>(variable) to transform characters to its integer:\n\n\nCode\n#include<iostream>\n\nint main()\n{\n    char myChar{ 'a' };\n    while (myChar <= 'z')\n    {\n        std::cout << myChar << ' ' << static_cast<int>(myChar) << '\\n';\n        ++myChar;\n    }\n\n    return 0;\n}\n\n\nThe next exercise ask us to print an inverse triangle:\n\n\nCode\n#|label: while-inverse-triangle\n\n#include <iostream>\n\nint main()\n{\n    int outer{ 5 };\n    while (outer >= 1)\n    {\n        int inner{ outer };\n        while ((inner >= 1))\n        {\n            std::cout << inner-- << ' ';\n            #//--inner;\n        }\n\n        std::cout << '\\n';\n        --outer;\n    }\n\n    return 0;\n}\n\n\nThe most exercise is to create a right-handside triangle:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int outer{ 1 };\n    while (outer <= 5)\n    {\n        int inner{ 5 };\n        \n        while (inner >= 1)\n        {\n            if (inner <= outer)\n                std::cout << inner << ' ';\n            else\n                std::cout << \"  \";\n            --inner;\n        }\n        \n        std::cout << '\\n';\n        outer++;\n    }\n    \n    return 0;\n}"
  },
  {
    "objectID": "c7_flow_error.html#do-while-statement",
    "href": "c7_flow_error.html#do-while-statement",
    "title": "8  Control flow and Error Handling",
    "section": "8.4 Do while statement",
    "text": "8.4 Do while statement\nThis is just like while loop but the statement always executes at least once. After the statement has been executed, the do-while loop checks the condition.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    // selection must be declared outside of the do-while so we can use it later\n    int selection{};\n\n    do\n    {\n        std::cout << \"Please make a selection: \\n\";\n        std::cout << \"1) Addition\\n\";\n        std::cout << \"2) Subtraction\\n\";\n        std::cout << \"3) Multiplication\\n\";\n        std::cout << \"4) Division\\n\";\n        std::cin >> selection;\n    }\n    while (selection != 1 && selection != 2 &&\n        selection != 3 && selection != 4);\n\n    // do something with selection here\n    // such as a switch statement\n\n    std::cout << \"You selected option #\" << selection << '\\n';\n\n    return 0;\n}\n\n\nThe author recommend favor while loops over do-while when given equal choice."
  },
  {
    "objectID": "c7_flow_error.html#for-statements",
    "href": "c7_flow_error.html#for-statements",
    "title": "8  Control flow and Error Handling",
    "section": "8.5 For statements",
    "text": "8.5 For statements\nIn this session, we learn about the classic for statements with the form: for (init-statement; condition; end-expression) statements.\nWe can easily link to the while statement:\n\n\nCode\ninit_statement;\nwhile(condition)\n{\n    statement;\n    end_expression;\n}\n\n\nWe can write a very simple for loop:\n\n\nCode\nint main()\n{\n    for (int count{ 1 }; count <= 10; ++count)\n        std::cout << count << ' ';\n    \n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nWe can easily change to while statement:\n\n\nCode\nint main()\n{\n    {\n        int count{1};\n        while (count <= 10)\n        {\n            std::cout << count << ' ';\n            ++count\n        }\n    }\n    \n    std::cout << '\\n';\n}\n\n\nWe can define multiple counters:\n\n\nCode\n#include \"io.h\"\n#include <iostream>\n\nint main()\n{\n\n    for (int x{ 0 }, y{ 9 }; x < 10; ++x, --y)\n        std::cout << x << ' ' << y << '\\n';\n    \n    return 0;\n}\n\n\nLoop can nest in other loop:\n\n\nCode\nvoid charNumber()\n{\n    for (char c{ 'a' }; c <= 'h'; ++c)\n    {\n        std::cout << c;\n        \n        for (int i{ 0 }; i < 4; i++)\n        {\n            std::cout << i;\n        }\n\n        std::cout << '\\n';\n    }\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\n\nFor statements are the mostly important used loop in C++.\nPrefer for loop over while loop when there is an obvious loop variable.\nPrefer while loop over for loops when there is no obvious loop variable."
  },
  {
    "objectID": "c7_flow_error.html#break-and-continue",
    "href": "c7_flow_error.html#break-and-continue",
    "title": "8  Control flow and Error Handling",
    "section": "8.6 Break and continue",
    "text": "8.6 Break and continue\nbreak statement terminates the switch or loop, and execution continue at the first statement beyond the switch or loop.\nreturn statement terminate the entire function that the loop is within, and execution continues at point where the function was called.\n\nContinue\nContinue statement tells the program end current iteration, and continue next iteration.\nThe author advise to use the break, continue statement or early return when they simplify the loop logic."
  },
  {
    "objectID": "c7_flow_error.html#sec-halts",
    "href": "c7_flow_error.html#sec-halts",
    "title": "8  Control flow and Error Handling",
    "section": "8.7 Halts",
    "text": "8.7 Halts\nThe last category of flow control statement is halt: terminates the program.\n\nThe std::exit() function\nIt terminates the program normally. The term normal termination means that the program exits in an expected way; it does not imply about whether the program was successful or not.\nstd::exit() cleans up some static storage objects, returned back to OS.\nThe program does not execute any statements after std::exit().\nstd::exit() does not clean up local variables in the current function or up in the call stack.\nFunction std::atexit() take the arguments as functions to remember to do the clean up when we call std::exit().\n\n\nstd::abort()\nThis function ends the program abnormally. It means that the program has some kind of unusual runtime error and could not continue to run.\n\n\nCode\n#include <cstdlib> // for std::abort()\n#include <iostream>\n\nint main()\n{\n    std::cout << 1 << '\\n';\n    std::abort();\n\n    // The following statements never execute\n    std::cout << 2 << '\\n';\n\n    return 0;\n}\n\n\nIt does not clean up anything.\n\n\n\n\n\n\nOnly use a halt if there is no safe way to return normally from the main function."
  },
  {
    "objectID": "c7_flow_error.html#introduction-to-testing-the-code",
    "href": "c7_flow_error.html#introduction-to-testing-the-code",
    "title": "8  Control flow and Error Handling",
    "section": "8.8 Introduction to testing the code",
    "text": "8.8 Introduction to testing the code\n\nTest your programs in small pieces\nWe should write small functions (or classes), and then compile and test immediately. This test is call unit testing; each unit test assures a correct-particular behavior of that unit.\nThese are some method to test your unit code:\n\nInformal testing\nYou write your function and run it with some inputs to see whether it runs as expected or not.\nWe have a function that check whether a character is lower Vowel, then we add some character to see that it works well\n\n\nCode\n#include \"io.h\"\n#include <iomanip>\n#include <iostream>\n\nint main()\n{\n    std::cout << std::boolalpha;\n    std::cout << isVowvel('0') << '\\n';\n\n    return 0;\n}\n\n\n\n\nPreserving your tests\nInstead of testing informal, we can write a program to test the unit function.\n\n\nCode\nvoid testVowel()\n{\n    std::cout << \"Choose 'a': \" << isVowvel('a') << '\\n';\n    std::cout << \"Choose 'b': \" << isVowvel('b') << '\\n';\n}"
  },
  {
    "objectID": "c7_flow_error.html#common-semantic-errors-in-c",
    "href": "c7_flow_error.html#common-semantic-errors-in-c",
    "title": "8  Control flow and Error Handling",
    "section": "8.9 Common semantic errors in C++",
    "text": "8.9 Common semantic errors in C++\nSemantic errors means that the codes do not do what we intended, and it leads to undefined behavior. There are some common semantic errors:\n\nConditional logic errors: errors occurs when the programmer incorrectly codes the logic of a conditional statement or loop condition.\nInfinite loop\nOff-by-one errors: counter are not correctly condition\nIncorrect operator precedence\nInteger division\nAccidental null statements\nNot using compound statement when one is required"
  },
  {
    "objectID": "c7_flow_error.html#detecting-and-handling-errors",
    "href": "c7_flow_error.html#detecting-and-handling-errors",
    "title": "8  Control flow and Error Handling",
    "section": "8.10 Detecting and handling errors",
    "text": "8.10 Detecting and handling errors\nMost errors occur due to faulty assumptions made by the programmer and/or lack of proper error detection/handling:\n\nAssume about return value\nAssume that user give correct input\nAssume that function is called correctly\n\nThus, we need to learn about error handling strategies (what to do when things go wrong) inside a function.\nFunctions may fail for many reasons and there is no best way to handle an error. There are 4 general strategies that can be used:\n\nHandling the error within the function\nWe correct the error in the same function which the error occurred so that the error can be contained and corrected without impacting any code outside function:\n\n\nCode\nvoid printDivision(int numerator, int demonator)\n{\n    if (demonator != 0)\n        std::cout << static_cast<double>(numerator) / demonator << '\\n';\n    else\n        std::cerr << \"Error: Could not divide by zero\\n\";\n}\n\n\n\n\n\n\n\n\nThe handling print the error message out, and then the program continue to run the next statements in the caller.\nWhen we added a halt, it stops entire program.\n\n\n\n\n\nPassing error back to the caller\nAs the above handling, the called function does not return anything to the calling function. If we want to pass the error to caller function, we should create a handling that return a value so that the caller function knows whether the called function runs correctly or not.\n\n\nFatal errors\nIn some case, the error is severe that we have to stop the program (non-recoverable), we can use the halt statement such as std::exit():\n\n\nCode\nvoid printDivision(int numerator, int demonator)\n{\n    if (demonator != 0)\n        std::cout << static_cast<double>(numerator) / demonator << '\\n';\n    else\n    {\n        std::cerr << \"Error: Could not divide by zero\\n\";\n        std::exit(1);\n    }\n}"
  },
  {
    "objectID": "c7_flow_error.html#stdcin-and-handling-invalid-input",
    "href": "c7_flow_error.html#stdcin-and-handling-invalid-input",
    "title": "8  Control flow and Error Handling",
    "section": "8.11 std::cin and handling invalid input",
    "text": "8.11 std::cin and handling invalid input\nA robust program anticipate the misuse from users and provide way to handle those program at the first place.\n\nstd::cin, buffers, and extraction\nstd::cin let user enter a value. This value is then stored temporarily inside of std::cin and waits for extracting to a variable. They call it buffer. The operator>> is an extraction to get the value in buffer into the variable. Normally, a value or a character is taken out, if there is still information in the buffer, that information is still there for the next extraction.\nFor example, if there is “5a” in buffer and we extract to variable x, then x = ‘5’ and ‘a’ is in the buffer for the next extraction.\nWe write a program to illustrate the following error cases:\n\n\nCode\n#include <iostream>\n\ndouble getDouble()\n{\n    std::cout << \"Enter a double value: \";\n    double x{};\n    std::cin >> x;\n    return x;\n}\n\nchar getOperator()\n{\n    std::cout << \"Enter one of the following: +, -, *, or /: \";\n    char op{};\n    std::cin >> op;\n    return op;\n}\n\nvoid printResult(double x, char operation, double y)\n{\n    switch (operation)\n    {\n    case '+':\n        std::cout << x << \" + \" << y << \" is \" << x + y << '\\n';\n        break;\n    case '-':\n        std::cout << x << \" - \" << y << \" is \" << x - y << '\\n';\n        break;\n    case '*':\n        std::cout << x << \" * \" << y << \" is \" << x * y << '\\n';\n        break;\n    case '/':\n        std::cout << x << \" / \" << y << \" is \" << x / y << '\\n';\n        break;\n    }\n}\n\nint main()\n{\n    double x{ getDouble() };\n    char operation{ getOperator() };\n    double y{ getDouble() };\n\n    printResult(x, operation, y);\n\n    return 0;\n}\n\n\n\n\nError case 1: Input extraction succeeds but the input is meaningless to the program\nFor example, users enter x = 5, y = 2 and operator = ‘k’. These inputs are attracted successfully to variable but we cannot operate the function.\nWe solve this case by doing input validation:\n\n\nCode\nhar getOperator()\n{\n    while (true)\n    {\n        std::cout << \"Enter one of the following: +, -, *, or /: \";\n        char op{};\n        std::cin >> op;\n\n        switch (op)\n        {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n            return op;\n        default:\n            std::cerr << \"Error: Operator is not valid. Please try again.\\n\";\n        }\n    }\n}\n\n\n\n\nError case 2: Extraction succeeds but with extraneous input\nFor example, user enters 5*7, the programs run and return 35 but does not lead user continue enter the input because *7\\n is stored in buffer for the following operator>>.\nTo solve this error, we have to tell the program ignore all the following character until the next \\n. In C++, we use the function std::cin.ignore(num_char_to_ignore, \\n) or better is std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n)\n\n\nCode\nvoid ignoreLine()\n{\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n}\n\n\nThen call the function in get input function:\n\n\nCode\ndouble getDouble()\n{\n    std::cout << \"Enter a double: \";\n    double x{};\n    std::cin >> x;\n    ignoreLine();\n    \n    return x;\n}\n\n\n\n\nError case 3: Extraction fails\nThis case happens when we enter a double value by a value with different type eg.: a. The operator>> cannot cover it to a double, so it let a in the buffer and goes into fail mode. Then, further requests for input extraction will silently fail. Thus, the output prompt still prints, but the input prompt is skipped, and we get stuck in infinite loop.\nWe solve the problem by:\n\nTest whether the std::cin is fail: !std::cin\nIf it is fail, put it back to normal state: std::cin.clear()\nFlush the buffer so we can enter the new value: ignoreLine()\n\n\n\nCode\nif (!std::cin)\n{\n    std::cin.clear();   #// put back to normal mode\n    ignoreLine();       #// and remove bad input\n}\n\n\n\n\nError case 4: Extraction succeeds but the user overflows a numeric value"
  },
  {
    "objectID": "c7_flow_error.html#assert-and-static_assert",
    "href": "c7_flow_error.html#assert-and-static_assert",
    "title": "8  Control flow and Error Handling",
    "section": "8.12 Assert and static_assert",
    "text": "8.12 Assert and static_assert\nReturn to the program:\n\n\nCode\nvoid printDivision(int numerator, int demonator)\n{\n    if (demonator != 0)\n        std::cout << static_cast<double>(numerator) / demonator << '\\n';\n    else\n    {\n        std::cerr << \"Error: Could not divide by zero\\n\";\n    }\n}\n\n\nThe program checks whether we divide a number by a zero. This is a semantic error and will cause the program to crash down.\nWe link to the session Section 8.7 for ideas on std::exit() and std//abort().\n\nIf we skip the offending statements, the error fails silently. This is bad for programming because we do not know where the error message is and how the conditions that triggered the error message.\nIf we terminate the program by std::exit(), we loses our call stack and any debugging information. std::abort() is a better option for such cases when the we can start debugging at the point where the program aborted.\n\n\nPrecondition, Invariant, Postcondition\nIt is any condition that must always be true prior to the execution of codes’ component.\nInvariant is a condition must be true while some component is executing\nPostcondition is something that must be true after the execution of some component of code.\n\n\nAssertions\nAn assertion is an expression that will be true unless there is a bug in a program. If the expression is true, the assertion statement does nothing, otherwise, an error message is displayed and the program is terminated (via std::abort()). The error message contains: failed as text, name of code file, and the line number of the assertion.\nTo use assertion, we include header assert. Let look at the following codes:\n\n\nCode\n#include <cassert>\n#include <cmath>\n#include <iostream>\n\n    double calculateTimeUntilObjectHitsGround(double initialHeight, double gravity)\n    {\n        assert(gravity > 0.0);\n\n        if (initialHeight <= 0.0)\n        {\n            return 0.0;\n        }\n\n        return std::sqrt((2.0 * initialHeight) / gravity);\n    }\n\n\n\nMake the assert statements be descriptive:\n\n\n\nCode\nassert(found && \"Car could not be found in database\")\n\n#// If `found == false`, then FALSE && TRUE is FALSE,  this trigger assert\n\n\n\nAsserts and Error handling\nAssertions: to catch the programming errors by documenting something that should never happen. If it does happen, the the programmer made an error somewhere, it identifies and fixes. It does not allow recovery from errors.\nError handling: gracefully handle case that could happen (rarely). There may or may not be recoverable, but the program’s users may encounter them.\n\n\nstatic_assert\nA static_assert checks the condition at the compile-time. It formula is static_assert(condition, diagnostic_message)."
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\nCode\n1 + 1\n\n\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "C1_Introduction.html#sec-statements",
    "href": "C1_Introduction.html#sec-statements",
    "title": "2  Introduction to C++",
    "section": "2.1 Statements",
    "text": "2.1 Statements\nStatements are the instructions that cause the program to perform some actions. Most of the statements end with semicolon."
  },
  {
    "objectID": "C1_Introduction.html#function",
    "href": "C1_Introduction.html#function",
    "title": "2  Introduction to C++",
    "section": "2.2 Function",
    "text": "2.2 Function\nIn C++, statements are typically grouped into units called functions. Function is a collection of statements that execute sequentially (in order, from top to bottom).\nFunctions are written to do a specific tasks."
  },
  {
    "objectID": "C1_Introduction.html#syntax-and-syntax-error",
    "href": "C1_Introduction.html#syntax-and-syntax-error",
    "title": "2  Introduction to C++",
    "section": "2.3 Syntax and syntax error",
    "text": "2.3 Syntax and syntax error\nSyntax is the rules how the programs must be constructed in order to be considered valid. If we violate a rule, the compiler will complain and issue a syntax error.\nProgram’s compilation will only complete once all syntax errors are resolved."
  },
  {
    "objectID": "C1_Introduction.html#comments",
    "href": "C1_Introduction.html#comments",
    "title": "2  Introduction to C++",
    "section": "2.4 Comments",
    "text": "2.4 Comments\nA comment is a programmer-readable note inserted directly into a source code of the program (compiler ignores the comments).\nSingle-line comments: // symbol begins a C++ single-line comment.\nMulti-line comments: /* and */ pair of symbols denotes a multi-line comment.\nProper use of comments\n\nDescribe what the library, program, or functions, do. These are typically placed on the top of the file or library.\nSecond, inside the lib, program, or function, comments are used to describe how the code is going to accomplish the goal.\nThird, at the statement level, comments can describe why the code is doing something. The bad statement comment describe what the code is doing.\n\nComments are good way to remind the reason a programmer made one decision instead of another.\n\n\n\n\n\n\nBest practice\n\n\n\n\n\nComment your code liberally, and write your comments as if speakings to someone who has no idea what the code does. Don’t assume that you’ll remember why you mad specific choices.\n\n\n\nYou can also comment out the code block if:\n\nYou’re working on a new piece of code that won’t compile yet.\nYou have written a new code that results the errors and you do not have time to fix it.\nTo find the source of the errors.\nYou want to replace one piece of code with another piece of code.\n\nSummary\n\nAt the library, program, or function level, use comments to describe what.\nInside them, use comments to describe how.\nAt the statement level, use comments to describe why."
  },
  {
    "objectID": "C1_Introduction.html#sec-intro_var",
    "href": "C1_Introduction.html#sec-intro_var",
    "title": "2  Introduction to C++",
    "section": "2.5 Objects and Variables",
    "text": "2.5 Objects and Variables"
  },
  {
    "objectID": "C1_Introduction.html#data",
    "href": "C1_Introduction.html#data",
    "title": "2  Introduction to C++",
    "section": "2.6 Data",
    "text": "2.6 Data\nIn Section 2.1, statements inside function perform actions that generate whatever result the program was designed to produce.\nBut, how do programs actually produce results?: bref, by manipulating data.\nIn computing, data is any information that can be moved, processed and stored by computer.\n\n\n\n\n\n\nKey insight\n\n\n\n\n\nPrograms are collections of instructions that manipulate data to produce a desired results.\n\n\n\nA program can acquire data to work in many ways: file, database, network, user providing input on keyboard, or from the programmer putting data directly into a source code.\nData on computer is typically stored in a efficient format (and thus is not human readable).\n\nObjects and variables\n\nA single piece of data stored in memory somewhere is called value.\nAn object is a region of storage that has a value and other associated properties. We use the object to store and retrieve values.\nObjects can be named or unnamed. A named object is called variable, the name of object is call identifier.\n\n\n\nVariable instantiation\nTo create a variable, we have to define it. Here is an example of defining a variable named x:\n\n\nCode\nint x;\n\n\nWhen the program run, it will instantiate the variable: object will be created and assigned a memory address. Variable must be instantiated before they can be used to store value.\n\n\nData types\nVariables are named region of storage that can store value. A data type tells the compiler what type of value the variable will be store.\n\n\nDefine multiple variables\nWe can define muliple variables in one statement by separating them by ,.\n\n\nCode\nint a, b;\n\n\nBut, variables of different types must be defined in separate statements:\n\n\nCode\nint a, double b;  # false\nint a; double b;  # correct\n\n# Correct and recommended\nint a;\ndouble b;\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nAvoid defining multiple variables of the same type in a simple statement. Instead, define each variable in a separate statement on it own line"
  },
  {
    "objectID": "C1_Introduction.html#variable-assignment-and-initialization",
    "href": "C1_Introduction.html#variable-assignment-and-initialization",
    "title": "2  Introduction to C++",
    "section": "2.7 Variable assignment and initialization",
    "text": "2.7 Variable assignment and initialization\nIn previous session Section 2.5, we know how to define a variable. In this session, we’ll explore how to actually put values into variables and use those values.\nRecall the variable’s definitions:\n\n\nCode\nint x;\nint y;\nint z;\n\n\n\nVariable assignment\nAfter variable has been defined, you can give it a value by using =, copy assignment or assignment.\n\n\nCode\n#include <iostream>\n\nint main() {\n  \n  int width;\n  width = 5;  // copy assignment of value 5 into variable width\n\n  width = 7;\n  \n  return 0;\n}\n\n\n\n\nInitialization\nWith initialization, we can define and assign value to variable as the same time. There are many ways to initiate:\n\n\nCode\nint a;\nint a = 5;  #copy initialization\nint c( 6 )  # direct initialization\n\n# List initialization methods\nint d { 7 };\nint e = { 8 };\nint f {}\n\n\n\nDefault initialization\nWe do not provide any initialization value.\n\n\nCopy initialization\nWith =: copy the value on the right-hand side of the equals into the variable being created. It does not use much in modern C++.\n\n\nDirect initialization\nSimilar to copy initialization, not popular in modern C++.\n\n\nList initialization\nThis is the modern way to initialize. Prior to this, some types of initialization require using the direct one, and other types required indirect one. The list initialization introduce to provide more consistent initialization syntax.\nList initialization disallows “narrowing conversion”: return errors if we initialize a variable using a value that the variable cannot safely hold:\n\n\nCode\nint width { 4.5};   # return error\n\n\n\n\n\n\n\n\nBest practice\n\n\n\n\nFavor list initialization whenever possible.\nInitialize your variables upon creation."
  },
  {
    "objectID": "C1_Introduction.html#introduction-to-iostream-cout-cin-and-endl",
    "href": "C1_Introduction.html#introduction-to-iostream-cout-cin-and-endl",
    "title": "2  Introduction to C++",
    "section": "2.8 Introduction to iostream: cout, cin, and endl",
    "text": "2.8 Introduction to iostream: cout, cin, and endl\n\nThe input and output (io) library\nio library is part of C++ standard library that works with inpur and output. We use the functionality in iostream to get input from keyboard and output data to console.\nWe use the library by including it:\n\n\nCode\n#include <iostream>\n\n\nOne of the most useful is std::cout: send data to the console to be printed as text\n\n\nCode\n#include <iostream>\n\nint main()\n{\n  std::cout << \"Hello World!\\n\";\n  \n  return 0;\n}\n\n\nIt can print a number too:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n  std::cout << 4;\n  \n  return 0;\n}\n\n\nIt can print value of a variable:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n  int x{ 5 };\n  std::cout << x;\n  \n  return 0;\n}\n\n\nTo print more than one thing in the same line:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    std::cout << \"x is equal to \" << x;\n\n    return 0;\n}\n\n\nUse std::endl to make the cursor in the next line.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    std::cout << \"Hi!\" << std::endl;\n    std::cout << \"My name is Huy.\" << std::endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nOutput a newline whenever a line of output is complete.\n\n\n\n\nstd::cout is buffered\nStatements request that output be sent to the console. However, output is typically not sent to the console immediately. Instead, the requested output gets in line, and is stored in a region of memory set aside to collect later, called buffer. Periodically, buffer is flushed, all data is transferred to its destination.\n\n\nstd::endl vs \\n\nstd::endl move the cursor to the next line and flushes the buffer. Sometimes, we do not need to flush the buffer and prefer the system do it periodically.\nThus, use of \\n is preferred instead:\n\n\n\n\n\n\nBest practice\n\n\n\nPrefer \\n over std::endl when ouputing text to the console.\n\n\n\n\nstd::cin\nstd::cin reads the data from keyboard using extraction operator >>.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter a number: \";\n    \n    int x{ };\n    std::cin >> x;\n\n    std::cout << \"You endtered: \" << x << '\\n';\n    return 0;\n}\n\n\nWe can input many variables in the same line:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter two numbers separated by a space: \";\n    \n    int x{ };\n    int y{ };\n    std::cin >> x >> y;\n\n    std::cout << \"You entered \" << x << \" and \" << y << \".\\n\";\n    std::cout << \"Thank you!\\n\";\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nInitialize variable first, then use std::in."
  },
  {
    "objectID": "C1_Introduction.html#uninitialized-variables-and-undefined-behavior",
    "href": "C1_Introduction.html#uninitialized-variables-and-undefined-behavior",
    "title": "2  Introduction to C++",
    "section": "2.9 Uninitialized variables and undefined behavior",
    "text": "2.9 Uninitialized variables and undefined behavior\nC++ does not initialize the variable automatically. Thus, when a variable is given a memory address to use to store data, the default value of that variable is whatever value happens to already be in that memory address.\nLet be clear that:\n\nInitialization = the object is given a known value at the point of definition.\nAssignment = The object is given a known value beyond the point of definition\nUninitialized = The object has not been given a known value yet.\n\nIn some case, we do not know what the value printed from the following code because uninitialized x is given any value.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x;\n    std::cout << x << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nUsing uninitialized is one of the most common mistakes\n\n\n\n\nUndefined behavior\nUninitialized variables are one example of undefined behavoir: we cannot know the results, or they can change, be incorrect, sometime correct, or crash."
  },
  {
    "objectID": "C1_Introduction.html#basic-formatting",
    "href": "C1_Introduction.html#basic-formatting",
    "title": "2  Introduction to C++",
    "section": "2.10 Basic formatting",
    "text": "2.10 Basic formatting\nThe recommendations for basic formatting:\n\nIt fine to use either tab or spaces for indentation.\nFunction braces can be:\n\n\n\nCode\nint main() {\n}\n\n\nor\n\n\nCode\nint main() \n{\n}\n\n\nThe author recommended the later.\n\nEach statement should start one tab from the opening space.\nLine should not be too long. Typically, 80 characters is the maximum length in a line.\nIf line is too long, split with an operator (eg. +, -). The operator should be placed at the beginning of the next line.\nUse whitespaces to make the code easier to read."
  },
  {
    "objectID": "C1_Introduction.html#literals-and-operators",
    "href": "C1_Introduction.html#literals-and-operators",
    "title": "2  Introduction to C++",
    "section": "2.11 Literals and operators",
    "text": "2.11 Literals and operators\n\nLiterals\nLiteral is a fixed value that has been inserted directly into the source code.\n\n\nOperators\nOperator is the specific operation to be performed.\n\n\nReturn values and side effects\nAn operator that has some observable effect beyond producing return value is said to have a side effect. For example, x = 5 is evaluated, side effect is to assign 5 to x; the changed value of x is observable, or std::cout << too."
  },
  {
    "objectID": "C1_Introduction.html#expression",
    "href": "C1_Introduction.html#expression",
    "title": "2  Introduction to C++",
    "section": "2.12 Expression",
    "text": "2.12 Expression\nExpression is a combination of literals, variables, operators, and function calls that calculates a single value.\nThe process of executing an expression is called evaluation. The single value is called result.\nExpressions do not end in a semicolon, and cannot be compiled by themselves (they must exist within a statement), example that\n\n\nCode\nint x{ 2 + 3 } ;\n\n\n2 + 3 is an expression and do not need a semicolon.\nExpressions also involve operators with side effects:\n\n\nCode\nx = 5;\nx = 2 + 3;\nstd::cout << x;\n\n\n\nExpression statement\nExpression cannot compile by itself. We can add = to make it compile. We call this expression statement, an expression following by a semicolon.\n\n\nUseless expression statements\nWe can make an expression without assigning or having any side effect, such that\n\n\nCode\n2 * 3"
  },
  {
    "objectID": "C1_Introduction.html#developing-first-program",
    "href": "C1_Introduction.html#developing-first-program",
    "title": "2  Introduction to C++",
    "section": "2.13 Developing first program",
    "text": "2.13 Developing first program\n\nMultiply by 2\n\n\n\n\n\n\nBest practice\n\n\n\nNew programmers often try to write an entire program all at once, and then get overwhelmed when it produces a lot of errors. A better strategy is to add one piece at a time, make sure it compiles, and test it. Then when you’re sure it’s working, move on to the next piece.\n\n\nThere are many solutions, from bad to good. Let take time to find the good one (not override input value, avoid complexity).\n\nWe should firstly try to make the program work\nThen, spend time to cleanup the code.\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n    \n    int num{ };\n    std::cin >> num;\n    \n    std::cout << \"Double \" << num << \" is: \" << num * 2 << \".\\n\";\n    std::cout << \"Triple \" << num << \" is: \" << num * 3 << \".\\n\";\n\n    return 0;\n}"
  },
  {
    "objectID": "C2_function_file.html#introduction-to-functions",
    "href": "C2_function_file.html#introduction-to-functions",
    "title": "3  Funtions and Files",
    "section": "3.1 Introduction to functions",
    "text": "3.1 Introduction to functions\nA function is a reusable sequence of statements designed to do a particular job. Function allows us to split the program into small, modular chunks which are easier to organize, test, and use. Besides the standard library of C++, we can write our own function, called user-defined function.\nWhen a program is executing the statements sequentially inside one function and encounters a function call. A function call is an expression that tells CPU to interrupt the current function and execute another function. The CPU put a bookmark at the current point of execution, and then calls the function.\nThe function initiating the function call is the caller, the other is called function.\n\nAn example of a user-defined function\nThe general syntax of function:\n\n\nCode\n#| label: func_syntax\nreturnType functionName() # This is function header\n{\n  # This is body of the function\n}\n\n\nThe first line is function header telling the compile that the function exists.\n\nIn this session, returnType of int for main() and void otherwise.\nfunctionName is name of user-defined function.\n\nLet see the example function:\n\n\nCode\n#| label: func_doPrint\n\n#include <iostream>     // for std::cout\n\n// Definition of user-defined function doPrint()\nvoid doPrint()\n{\n    std::cout << \"In doPrint() \\n\";\n}\n\nint main()\n{\n    std::cout << \"Starting main() \\n\";\n    doPrint();\n    std::cout << \"Ending main() \\n\";\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDo not forget to include parentheses () after the function’s name when making a function call.\n\n\n\n\nFunction can be called more than one time in a caller.\nAny functions can call any other functions:\n\n\n\nCode\n#| label: func_call_func\n\n#include <iostream>     // for std::cout\n\n// Definition of user-defined function doPrint()\nvoid doB()\n{\n    std::cout << \"In doB() \\n\";\n}\n\nvoid doA()\n{\n    std::cout << \"Starting doA()\\n\";\n    doB();\n    std::cout << \"Ending doA()\\n\";\n}\n\nint main()\n{\n    std::cout << \"Starting main() \\n\";\n    doA();\n    std::cout << \"Ending main() \\n\";\n\n    return 0;\n}\n\n\n\nNested functions are not supported: we cannot decide a function inside another function.\n\n\n\nCode\n#include <iostream>\n\nint main() \n{\n  void foo()  # Illegal: this function is nested inside function main()\n  {\n    std::cout << \"foo!\\n\";\n  }\n  \n  foo();\n  return 0;\n}\n\n\nThe right way to write is\n\n\nCode\nvoid foo() \n{\n    std::cout << \"foo!\\n\";\n}\n\nint main()\n{\n    foo();\n    return 0;\n}\n\n\n\n\nFunction return values (value-returning functions)\nIf we want to write a program that get number from user, then double it and return value to the console, we can start with:\n\n\nCode\n#include <iostream>     // for std::cout\n\nint main()\n{\n    // get a value from user\n    std::cout << \"Enter an integer: \";\n    int num{};\n    std::cin >> num;\n\n    // print the value doubled\n    std::cout << num << \" doubled is: \" << num * 2 << '\\n';\n\n    return 0;\n}\n\n\nWe can also write a function that get value from user and let main() calls that function to double it:\n\n\nCode\n#include <iostream>     // for std::cout\n\n#| label: cod_problem\nvoid getValueFromUser()\n{\n    std::cout << \"Enter an integer: \";\n    int input{};\n    std::cin >> input;\n}\n\nint main()\n{\n    getValueFromUser();\n\n    int num{};\n\n    std::cout << num << \" double is: \" << num * 2 << '\\n';\n\n    return 0;\n}\n\n\nWhile this program is a good solution, it always returns 0 because the value from getValueFromUser() is not stored. We need that function return a value.\nThe function return a value require two conditions:\n\nDefine the return type before the name of the function.\nA return statement in the body of the function. The function exits immediately, and a copy of return value backs to the caller. This is return by value process.\n\nLet look at an example:\n\n\nCode\n#include <iostream>\n\nint returnValueFive()\n{\n  return 5;\n}\n\nint main()\n{\n  std::cout << returnValueFive() << '\\n';\n  std::cout << returnValueFive() + 2 << '\\n';\n  \n  returnValueFive();\n  \n  return 0;\n}\n\n\n\n\n\n\n\n\nWhen a called function returns a value, the caller may decide to use that value in an expression or statement(e.g by assigning it to a variable, or sending it to std::cout).\n\n\n\n\n\nFixing our challange program\nNow, we return to the problem and use the code:\n\n\nCode\n#include <iostream>\n\nint getValueFromUser() // this function now returns an integer value\n{\n    std::cout << \"Enter an integer: \";\n    int input{};\n    std::cin >> input;\n\n    return input; // return the value the user entered back to the caller\n}\n\nint main()\n{\n    int num { getValueFromUser() }; // initialize num with the return value of getValueFromUser()\n\n    std::cout << num << \" doubled is: \" << num * 2 << '\\n';\n\n    return 0;\n}\n\n\n\n\nRevisiting main()\nWhen we run a program, the operating system calls the function main(). It executes the main() from the top to bottom sequentially. Finally, main() returns an integer value (usually 0), and the program terminates. The return value from mmain() is called status code, and indicates that the program is successful or fail.\n\n\n\n\n\n\nBest practice\n\n\n\n\nThe main function should return the value 0 if the program an normally.\nMake sure the functions with non-void return types return a value in all cases.\nFailure to return a value from a value-returning function will cause undefined behavior.\n\n\n\n\n\n\n\n\n\n\nFunction main will implicitly return 0 if no return statement is provided. Thus, it is recommended to explicitly state the return value.\nFunction can only return a single value. It can return not only literal, but also a variable or a call to function that return single value.\nThe function author can decide what the return value means (status code, single value). It is good to document the function with a comment indicating what the return values mean.\n\n\n\n\n\n\nReusing functions\nWe can illustrate a good case for function reuse:\n\n\nCode\n#include <iostream>\n\n// Create a function that return an integer value from user's keyboard\nint main()\n{\n    int x{};\n    std::cout << \"Enter an integer: \";\n    std::cin >> x;\n\n    int y{};\n    std::cout << \"Enter second integer: \";\n    std::cin >> y;\n\n    std::cout << x << \" + \" << y << \" = \" << x + y << '\\n';\n\n    return 0;\n}\n\n\nThe central tenets of good programming: Don’t Repeat Yourself (DRY). Let create a function:\n\n\nCode\n#include <iostream>\n\n// Create a function that return an integer value from user's keyboard\nint getValueFromUser()\n{\n    int input{};\n    std::cout << \"Enter an integer: \";\n    std::cin >> input;\n\n    return input;\n\n}\n\n// main function return the sum of two integers from user\nint main()\n{\n    int x{ getValueFromUser() };\n    int y{ getValueFromUser() };\n\n    std::cout << x << \" + \" << y << \" = \" << x + y << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nDon’t repeat yourself. IF you need to do something more than once time, consider how to modify the code to remove as much as redundancy as possible."
  },
  {
    "objectID": "C2_function_file.html#void-functions",
    "href": "C2_function_file.html#void-functions",
    "title": "3  Funtions and Files",
    "section": "3.2 Void functions",
    "text": "3.2 Void functions\nFunctions are not required to return a value to the caller, we use the return type of void. For example:\n\n\nCode\n#include <iostream>\n\nvoid printHi()\n{\n    std::cout << \"Hi!\\n\";\n}\n\nint main()\n{\n    printHi();\n\n    return 0;\n}\n\n\nThe function printHi() prints “Hi!”, but does not need to return anything back to the caller. A function that does not return a value is called a non-value returning function (void-function).\n\n\n\n\n\n\nBest practice\n\n\n\nDo not put a return statement at the end of a non-value returning function.\n\n\n\nVoid functions can’t be used in expression that require a value\nConsider the following program:\n\n\nCode\n#include <iostream>\n\nvoid printHi()\n{\n    std::cout << \"Hi!\\n\";\n}\n\nint main()\n{\n    printHi();\n\n    std::cout << printHi();\n\n    return 0;\n}\n\n\nAn error occurs because the printHi() does not return value so it cannot provide the value to std::cout to print out.\nReturning a value from a void function is a compile error.\n\nEarly return\n\na return statement that is not the last statement in a function is called an early return. For example:\n\n\n\n\nCode\n#include <iostream>\n\nvoid print()\n{\n    std::cout << \"A\";\n\n    return;\n\n    std::cout << \"B\";\n}\n\nint main()\n{\n    print();\n\n    return 0;\n}\n\n\nThe program returns “A” because it does not reach to second statements in `print()."
  },
  {
    "objectID": "C2_function_file.html#introduction-to-function-parameters-and-arguments",
    "href": "C2_function_file.html#introduction-to-function-parameters-and-arguments",
    "title": "3  Funtions and Files",
    "section": "3.3 Introduction to function parameters and arguments",
    "text": "3.3 Introduction to function parameters and arguments\n\nThe problem\nWe start by the codes:\n\n\nCode\n#include <iostream>\n\nvoid print()\n{\n    std::cout << \"A\";\n\n    return;\n\n    std::cout << \"B\";\n}\n\nint main()\n{\n    print();\n\n    return 0;\n}\n\n\nWe want to have a function that prints a doubled number:\n\n\nCode\n#include <iostream>\n\nint getValueFromUser()\n{\n    std::cout << \"Enter an integer: \";\n    int input{};\n    std::cin >> input;\n\n    return input;\n}\n\nvoid printDouble()\n{\n    std::cout << num << \" doubled is: \" << num * 2 << '\\n';\n}\n\nint main()\n{\n    int num{ getValueFromUser() };\n\n    std::cout << num << \" doubled is: \" << num * 2 << '\\n';\n\n    return 0;\n}\n\n\nThe compiler does not know the definition of num in the function. Then, we can\n\n\nCode\n#include <iostream>\n\nint getValueFromUser()\n{\n    std::cout << \"Enter an integer: \";\n    int input{};\n    std::cin >> input;\n\n    return input;\n}\n\nvoid printDouble()\n{\n    int num{};\n    std::cout << num << \" doubled is: \" << num * 2 << '\\n';\n}\n\nint main()\n{\n    int num{ getValueFromUser() };\n\n    printDouble();\n\n    return 0;\n}\n\n\nThe function run normally, but always returns 0 because function printDouble() does not access the input from user. Thus, we need some way to pass the value of variable to printDouble().\n\n\nFunction parameters and arguments\nA function parameter: a variable used in header of a function, identically to variables defined inside the function, one difference: they are initialized with a value provided by the caller of the function.\nAn argument is a value that is passed from the caller to the function when a function call is made:\n\n\nCode\nint main()\n{\n    doPrint();\n    printValue(10);\n    add(2, 3);\n\n    return 0;\n}\n\n\nUse the commas for separation multiple arguments, and parameters.\nPass by value: when a function is called, all of the parameters are created as variables, and the value of each of the arguments is copied into the matching parameters.\n\n\nCode\n// This function takes one parameter named x\n// The caller will supply the value of x\nvoid printValue(int x, int y)\n{\n    std::cout << x << '\\n';\n    std::cout << y << '\\n';\n}\n\nint main()\n{\n    printValue(10, 20);\n\n    return 0;\n}\n\n\nNow, we come back to our challenge program:\n\n\nCode\n#include <iostream>\n\nint getValueFromUser()\n{\n    std::cout << \"Enter an integer: \";\n    int input{};\n    std::cin >> input;\n\n    return input;\n}\n\nvoid printDouble(int input)\n{\n    std::cout << input << \" doubled is: \" << input * 2 << '\\n';\n}\n\nint main()\n{\n    int num{ getValueFromUser() };\n    printDouble(num);\n\n    // printDouble(getValueFromUser());\n\n    return 0;\n}\n\n\nThe arguments can be also the expression, the variable:\n\n\nCode\n#include <iostream>\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\nint multiply(int z, int w)\n{\n    return z * w;\n}\n\nint main()\n{\n    std::cout << add(5, 6) << '\\n';\n    std::cout << add(2 + 3, 3 * 4) << '\\n';\n\n    int a{ 5 };\n    std::cout << add(a, a) << '\\n';\n\n    std::cout << add(2, multiply(2, a)) << '\\n';\n    std::cout << multiply(add(1, 3), multiply(2, 3)) << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "C2_function_file.html#sec-localScope",
    "href": "C2_function_file.html#sec-localScope",
    "title": "3  Funtions and Files",
    "section": "3.4 Introduction to local scope",
    "text": "3.4 Introduction to local scope\n\nLocal variables\nFunction parameters as well as all variables defined inside the function body, are local variables.\nLocal variables are created at the point of definition and destroyed no earlier than the end of the set of the curly braces in which they are defined. We have definition of object’s lifetime to be the time between its creation and destruction which happen when the program is running (calling runtime), not at compile time.\n\n\nCode\nint add(int x, int y)\n{\n    int z{ x + y };\n\n    return z;\n} // z, y, and x destroyed here\n\n\nHere is an example:\n\n\nCode\n#include <iostream>\n\nvoid doSomething()\n{\n    std::cout << \"Hello!\\n\";\n}\n\nint main()\n{\n    int x{ 0 };\n    doSomething();\n\n    return 0;\n} // x's lifetime ends here\n\n\n\n\nLocal scope\nAn identifiers’ scope determines where the identifier can be accessed within the source code. When an identifiers can be accessed, it is in scope, while it we cannot access, it is out of scope. Scope is compile-time property.\nA local variables’ scope begins at the point of value definition, and stops at the end of the set of curly braces in which it is defined. Local variables defined in one function are also not in scope in other functions that are called.\nHere is an example:\n\n\nCode\n#include <iostream>\n\n// x is not in scope anywhere in this function\nvoid doSomething()\n{\n    std::cout << \"Hello!\\n\";\n}\n\nint main()\n{\n    // x can not be used here because it's not in scope yet\n\n    int x{ 0 }; // x enters scope here and can now be used within this function\n\n    doSomething();\n\n    return 0;\n} // x goes out of scope here and can no longer be used\n\n\n\n\n\n\n\n\n\nOut of scope: an identifier cannot be accessed anywhere within the code\nGoing out of scope: for objects, an object goes out of the scope at the end of the scope. A local variable’s lifetime ends at the point where it goes out of scope.\nNot all types of variable are destroyed when they go out of scope.\n\n\n\n\nAnother example:\n\n\nCode\n#include <iostream>\n\nint add(int x, int y) // x and y are created and enter scope here\n{\n    // x and y are visible/usable within this function only\n    return x + y;\n} // y and x go out of scope and are destroyed here\n\nint main()\n{\n    int a{ 5 }; // a is created, initialized, and enters scope here\n    int b{ 6 }; // b is created, initialized, and enters scope here\n\n    // a and b are usable within this function only\n    std::cout << add(a, b) << '\\n'; // calls function add() with x=5 and y=6\n\n    return 0;\n} // b and a go out of scope and are destroyed here\n\n\n\n\n\n\n\n\nKey insight\n\n\n\nNames used for function parameters or variables declared in a function body only visible within the function that declares them. Local variables within a function can be named without regard for the names of variables in other functions. This helps keep functions independent.\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nDefine the local variables as close to their first use as reasonable."
  },
  {
    "objectID": "C2_function_file.html#why-functiona-are-useful-and-how-to-use-them-effectively",
    "href": "C2_function_file.html#why-functiona-are-useful-and-how-to-use-them-effectively",
    "title": "3  Funtions and Files",
    "section": "3.5 Why functiona are useful, and how to use them effectively",
    "text": "3.5 Why functiona are useful, and how to use them effectively\n\nWhy use functions?\n\nOrganization:\n\nSimpler the main() function\nA function is a mini-program that we can write separately\nHelp us to have more manageable chunks\n\nRe-usability:\n\nFunction can be called many times within a program\nFollow “Do not repeat yourself” to minimize the copy/paste error\nCan be shared with other program\n\nTesting:\n\nFunctions reduces code redundancy, so less code to test\nFunction is self-contained, when it is tested, we do not need to test it again unless we change it.\nMake easier to find bugs\n\nExtensibility:\n\nWhen we need to extend the program to handle case it didn’t handle before, function allow us to make change in one place\n\nAbstraction:\n\nWe only need: name, inputs, outputs and where it lives.\nDo not need to know how it works, what other code it’s dependent\nReduce the amount of knowledge\n\n\n\n\nEffectively using functions\n\nWhen there are repeated group of statements\nGenerally perform one and only one task"
  },
  {
    "objectID": "C2_function_file.html#forward-declarations-and-definitions",
    "href": "C2_function_file.html#forward-declarations-and-definitions",
    "title": "3  Funtions and Files",
    "section": "3.6 Forward declarations and definitions",
    "text": "3.6 Forward declarations and definitions\nWe start by the simple program:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n    return 0;\n}\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\n\nThe compiler returns error: identifier add is not found. In the program, we defined add after main, and compiler reads the code sequentially so it cannot find add in main. There are two ways to address the issu:\n\nReorder the function definitions\nWe defined add before main:\n\n\nCode\n#include <iostream>\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\nint main()\n{\n    std::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n    return 0;\n}\n\n\nIt is good in the program. But in larger program, it is difficult to know which functions call which functions. For example, A calls B and B also calls A; we have trouble to find the appropriate order of functions. The second option will solve this problem.\n\n\nUse a forward declaration\nA forward declaration allows us to tell the compiler about the existence of a function before we define the function’s body. The compiler encounter a call to the function, it will understanding and check whether we are calling function correctly, it doesn’t know how or where the function is defined1.\nHere is an example of forward function declaration:\n\n\nCode\n#include <iostream>\n\nint add(int x, int y);\n\nint main()\n{\n    std::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n    return 0;\n}\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\n\nForward declaration also helps to read the code from different files.\n\n\nDeclaration and definition\nA definition actually implement (for function or types) or instantiates (for variables) the identifier.\n\n\nCode\nint add(int x, int y)    // implement function add()\n{\n  int x{ }  // instantiates variable\n}\n\n\nA definition is needed to satisfy the linker. The one definition rule (ODR):\n\nWithin a file, a function, a variable, type, or template can only have one definition.\nWithin a given program, a variable or normal function can only have one definition\nTypes, templates, inline functions, and inline variables are allowed to have identical definitions in different files"
  },
  {
    "objectID": "C2_function_file.html#programs-with-multiple-code-files",
    "href": "C2_function_file.html#programs-with-multiple-code-files",
    "title": "3  Funtions and Files",
    "section": "3.7 Programs with multiple code files",
    "text": "3.7 Programs with multiple code files\nWe can create a another code file in the Solution Explorer. The code file contains the function called in main code file. Remember to declare the function in main source code so that the compiler checks and passes successfully.\nAfter compiling, the program will link on the compiled files in the solution to execute.\nIn the project, we created a code file named Add.cpp to define the function add.\n\n\nCode\n# In the add.cpp\nint add(int x, int y)\n{\n    return x + y;\n}\n\n\nTogether with the code file:\n\n\nCode\n# In the main source code\n#include <iostream>\n\nint add(int x, int y);\n\nint main()\n{\n    std::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\nBecause the compiler compiles each code file individually, each code files that uses std::cout, std::cin needs to #include<iostream>. Similarly, we includes other libraries if we use the functions in them.\nWhenever you create a new code (.cpp) file, you will need to add it to your project so that it gets compiled."
  },
  {
    "objectID": "C2_function_file.html#naming-collisions-and-an-introfuction-to-namespaces",
    "href": "C2_function_file.html#naming-collisions-and-an-introfuction-to-namespaces",
    "title": "3  Funtions and Files",
    "section": "3.8 Naming collisions and an introfuction to namespaces",
    "text": "3.8 Naming collisions and an introfuction to namespaces\nC++ requires that all identifiers be non-ambiguous, otherwise the program produces an error as name collision. If the names conflict in the same file, there is a compile error; if it is in the separate files in the same program, there is a linker error.\nC++ provides plenty of mechanisms for avoiding naming collisions.\n\nLocal scopes: keep local variables defined inside functions from conflicting with each other\nBut local scopes does not work for function names.\n\n\nNamespace\nNamespace is a region that allows us to declare names inside of it for the purpose of disambiguation; it provides a scope region called namespace scope.\n\n\n\n\n\n\n\nA name declared in a namespace will not be mistaken for an identical name declared in another scope.\nWithin a namespace, all names are unique.\nNamespace often groups related identifiers in a large project to avoid collide with other identifiers.\n\n\n\n\n\nThe global namespace\nAny name that is not defined inside a class, function, or a namespace is considered to be part of an implicitly defined namespace, global namespace.\nOnly declaration and definition statements can appear in the global namespace. We can define variable in the global namespace, but this should generally be avoided.. Let read carefully the example code below:\n\n\nCode\n#include <iostream> // handled by preprocessor\n\n# All of the following statements are part of the global namespace\nvoid foo();    # okay: function forward declaration in the global namespace\nint x;         # compiles but strongly discouraged: uninitialized variable definition in the global namespace\nint y { 5 };   # compiles but discouraged: variable definition with initializer in the global namespace\nx = 5;         # compile error: executable statements are not allowed in the global namespace\n\nint main()     # okay: function definition in the global namespace\n{\n    return 0;\n}\n\nvoid goo();    # okay: another function forward declaration in the global namespace\n\n\n\n\nThe std namespace\nWe usually typed std::cout: we tell the compiler to search for the function cout inside the namespace std. This approach avoid any collide with any functions in other library or namespace.\n\n\n\n\n\n\nWhen you use an identifier that is defined a namespace (such as the std namespace), you have to tell the compiler that the identifier lives inside the namespace.\n\n\n\n\n\n\n\n\n\nAvoid using-directives (such as using namespace std;) at the top of your program or in header files. They vioalate the reason why namespace were added in the firest place."
  },
  {
    "objectID": "C2_function_file.html#introduction-to-the-preprocessor",
    "href": "C2_function_file.html#introduction-to-the-preprocessor",
    "title": "3  Funtions and Files",
    "section": "3.9 Introduction to the preprocessor",
    "text": "3.9 Introduction to the preprocessor\nEach code file goes through a preprocessing phase; a program called preprocessor make various changes to the text of the code file.\nThis phase works with the #include, #define. When we use #include, the preprocessor copies all the files to the compiler."
  },
  {
    "objectID": "C2_function_file.html#header-files",
    "href": "C2_function_file.html#header-files",
    "title": "3  Funtions and Files",
    "section": "3.10 Header files",
    "text": "3.10 Header files\nWhat do we do if we want to store all the declaration in one files? That the important role of header file (extension .h).\nHeader file contains the function and variable declarations, not definitions. We can create our own header file (paired with the function code) and #include nameOfFile.h in the main and in the functions that declared in the header file.\n\n\n\n\n\n\nBest practice\n\n\n\n\nUse a .h suffix when naming your header files.\nIf a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).\nSource files should #include their paired header file (if one exists).\nUse double quotes to include header files that you’ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you’ve installed elsewhere on your system.\nWhen including a header file from the standard library, use the version without the .h extension if it exists. User-defined headers should still use a .h extension.\nEach file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.\nEach header file should have a specific job, and be as independent as possible. For example, you might put all your declarations related to functionality A in A.h and all your declarations related to functionality B in B.h. That way if you only care about A later, you can just include A.h and not get any of the stuff related to B.\nBe mindful of which headers you need to explicitly include for the functionality that you are using in your code files\nEvery header you write should compile on its own (it should #include every dependency it needs)\nOnly #include what you need (don’t include everything just because you can).\nDo not #include .cpp files.\n\n\n\nThe author discuss the use of Header Guard helps to avoid the problem of collission between files in the program when creating headers."
  },
  {
    "objectID": "C2_function_file.html#how-to-design-your-first-programs",
    "href": "C2_function_file.html#how-to-design-your-first-programs",
    "title": "3  Funtions and Files",
    "section": "3.11 How to design your first programs",
    "text": "3.11 How to design your first programs\nThe most important to remember is to design the program before you start coding. It is like architecture. A little up-front planning saves both time and frustation in th long run.\n\nDesign step 1: Define your goal\nShould address the goal in one or two sentences, often useful to express this as a user-facting outcome. Example:\n\nAllow the user to organize a list of names and associated phone numbers\nModel how long it takes for a ball dropped off a tower to hit the ground\n\n\n\nDesign step 2: Define requirements\nThis focuses on the “what”, not the “how”. For example:\n\nPhone numbers should be saved, so they can be recalled later\nThe program should produce results within 10 seconds of the user submitting their request\n\nA single problem may yield many requirements, and the solution is not “done” until it satisfies all of them.\n\n\nDesign step 3: Define your tools, targets, and backup plan\nAs a new programmer, the answers are simple:\n\nWriting a program for own use\nOn own system\nUsing IDE purchased or downloaded\n\n\n\nDesign step 4: Break hard problems down into easy problems\nTry split the complex task to sub-task and continuing define smaller sub-task until they are manageable.\n\n\nDesign step 5: Figure out the sequence of events\nThen, we determine how to link all tasks together. For example, if we are writing a calculator, we might do things in this order:\n\nGet first number from user\nRecognize the operator from user\nGet second number from user\nCalculate result\nPrint result back to user\n\nThen, we can implement them\n\n\nImplementation step 1: Outlining the main function\nDo not worry about input and outphut for the time being\n\n\nCode\nint main() {\n  // Get first number from user\n      // getUserNumer();\n  \n  // Recognize the operator from user\n      // getMathOperation()\n  \n  //  Get second number from user\n      // getUserNumer();\n  \n  // Calculate result\n      // calculateResult();\n  \n  //  Print result\n      // printResult();\n  \n  return 0;\n}\n\n\n\n\nImplementation step 2: Implement each function\nIn this step, for each function, we do three things:\n\nDefine the function prototypes (input, output)\nWrite the function\nTest the function\n\n\n\nCode\n#include <iostream>\n\nint getUserNumber() {\n\n    std::cout << \"Enter an integer: \";\n    \n    int number{};\n    std::cin >> number;\n\n    return number;\n}\n\nint main() {\n\n    // Get first number from user\n    int value{ getUserNumber() };\n    std::cout << value << '\\n';     //debug code\n\n    // Recognize the operator from user\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDo not implement your entire program in one go. Work on it in steps, testing each step along the way before proceeding.\n\n\n\n\n\nImplementation step 3: Final testing\nOnce your program is “finished”, the last step is to test the whole program and ensure it works as intended. If it doesn’t work, fix it.\n\n\n\n\n\n\nWord of advice\n\n\n\n\nKeep your programs simple to start: make your first goal as simple as possible.\nAdd features over time: Once you have your simple program working and working well, then you can add features to it\nFocus on one area at a time: Focus on one task at a time\nTest each piece of code as you go.\nDo not invest in perfecting early code\n\n\n\nThe good news is that once you become comfortable with all of these concepts, they will start coming more naturally to you. Eventually you will get to the point where you can write entire functions without any pre-planning at all."
  },
  {
    "objectID": "c3_data_type.html#introduction-to-fundamental-data-types",
    "href": "c3_data_type.html#introduction-to-fundamental-data-types",
    "title": "4  Fundamental Data Types",
    "section": "4.1 Introduction to fundamental data types",
    "text": "4.1 Introduction to fundamental data types\n\n\n\n\n\n\nRecall\n\n\n\nVariable is a names of a piece of memory that we will store a certain type of information (data) into.\n\n\nAll data on a computer is just a sequence of bits, we use a data type to tell the compiler how to interpret the contents of memory in some meaningful way.\nWhen we give an object a value, the compiler and CPU covert it to bit and store in a memory; when we consult the value, the bit is recovered to the human-readable format.\n\n4.1.1 Fundamental data types\nTable belows summray the data types in C++:\n\n\n\nFigure 4.1: Data types\n\n\n\n\n4.1.2 Void\nVoid means no type. Then, a variables cannot be defined with a type of void.\nvoid uses with function does not return value.\n\n\nCode\n#include<iostream>\n\nvoid writeValue(int x)\n{\n  std::cout << \"The value is: \" << x << '\\n';\n}\n\n\nIf we return value, compiler returns error.\n\n\n4.1.3 Object sizes and the size of operator\n\n\nCode\n#| label: typeSize\n\n#include <iostream>\n\nint main()\n{\n    std::cout << \"bool:\\t\\t\" << sizeof(bool) << \" bytes\\n\";\n    std::cout << \"char:\\t\\t\" << sizeof(char) << \" bytes\\n\";\n    std::cout << \"wchar_t:\\t\" << sizeof(wchar_t) << \" bytes\\n\";\n    std::cout << \"char16_t:\\t\" << sizeof(char16_t) << \" bytes\\n\";\n    std::cout << \"char32_t:\\t\" << sizeof(char32_t) << \" bytes\\n\";\n    std::cout << \"short:\\t\\t\" << sizeof(short) << \" bytes\\n\";\n    std::cout << \"int:\\t\\t\" << sizeof(int) << \" bytes\\n\";\n    std::cout << \"long:\\t\\t\" << sizeof(long) << \" bytes\\n\";\n    std::cout << \"long long:\\t\" << sizeof(long long) << \" bytes\\n\";\n    std::cout << \"float:\\t\\t\" << sizeof(float) << \" bytes\\n\";\n    std::cout << \"double:\\t\\t\" << sizeof(double) << \" bytes\\n\";\n    std::cout << \"long double:\\t\" << sizeof(long double) << \" bytes\\n\";\n\n    return 0;\n}\n\n\n\n\n4.1.4 Signed intgeger\nSigned integer is integer with sign operator. These are the conventional definition of interger:\n\n\nCode\nshort s;            // short int\nint i;\nlong l;           // long int\nlong long ll;     // long long int \n\n\n\n\n4.1.5 Floating point numbers\nFor floating numbers, we have the appropriate value; std::cout displays from 6 to 8 digits. We can override this format by use std::setprecision(#digits) from headers iomanip.\nThe precision does not only impact the fractional number, they impact any number with too many significant digits:\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    float f{ 123456789.0f };\n    std::cout << std::setprecision(9);\n    std::cout << f << '\\n';\n\n    return 0;\n}\n\n#> 123456792\n\n\nIn the example, 1234567892 is greater than 123456789. The value of 123456789.0 has 10 significant digits, but float values typically have 7 digits of precision, then we lost precision\n\n\n\n\n\n\nBest practice\n\n\n\nFavor double over float type.\n\n\n\n\n4.1.6 Rounding errors makes floating point comparision tricky\nFloating point numbers are tricky to work due to non-obvious differences between binary and decimal. The fraction 0.1, in binary, 0.1 represented by infinite sequence 0.00011001100110011… Thus, we assign 0.1 to floating point number, we run into rounding errors.\nLet see the following code:\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    double d{ 0.1 };\n    std::cout << d << '\\n'; // use default cout precision of 6\n    std::cout << std::setprecision(17);\n    std::cout << d << '\\n';\n\n    return 0;\n}\n\n#> 0.1\n#> 0.10000000000001\n\n\nThe double type guarantee precision for 16 digits, when there are more than that, there is not precision. Another one\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    std::cout << std::setprecision(17);\n\n    double d1{ 1.0 };\n    std::cout << d1 << '\\n';\n\n    double d2{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 }; // should equal 1.0\n    std::cout << d2 << '\\n';\n\n    return 0;\n}\n\n#> 1\n#> 0.999999999999999999999999\n\n\n\n\n4.1.7 Boolean values\nBoolean type takes only two value: ‘true’ or ‘false’. In C++, the system represents it as an integer which 0 for ‘false’ and 1 for ‘true’. If we want to print the values rather than number, we have to use the function std::boolalpha.\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    std::cout << true << '\\n';\n    std::cout << false << '\\n';\n\n    std::cout << std::boolalpha;\n\n    std::cout << true << '\\n';\n    std::cout << false << '\\n';\n\n    return 0;\n}\n\n#> 1\n#> 0\n#> true\n#> false\n\n\nThis is similar to the get information from user:\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    std::cout << \"Enter a boolean value: \";\n    \n    bool b{};\n    std::cin >> b;\n    \n    std::cout << \"You enter: \" << b << '\\n';\n\n    return 0;\n}\n\n#> Enter a Boolean value: true\n#> You entered: 0\n\n\nWe can do:\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nint main()\n{\n    std::cout << \"Enter a boolean value: \";\n    \n    bool b{};\n    std::cin >> std::boolalpha;\n    std::cin >> b;\n    \n    std::cout << \"You enter: \" << b << '\\n';\n\n    return 0;\n}\n\n\n\n4.1.7.1 Boolean return value\nWe can create a function that return boolean value:\n\n\nCode\n#include <iostream>\n#include <iomanip>      // for std::setprecision()\n\nbool isEqual(int x, int y) {\n    return (x == y);\n}\n\nint getInteger() {\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    return x;\n}\nint main() {\n    \n    int x{ getInteger() };\n    int y{ getInteger() };\n\n    std::cout << std::boolalpha;\n    std::cout << \"Does \" << x << \" equal \" << y << \"?\\n\";\n    std::cout << isEqual(x, y) << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "c3_data_type.html#introduction-to-if-statement",
    "href": "c3_data_type.html#introduction-to-if-statement",
    "title": "4  Fundamental Data Types",
    "section": "4.2 Introduction to if statement",
    "text": "4.2 Introduction to if statement\nConditional statement is common in programming language; they allow us to implement conditional behavior into our programs.\nThe simplest type of conditional statement in C++ is if statement, following the form:\n\nif (condition) true_statement;\n\n\n\n\n\n\n\nIf statements only conditionally execute a single statement. We talk about how to conditionally execute multiple statements in lesson 7.2 – If statements and blocks."
  },
  {
    "objectID": "c3_data_type.html#chars",
    "href": "c3_data_type.html#chars",
    "title": "4  Fundamental Data Types",
    "section": "4.3 Chars",
    "text": "4.3 Chars"
  },
  {
    "objectID": "c3_data_type.html#an-introduction-to-explicit-type-conversion-via-the-static_cast-operator",
    "href": "c3_data_type.html#an-introduction-to-explicit-type-conversion-via-the-static_cast-operator",
    "title": "4  Fundamental Data Types",
    "section": "4.4 An introduction to explicit type conversion via the static_cast operator",
    "text": "4.4 An introduction to explicit type conversion via the static_cast operator\nIf we want to explicitly change the type of data, we can use static_cast<new_type>(expression).1\n\n\nCode\n#include <iostream>\n\nvoid print(int x)\n{\n    std::cout << x;\n}\n\nint main()\n{\n    print( static_cast<int>(5.5) ); // explicitly convert double value 5.5 to an int\n\n    return 0;\n}\n\n\nWe can use this to covert chart to int:\n\n\nCode\n#include <iostream>\n\nint main() {\n    \n    char ch{ 'a' };\n    std::cout << ch << '\\n';\n\n    std::cout << ch << \" has value \" << static_cast<int>(ch) << '\\n';\n\n    return 0;\n}\n\n\nAnother exercise:\n\n\nCode\nint main() {\n    \n    std::cout << \"Please enter a single character: \";\n    char ch{};\n    std::cin >> ch;\n\n    std::cout << \"You entered '\" << ch << \"'\" << \", which has ASCII code \" << static_cast<int>(ch);\n\n    return 0;\n}"
  },
  {
    "objectID": "c3_data_type.html#const-variables-and-symbolic-constants",
    "href": "c3_data_type.html#const-variables-and-symbolic-constants",
    "title": "4  Fundamental Data Types",
    "section": "4.5 Const variables and symbolic constants",
    "text": "4.5 Const variables and symbolic constants\nConst variable: initialized variable with value and cannot assign different values later.\nLet look the code to create a const variable:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    const double gravity{ 9.8 };\n    gravity = 9.9;\n\n    return 0;\n}\n\n#> Error    C3892   'gravity': you cannot assign to a variable that is const\n\n\nAge example:\n\n\nCode\n#include <iostream>\n\nint main() \n{\n  std::cout << \"Enter your age: \";\n  \n  int age{};\n  std::cin >> age;\n  \n  const int constAge { age };\n  \n  age = 5         //okie\n  constAge = 6    // error: constAge is constant\n  \n  return 0;\n}\n\n\nWe can set the const for parameter, but do not prefer to do that."
  },
  {
    "objectID": "c3_data_type.html#compile-time-constants-constant-expressions-and-constexpr",
    "href": "c3_data_type.html#compile-time-constants-constant-expressions-and-constexpr",
    "title": "4  Fundamental Data Types",
    "section": "4.6 Compile-time constants, constant expressions, and constexpr",
    "text": "4.6 Compile-time constants, constant expressions, and constexpr\nConstant expression is an expression that can be evaluated by the compiler at compile time.\nCompile-time constant: a constant whose value is known at compile-time.\n\n\n\n\n\n\nA const variable is a compile-time constant if its initializer is a constant expression.\nEvaluating const expression takes longer at compile time, but saves time at runtime.\n\n\n\nRuntime const: every const variable initialized with a non-constant expression is a runtime constant. Runtime constants are constants whose initialization values are not known until runtime.\n\n4.6.1 The constexpr keyword\nCompile always implicitly keep track of const variables to know whether it’s a runtime or compile-time const. A variable can only be compile-time const.\nLet read the example:\n\n\nCode\n// constexpr uses\n    constexpr double gravity{ 9.8 };    // ok: 9.8 is a const expression\n    constexpr int sum{ 4 + 5 };         //ok\n    constexpr int something{ sum };     // ok: sum is const expression\n\n    std::cout << \"Enter you age: \";\n    int age{};\n    std::cin >> age;\n\n    constexpr int myAge{ age };     // compile error: age is not const expression\n    constexpr int f{ five() };      // compile error: return value of five() is not constant expression\n\n\n\n\n\n\n\n\nBest practice\n\n\n\n\nAny variable that should not be modifiable after initialization and whose initializer is known at compile-time should be declared as constexpr.\nAny variable that should not be modifiable after initialization and whose initializer is not known at compile-time should be declared as const."
  },
  {
    "objectID": "c3_data_type.html#literals",
    "href": "c3_data_type.html#literals",
    "title": "4  Fundamental Data Types",
    "section": "4.7 Literals",
    "text": "4.7 Literals\nLiterals are unnamed values inserted directly into the code. For example:\n\n\nCode\nreturn 5;\nboot myNameIsAlex{ true };\nstd::cout << 3.4;\n\n\nLike objects, all literals have type. There type is in"
  },
  {
    "objectID": "c3_data_type.html#string",
    "href": "c3_data_type.html#string",
    "title": "4  Fundamental Data Types",
    "section": "4.8 String",
    "text": "4.8 String\nAn example of string is \"Hello world?\\n\"; a sequence of characters. String is not natural in C++ language. We use std::string to work with string by including the header <string> in the header\nHere is an example:\n\n\nCode\n#include <string>\n#include <iostream>\n\nint main()\n{\n    //std::string name{};       // empty string\n    std::string name{ \"Huy\" };      // initialized with value\n    name = \"Quang\";\n\n    std::string myID{ \"45\" };\n\n    std::cout << \"My name is \" << name << '\\n';\n\n    std::string empty{};\n    std::cout << '[' << empty << ']';\n\n    return 0;\n}\n\n\n\n4.8.1 String input with std::cin\nUsing strings with std::cin my yield some surprises. Let see the example:\n\n\nCode\n#include <string>\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter your full name: \";\n    std::string name{};\n    std::cin >> name;\n\n    std::cout << \"Enter your age: \";\n    std::string age{};\n    std::cin >> age;\n\n    std::cout << \"Your name is \" << name << \" and your age is \" << age << '\\n';\n\n    return 0;\n}\n\n#> Input: Quang Huy\n#> Your name is Quang and your age is Huy\n\n\nNormally, the >>operator only extract the string before first space, and the rest is stored for the next >>operator.\nTo get the full string input, it is better to use std::getline():\n\n\nCode\n#include <string>\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter your full name: \";\n    std::string name{};\n    std::getline(std::cin >> std::ws, name);\n\n    std::cout << \"Enter your age: \";\n    std::string age{};\n    std::getline(std::cin >> std::ws, age);\n\n    std::cout << \"Your name is \" << name << \" and your age is \" << age << '\\n';\n\n    return 0;\n}\n\n\nThe input manipulator std::ws tells std::in ignore any leading whitespace (spaces, tabs, newlines) in the string. Here is another example:\n\n\nCode\n#include <string>\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Pick 1 or 2: \";\n    int choice{};\n    std::cin >> choice;\n\n    std::cout << \"Now enter your name: \";\n    std::string name{};\n    std::getline(std::cin >> std::ws, name);        // no std::ws here\n    std::cout << \"Hello \" << name << \", you chose \" << choice << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nIf using std::getline() to read strings, use std::cin >> std::ws input manipulator to ignore leading whitespace.\n\n\n\n\n4.8.2 String length\nWe use the length() function to return the string’s length. In C++, the length function is nested in std::string, it is written as std::string::length() in documentation. Thus, length() is not normal standalone function, it is called member function.\n\n\n\n\n\n\nKey insight\n\n\n\nWith normal function, we call function(object). With member function, we call object.function().\n\n\nlength() return unsigned integral value, to assign it to integer value, we have to use static_cast<type><name.length()>. We can also use ssize(name) to get the length as a signed integer.2\n\n\n\n\n\n\nBest practice\n\n\n\nDo not pass std::string by value, as making copies of std::string is expensive. Prefer std::string_view parameters.\n\n\n\n\n4.8.3 Literals for std::string\nWe can create string literals with type std::string by using s suffix after the double-quote string literal.\nHere is the exercise from this session:\n\n\nCode\n#include <iostream>\n#include <string>\n#include <string_view>\n\nint main()\n{\n    std::cout << \"Enter your full name: \";\n    std::string name{};\n    std::getline(std::cin >> std::ws, name);\n\n    std::cout << \"Enter your age: \";\n    int age{};\n    std::cin >> age;\n\n    //std::cout << \"Your age + length of your name is: \" << age + static_cast<int>(name.length());\n\n    int letters{ static_cast<int>(name.length()) };\n    std::cout << \"Your age + length of your name is: \" << age + letters << '\\n';\n    \n  return 0;\n}"
  },
  {
    "objectID": "c3_data_type.html#introduction-to-stdstring_view",
    "href": "c3_data_type.html#introduction-to-stdstring_view",
    "title": "4  Fundamental Data Types",
    "section": "4.9 Introduction to std::string_view",
    "text": "4.9 Introduction to std::string_view\nWhen use std:string, it creates a copy of the string, this is inefficient. Thus, from C++ 17, there is std::string_view from string_view header that provide read-only access to an existing string, not a copy of a string.\nHere is an example:\n\n\nCode\n#include <iostream>\n#include <string>\n#include <string_view>\n\nvoid printSV(std::string_view str)\n{\n    std::cout << str << '\\n';\n}\nint main()\n{\n    std::string_view s{ \"Hello world!\" };\n    printSV(s);\n\n    return 0;\n}\n\n\nUnlike std::string, std::string_view support constexpr:\n\n\n\n\n\n\n\nReturning a std::string_view from a function is usually a bad idea. We will explore why in lesson 11.7 – std::string_view (part 2). For now, avoid doing so.\nThe chapter summary can be found at https://www.learncpp.com/cpp-tutorial/chapter-4-summary-and-quiz/"
  },
  {
    "objectID": "c4_debug.html#syntax-and-semantic-errors",
    "href": "c4_debug.html#syntax-and-semantic-errors",
    "title": "5  Debugging C++ Programs",
    "section": "5.1 Syntax and semantic errors",
    "text": "5.1 Syntax and semantic errors\n\nSoftware errors are prevalent. It’s easy to make them, and it’s hard to find them\n\nTwo catergories of errors:\n\nSyntax error: write a statement that is not valid according to the grammar of C++ (missing semicolons, using undeclared variables, missing braces, etc…). A compiler will catch these errors, so we identify and fix them. For example:\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout < \"Hi there\"; << x << '\\n'; // invalid operator (<), extraneous semicolon, undeclared variable (x)\n    return 0 // missing semicolon at end of statement\n}\n\n\n\nSemantic error occurs when a statement is syntactically valid, does not do what the we want.\n\nSometimes it cause the program to crash\n\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int a { 10 };\n    int b { 0 };\n    std::cout << a << \" / \" << b << \" = \" << a / b << '\\n'; // division by 0 is undefined\n    return 0;\n}\n\n\n\nOr wrong value\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x;\n    std::cout << x << '\\n'; // Use of uninitialized variable leads to undefined result\n\n    return 0;\n}\n\n\n\nOr\n\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    return 0; // function returns here\n\n    std::cout << \"Hello, world!\\n\"; // so this never executes\n}"
  },
  {
    "objectID": "c4_debug.html#the-debugging-process",
    "href": "c4_debug.html#the-debugging-process",
    "title": "5  Debugging C++ Programs",
    "section": "5.2 The debugging process",
    "text": "5.2 The debugging process\nGenerally, there are 5 steps:\n\nFind the root cause of the problem\nEnsure you understand why the issue is occuring\nDetermine how you’ll fix the issue\nRepair the issue causing the problem\nRetest to ensure the problem has been fixed and no new problems have emerged\n\n\n5.2.1 Debugger\nA debugger is a computer program that allows the programmer to control how another program executes and examine the program state while that program is running. For example, a programmer can use debugger to execute a program line by line, examining the value of variables along the way.\nThe advantage:\n\nThe ability to precisely control execution of program\nTo view the program state\n\n\n\n\n\n\n\nDo not neglect learning to use a debugger. As your programs get more complicated, the amount of time you spend learning to use the integrated debugger effectively will pale in comparison to amount of time you save finding and fixing issues.\n\n\n\n\n\n5.2.2 The call stack\nThe call stack is a list of all active functions that have been called to get to the current point of execution. It includes an entry for each function called, as well as which line code will be returned to when the function returns. Whenever a new functions is called, that function is added to the top of the call stack."
  },
  {
    "objectID": "c5_operators.html#introduction",
    "href": "c5_operators.html#introduction",
    "title": "6  Operators",
    "section": "6.1 Introduction",
    "text": "6.1 Introduction\nAn operation is an mathematical calculation involving zero or more input values (called operand) to produce a new value. The specific operation to be performed is denoted by a construct (symbol or pair of symbols: +, -, “*”, “/”, ….) called an operator.\nOperator precedence:\n\nIn the compound expression (including more than 1 operators), C++ use the rule of operator precedence. Each operator is assigned one level, the higher level operator will be evaluate first.\nWhen the operators have the same level, C++ uses operator associativity that indicates whether the it analyzes from left-to-right or right-to-left.\nWe can use the pasteurization for explicitly say the order of the operator\n\n\n\n\n\n\n\nBest practice\n\n\n\nUse parentheses to make it clear how a non-trivial expression should evaluate (even if they are technically unnecessary).\n\n\nFor example\n\n\nCode\nx = (y + z + w);   // instead of this\nx = y + z + w;     // it's okay to do this\n\nx = ((y || z) && w); // instead of this\nx = (y || z) && w;   // it's okay to do this\n\nx = (y *= z); // expressions with multiple assignments still benefit from parenthesis\n\n\n\n\n\n\n\n\nIn many cases, the operands in a compound expression may evaluate in any order. This includes function calls and the arguments to those function calls.\n\n\n\nWe can have the mistakes that the compiler chooses the order differs from what we want:\n\n\nCode\n#include <iostream>\n\nint getValue()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    return x;\n}\nint main()\n{\n    std::cout << getValue() + (getValue() * getValue());\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nOutside of the operator precedence and associativity rules, assume that the parts of an expression could evaluate in any order. Ensure that the expressions you write are not dependent on the order of evaluation of those parts.\n\n\nExample for best practice:\n\n\nCode\n#include <iostream>\n\nint getValue()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    return x;\n}\nint main()\n{\n    int a{ getValue() };\n    int b{ getValue() };\n    int c{ getValue() };\n\n    std::cout << a + (b * c);\n\n    return 0;\n}"
  },
  {
    "objectID": "c5_operators.html#arithmetic-operators",
    "href": "c5_operators.html#arithmetic-operators",
    "title": "6  Operators",
    "section": "6.2 Arithmetic operators",
    "text": "6.2 Arithmetic operators\nThere are two unary arithmetic operators:\n\n\n\nUnary Arithmetic\n\n\nThe binary arithmetic operators:\n\n\n\nBinary Arithmetic\n\n\nArithmetic assignment operators\n\n\n\nArithmetic Assignment operators"
  },
  {
    "objectID": "c5_operators.html#incrementdecrements-operators-and-side-effects",
    "href": "c5_operators.html#incrementdecrements-operators-and-side-effects",
    "title": "6  Operators",
    "section": "6.3 Increment/decrements operators, and side effects",
    "text": "6.3 Increment/decrements operators, and side effects\n\n\n\nIncrement/decrement operators\n\n\nLet have an example:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    int y{ 5 };\n\n    std::cout << x << ' ' << y << '\\n';\n    std::cout << ++x << ' ' << --y << '\\n'; // prefix make the calculation \n                                           //  and assign directly\n    std::cout << x << ' ' << y << '\\n';\n\n    std::cout << x++ << ' ' << y-- << '\\n'; // postfix creates a copy, calcul, \n                                            // and return the copy\n    std::cout << x << ' ' << y << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nBest practice\n\n\n\nStrongly favor the prefix version.\n\n\n\n6.3.1 Side effects can cause undefined behavior\n\nA function or expression is said to have a side effect if has some obervable effect beyond producing a return value.\n\nCommon examples are assignment value of objects, doing input, output,… Most of the time, side effects are useful:\n\n\nCode\nx = 5;\n++x;\nstd::cout << x\n\n\nHowever, side effects can also lead to unexpected results:\n\n\nCode\nint add(int x, int y)\n{\n    return x + y;\n}\n\nint main()\n{\n    int x{ 5 };\n    \n    int value{ add(x, ++x) };\n    std::cout << value << '\\n'; // value depends on how the above line evaluates\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\nC++ does not define the order of evaluation for function arguments or the operands of operators.\nDon’t use a variable that has a side effect applied to it more than once in a given statement. If you do, the result may be undefined."
  },
  {
    "objectID": "c5_operators.html#comma-and-conditional-operators",
    "href": "c5_operators.html#comma-and-conditional-operators",
    "title": "6  Operators",
    "section": "6.4 Comma and conditional operators",
    "text": "6.4 Comma and conditional operators\n\n\n\nComma operator\n\n\nThe comma operator allows us to evaluate multiple expressions wherever a single expression is allowed.\nIn almost every case, a statement written using the comma operator would be better written as a separate statements.\n\n\n\n\n\n\nBest practice\n\n\n\nAvoid using the comma operator, except within for loops\n\n\n\n6.4.1 Comma as a separator\nIn C++, comma symbol is often used as a separator, and does not invoke the comma operator:\n\n\nCode\nvoid foo(int x, int y) // Comma used to separate parameters in function definition\n{\n    add(x, y); // Comma used to separate arguments in function call\n    constexpr int z{ 3 }, w{ 5 }; // Comma used to separate multiple variables being defined on the same line (don't do this)\n}\n\n\n\n\n6.4.2 Conditional operator\n\n\n\nConditional operator\n\n\nAlways parenthesize the conditional part of the conditional operator, and consider parenthesizing the whole thing as well.\n\n6.4.2.1 The conditional operator evaluates as an expression\nBecause the conditional operator operands are expressions rather than statements, the conditional operator can be used in some places where if/else cannot.\n\n\n\n\n\n\nThe type of expressions in conditional operator must match or be convertible.\n\n\n\nThe conditional operator gives us a convenient way to compact some if/else statements. It’s most useful when we need a conditional initializer (or assignment) for a variable, or to pass a conditional value to a function."
  },
  {
    "objectID": "c5_operators.html#relational-operators-and-floating-point-comparisons",
    "href": "c5_operators.html#relational-operators-and-floating-point-comparisons",
    "title": "6  Operators",
    "section": "6.5 Relational operators and floating point comparisons",
    "text": "6.5 Relational operators and floating point comparisons\n\n\n\nRelational Operators\n\n\nComparison of calculated floating point values can be problematic.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    double d1{ 100.0 - 99.99 }; // should equal 0.01 mathematically\n    double d2{ 10.0 - 9.99 }; // should equal 0.01 mathematically\n\n    if (d1 == d2)\n        std::cout << \"d1 == d2\" << '\\n';\n    else if (d1 > d2)\n        std::cout << \"d1 > d2\" << '\\n';\n    else if (d1 < d2)\n        std::cout << \"d1 < d2\" << '\\n';\n\n    return 0;\n}\n#> d1 > d2  : error\n\n\nAvoid using operator== and operator!= to compare floating point values if there is any chance those values have been calculated."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#compound-statements",
    "href": "c6_scope_duration_linkage.html#compound-statements",
    "title": "7  Scope, duration and linkage",
    "section": "7.1 Compound statements",
    "text": "7.1 Compound statements\nCompound statement (block):\n\nZero, one, or more statement that compiler treats as simple statement\nBetween “{}”, not need semicolon at the and of “}”\nBe anywhere when the single statement is valid\n\nFunction cannot be nested inside other function, but block can. Then we have\n\nOuter block: enclosing one\nInner block: nested one\n\nBlock is very useful with if statements: replace single statement with a block. For example,\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n    int value{};\n    std::cin >> value;\n\n    if (value >= 0)\n    {\n        std::cout << value << \" is a positive integer (or zero)\\n\";\n        std::cout << \"Double this number is \" << value * 2 << '\\n';\n    }\n    else\n    {\n        std::cout << value << \" is a negative integer\\n\";\n        std::cout << \"The positive of \" << value << \" is \" << -value << '\\n';\n        std::cout << \"Then, its double is \" << (-value) * 2 << '\\n';\n    }\n\n    return 0;\n}\n\n\nNesting level or nesting depth is the maximum numbers of nested blocks inside at any point in the function. For example,\n\n\nCode\n#include <iostream>\n\nint main()\n{ // block 1, nesting level 1\n    std::cout << \"Enter an integer: \";\n    int value {};\n    std::cin >> value;\n\n    if (value >  0)\n    { // block 2, nesting level 2\n        if ((value % 2) == 0)\n        { // block 3, nesting level 3\n            std::cout << value << \" is positive and even\\n\";\n        }\n        else\n        { // block 4, also nesting level 3\n            std::cout << value << \" is positive and odd\\n\";\n        }\n    }\n\n    return 0;\n}\n\n\nThere are 4 blocks, and nesting level is 3.\n\n\n\n\n\n\nBest practice\n\n\n\nKeep the nesting level of our functions to 3 or less. If greater, think to re-factor the function into sub-ones."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#user-defined-namespaces-and-the-scope-resolution-operator",
    "href": "c6_scope_duration_linkage.html#user-defined-namespaces-and-the-scope-resolution-operator",
    "title": "7  Scope, duration and linkage",
    "section": "7.2 User-defined namespaces and the scope resolution operator",
    "text": "7.2 User-defined namespaces and the scope resolution operator\nThe better way to solve the name collisions is to put our functions in our own namespaces eg, standard library moved into std namespace.\n\n7.2.1 Define our own namespaces\nWe define namespace by using statement namespace\nin foo.cpp file:\n\n\nCode\nnamespace foo\n{\n    int doSomething(int x, int y)\n    {\n        return x - y;\n    }\n}\n\n\nin goo.cpp file:\n\n\nCode\nnamespace goo\n{\n    int doSomething(int x, int y)\n    {\n        return x - y;\n    }\n}\n\n\nin main.cpp:\n\n\nCode\n#include <iostream>\n\nint doSomething(int x, int y);\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    std::cout << doSomething(4, 3) << '\\n';\n    \n    return 0;\n}\n\n\nRunning the program, there is “LINK ERROR”: cannot find the doSomething in global namespace because it is in either foo or goo namespace.\n=> Solve this problem by: scope resolution or using statements\n\n7.2.1.1 Accessing namespace with the scope resolution operator (::)\nWe use the operator (::) to tell exactly whose namespace of the called function. For example in main.cpp\n\n\nCode\n#include <iostream>\n\nint doSomething(int x, int y);\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    std::cout << foo::doSomething(4, 3) << '\\n';\n    \n    return 0;\n}\n\n\nIf an identifier inside a namespace is used, without scope resolution, the compiler finds inside the namespace, if it cannot find, it goes to each containing namespace in sequence to find, the global namespace being checked last.\n\n\nCode\n#include <iostream>\n\nvoid print() // this print lives in the global namespace\n{\n    std::cout << \" there\\n\";\n}\n\nnamespace foo\n{\n    void print() // this print lives in the foo namespace\n    {\n        std::cout << \"Hello\";\n    }\n\n    void printHelloThere()\n    {\n        print(); // calls print() in foo namespace\n        ::print(); // calls print() in global namespace\n    }\n}\n\nint main()\n{\n    foo::printHelloThere();\n\n    return 0;\n}\n\n\nIf we define namsepace in different files to main.cpp:\n\nCreate header file for the namespace. For example, namespace foo:\n\n\n\nCode\n#ifndef FOO_H\n#define FOO_H\n\nnamespace foo\n{\n    int add(int x, int y);\n\n    int substract(int x, int y);\n\n}\n\n#endif\n\n\n\nInclude the header into the namespace file foo.cpp:\n\n\n\nCode\n#include \"foo.h\"\n\nnamespace foo\n{\n    int add(int x, int y)\n    {\n        return x + y;\n    }\n\n    int substract(int x, int y)\n    {\n        return x - y;\n    }\n}\n\n\n\nAdd header to main.cpp:\n\n\n\nCode\n#include \"foo.h\"\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    std::cout << foo::add(4, 3) << '\\n';\n    std::cout << foo::substract(10, 7) << '\\n';\n    \n    return 0;\n}\n\n\nNamespace can be nested in other namespace by declaration namespace foo::goo.\n\n\n7.2.1.2 Namespace aliases\nFor nested namespace, C++ allow to name the namespace for shortenning:\n\n\nCode\n#include <iostream>\n\nnamespace foo::goo\n{\n  int add(int x, int y)\n  {\n    return x + y;\n  }\n}\n\nint main()\n{\n  namespace active = foo::goo;  // active refers to foo::go\n  \n  std::cout << active::add(1, 2) << '\\n'; // This is really foo::goo::add()\n  \n  return 0;\n}\n\n\n\n\n\n\n\n\n\nIn general, we should avoid deeply nested namespaces.\nWe can separate application-specific code from code that might be reusable later .For example, one namespace for math: math::, language and localization: lang::\nWhen sharing the code, should put it in a namespace."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#local-variables",
    "href": "c6_scope_duration_linkage.html#local-variables",
    "title": "7  Scope, duration and linkage",
    "section": "7.3 Local variables",
    "text": "7.3 Local variables\nLocal variables have a block scope: in scope from point of definition to the end of the block they are defined within.\n\n\nCode\n#|label: block-scope\n\n#include <iostream>\n\nint main()\n{\n    int i{ 5 };         // i enters scope\n    double d{ 4.0 };   // d enters scope\n\n    return 0;\n}   // d and i go out of scope here.\n\n\nAll variable names within a scope must be unique.\nA local variable has a lifetime, called storage duration. This determine when and how a variable will be created and detroyed.\nLocal variable has automatic storage duration: created and detroyed within the block\n=> local variable == automatic variable.\nWe can define variables inside nested block:\n\nThey enters the scope at time of definition and go out at the end of the nested block. So do their lifetimes.\nThus, it cannot be found from outer block\nBut, variable in outer block can be used inside nested block.\n\n\n\nCode\n#include <iostream>\n\nint main()\n{ // outer block\n\n    int x { 5 }; // x enters scope and is created here\n\n    { // nested block\n        int y { 7 }; // y enters scope and is created here\n\n        // x and y are both in scope here\n        std::cout << x << \" + \" << y << \" = \" << x + y << '\\n';\n    } // y goes out of scope and is destroyed here\n\n    // y can not be used here because it is out of scope in this block\n\n    return 0;\n} // x goes out of scope and is destroyed here\n\n\nVariable should be defined in the most limited scope: inside the nested block that uses it.\n\n\n\n\n\n\nDefine variables in the most limited existing scope. Avoid creating new blocks whose only purpose is to limit the scope of variables."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#introduction-to-global-variables",
    "href": "c6_scope_duration_linkage.html#introduction-to-global-variables",
    "title": "7  Scope, duration and linkage",
    "section": "7.4 Introduction to global variables",
    "text": "7.4 Introduction to global variables\nWe define a variable outside of a function, this one is global variable. By convention:\n\nIt is under the #include and above any function.\nConsider using prefix ‘g’ or ‘g_’ for global variables.\n\nIts properties:\n\nHas global scope (global namespace scope)\nUses anywhere in the file\nCreated when the program starts and detroyed when it ends => static duration So, it is static variable.\nZero-initialized by default1.\nGlobal variable can be defined as constant, but we have to initialize it:\n\n\n\nCode\nconst int g_x;  //error: no default initialized\n\nconst int g_w{1}; // ok\n\n\n\n\n\n\n\n\nWe should avoid to use non-constant global variables."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#varaible-shadowing-name-hiding",
    "href": "c6_scope_duration_linkage.html#varaible-shadowing-name-hiding",
    "title": "7  Scope, duration and linkage",
    "section": "7.5 Varaible shadowing (name hiding)",
    "text": "7.5 Varaible shadowing (name hiding)\nWhen outer block and inner block have a variable with same name, the nested variable “hides” the outer variable when they are both in scope. This is called name hiding or shadowing.\nThe same applies to global variable, but global variable is a part of namespace so we can use ::prefix to indicate using global variable.\n\n\n\n\n\n\nAvoid variable shadowing"
  },
  {
    "objectID": "c6_scope_duration_linkage.html#internal-linkage",
    "href": "c6_scope_duration_linkage.html#internal-linkage",
    "title": "7  Scope, duration and linkage",
    "section": "7.6 Internal linkage",
    "text": "7.6 Internal linkage\nAn identifer’s linkage determines whether the other declarations of that name refer to the same object or not.\n\nLocal variable does not have linkage.\nGlobal variable has internal and external linkage\n\nAn internal linkage is seen and used within a single file.\nA global variable has external linkage as default, so we define internal linkage by use static ....\nBut const global variable or constexpr global variable are internal linkage by default.\n\n\nCode\nstatic int g_x{};   // internal linkage\nconst int g_y{ 2 }; // internal linkage by default\nconstexpr int g_z{ 3 }; //internal linkage by default\n\n\n\nThe one-definition rule and internal linkage\nOne-definition rule says that an object or function cannot have more than one definition, either within a file or a program. But, internal object are defined in different files are considered to be independent entities.\nWe can apply the same to function by using static:\n\n\nCode\n# This function is declared as static, and can now be used only within this file\n# Attempts to access it from another file via a function forward declaration will\n# fail\n\n[[maybe_unused]] static int add(int x, int y)\n{\n    return x + y;\n}"
  },
  {
    "objectID": "c6_scope_duration_linkage.html#external-linkage-and-variable-forward-declarations",
    "href": "c6_scope_duration_linkage.html#external-linkage-and-variable-forward-declarations",
    "title": "7  Scope, duration and linkage",
    "section": "7.7 External linkage and variable forward declarations",
    "text": "7.7 External linkage and variable forward declarations\nIdentifier with external linkage can be used and seen from its file and other code files (via a forward declaration).\n\nFunction have external linkage by default so we can use a forward declaration\nNon-const global variable are external by default\nConst global variable defined through extern keyword\nTo use global variable in other file, we also forward declaration like in function,\n\nThe following code are example of using external linkage for global variable (const and non-const one). First, we have global variable in one source file a.cpp:\n\n\nCode\nint g_x{ 3 };                   #// internal by default\nextern const int g_y { 4 };     #// okie\nextern constexpr int g_z{3};    #// can, but useless\n\n\nWe use them in the main.cpp by their declarations:\n\n\nCode\n#include <iostream>\n\nint g_x;                   #// internal by default\nextern const int g_y;     #// okie\nextern constexpr int g_z;    #// can, but useless\n\nint main()\n{\n    std::cout << g_x << '\\n'; // prints 2\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nDo not use extern keyword if we define an unitialized non-const global variable. C++ will think it is a declaration.\n\n\n\nWe should be clear about file scope and global scope: all global variable can be used within the file that defines them; if it can be seen by other files too, it has global scope (with proper declarations)."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#why-non-const-global-variables-are-evil",
    "href": "c6_scope_duration_linkage.html#why-non-const-global-variables-are-evil",
    "title": "7  Scope, duration and linkage",
    "section": "7.8 Why (non-const) global variables are evil",
    "text": "7.8 Why (non-const) global variables are evil\n\nTheir values can be changed by any function that is called => Make program state is unpredictable.\nA function that utilizes nothing but its parameters and has no side effects is perfectly modular.\nModularity helps both in understanding what a program does, as well as reusability.\nGlobal variables make the program less modular.\n\n\n\n\n\n\n\nUse local variables instead of global variables whenever possible."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#sec-sharConstVar",
    "href": "c6_scope_duration_linkage.html#sec-sharConstVar",
    "title": "7  Scope, duration and linkage",
    "section": "7.9 Sharing global constants across multiple files",
    "text": "7.9 Sharing global constants across multiple files\n\nCreate a .cpp file for a constants namespace includes all the const global variables.\nCreate a header file for that namespace\nInclude the header file in other files using the constants\n\nThis solution has downside. The compiler does not evaluate the const global variables at compile-time because it only recognizes the declarations. There may impact the performance maximization. To have a better solution, C++17 introduce a new keyword inline that allow an object can be defined in different files without violating the one definition rule.\n\n\nCode\n#> In constant.cpp\n\n#include \"constant.h\"\n\nnamespace constants\n{\n    extern const double pi{ 3.14159 };\n    extern const double avogadro{ 6.0221413e23 };\n    extern const double myGravity{ 9.2 };\n}\n\n#> In constant.h\n\n#ifndef CONSTANT_H\n#define CONSTANT_H\n\nnamespace constants\n{\n    extern const double pi;\n    extern const double avogadro;\n    extern const double myGravity;\n}\n\n#endif // !CONSTANT_H\n\n#> In main.Cpp\n\n#include \"constant.h\"\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter a radius: \";\n    int radius{};\n    std::cin >> radius;\n\n    std::cout << \"The circumfence is \" << 2.0 * radius * constants::pi << '\\n';\n\n    return 0;\n}\n\n\n\n7.9.1 Global constants as inline variables\nIn C++, the term inline has evolved to mean “multiple definitions are allowed”. An inline variable is one that is allowed to be defined in multiple files without violating one definition rule.\nInline variables have two primary restrictions that must be obeyed:\n\nAll definitions of the inline variable must be identical.\nThe inline variable definitions (not a forward declaration) must be present in any file that uses the variable.\n\nWe see the differences with the sharing constant global variables mentioned at the session’s beginning:\n\nFor inline const var, we do not need to have separate .cpp file for header because we define (not only declare) all in the header file.\n\n\n\nCode\n# In constants.h\n\n#ifndef CONSTANTS_H\n#define CONSTANTS_H\nnamespace constants\n{\n  inline constexpr double pi{3.14159};\n  inline constexpr double avogadro{6.0221413e23};\n}\n\n#endif\n\n# In main cpp\n\n#include \"constants.h\"\n\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter a radius: \";\n    int radius{};\n    std::cin >> radius;\n\n    std::cout << \"The circumference is: \" << 2.0 * radius * constants::pi << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nIf you need global constants and your compiler is C++17 capable, prefer defining inline constexpr global variables in a header file."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#static-local-variables",
    "href": "c6_scope_duration_linkage.html#static-local-variables",
    "title": "7  Scope, duration and linkage",
    "section": "7.10 Static local variables",
    "text": "7.10 Static local variables\nLocal variable, by its definition, has the scope within its block or automatic duration. When we want a local variable exists in whole the program, we use static local variables by adding static before local variable’s definition.\nLet have the examples:\n\n\nCode\n#include <iostream>\n\nvoid incrementAndPrint()\n{\n    int value{ 1 };\n    ++value;\n    std::cout << value << '\\n';\n}\n\nint main()\n{\n    incrementAndPrint();\n    incrementAndPrint();\n    incrementAndPrint();\n\n    return 0;\n}\n\n#> 2\n#> 2\n#> 2\n\n\nNow, we modify for static local variable:\n\n\nCode\n#label: static-local-var\n\n#include <iostream>\n\nvoid incrementAndPrint()\n{\n    static int value{ 1 };\n    ++value;\n    std::cout << value << '\\n';\n}\n\nint main()\n{\n    incrementAndPrint();\n    incrementAndPrint();\n    incrementAndPrint();\n\n    return 0;\n}\n#> 2\n#> 3\n#> 4\n\n\nWe use static local variable to keep track of variable like IDs for object.\n\n7.10.1 Static local constants\n\n\n\n\n\n\nAvoid static local variables unless the variable never needs to be reset"
  },
  {
    "objectID": "c6_scope_duration_linkage.html#using-declarations-and-using-directives",
    "href": "c6_scope_duration_linkage.html#using-declarations-and-using-directives",
    "title": "7  Scope, duration and linkage",
    "section": "7.11 Using declarations and using directives",
    "text": "7.11 Using declarations and using directives"
  },
  {
    "objectID": "c6_scope_duration_linkage.html#inline-function",
    "href": "c6_scope_duration_linkage.html#inline-function",
    "title": "7  Scope, duration and linkage",
    "section": "7.12 Inline function",
    "text": "7.12 Inline function\nCodes of called function are expanded in caller. Modern compiler decides this."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#constexpr-and-consteval-functions",
    "href": "c6_scope_duration_linkage.html#constexpr-and-consteval-functions",
    "title": "7  Scope, duration and linkage",
    "section": "7.13 Constexpr and consteval functions",
    "text": "7.13 Constexpr and consteval functions\nA constexpr function: can be evaluated at compile-time. Simply by supplying constexpr keyword in front of the return type.\n\n\nCode\n#include <iostream>\n\nconstexpr int greater(int x, int y)\n{\n    return (x > y ? x : y);\n}\n\nint main()\n{\n    constexpr int x{ 5 };\n    constexpr int y{ 6 };\n\n    constexpr int g{ greater(x, y) };\n\n    std::cout << g << \" is greater!\\n\";\n\n    return 0;\n}\n\n\nTo be a constexpr function, a function has to:\n\nHave a constexpr return type\nDo not have any non-constexpr functions\n\nConstexpr function can be evaluated at runtime."
  },
  {
    "objectID": "c6_scope_duration_linkage.html#chapter-summary",
    "href": "c6_scope_duration_linkage.html#chapter-summary",
    "title": "7  Scope, duration and linkage",
    "section": "7.14 Chapter summary",
    "text": "7.14 Chapter summary\nA compound statement or block is a group of statements is treated as a single statement by compiler."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "9  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever.\nMarkdown allows you to write using an easy-to-read, easy-to-write plain text format.\n\n\nCode\n1 + 1"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "c7_flow_error.html#introduction-to-random-numer-generation",
    "href": "c7_flow_error.html#introduction-to-random-numer-generation",
    "title": "8  Control flow and Error Handling",
    "section": "8.13 Introduction to random numer generation",
    "text": "8.13 Introduction to random numer generation\nComputer are generally incapable of generating truly random numbers. It simulates randomness using an algorithm.\n\nAlgorithms and state\nAlgorithm:\n\nIt is an instruction’s sequence to solve a demand and provide useful results.\nIt is reusable\nIn C++, algorithms are typically implemented as reusable functions.\n\nHere is an example:\n\n\nCode\nint plusOne()\n    {\n        static int s_state{ 3 };\n\n        ++s_state;\n\n        return s_state;\n    }\n\n\nAn algorithm is stateful if it retains some information across calls. A stateless algorithm does not store any information. Our plusOne() is stateful because it creates a static variable that is used through its call.\nThe plusOne() is deterministic: given input, it will always produce the same output.\n\n\nPseudo-random number generators (PRNGs)\nThis is a very simple PRNGs:\n\n\nCode\n#include \"random.h\"\n\nint LCG16()\n{\n    static int s_state{ 5323 };\n    s_state = 8253729 * s_state + 2396403;\n\n    return s_state % 32768;\n}\n\n\nThis function returns the same random sequence.\n\nSeeding a PRNG\nThe sequence of “random number” is not random. It is based on the initial state. The same initial state will generate same output sequence.\nWhen PRNG is instantiated, an initial value called a random seed can be provided to the initial state of the PRNG.\n\n\nWhat makes a good PRNG?\n\nThe PRNG should generate each number with approximately same probability.\nThe method by which the next number in the sequence should be unpredictable.\nIt should represent the distribution of number\nIt should have a high period for all seed\n\nAll PRNG are periodic: the sequence of numbers will repeated itself. The length of sequence before a PRNG begins to repeat itself is known as the period.\n\nIt should be efficient\n\n\n\n\nRandomization in C++\nWe use via <random> header with the following PRNG families:\n\n\n\nPRNG families in C++\n\n\n\n\nGenerating random numbers using Mersenne Twister\nWe use the <ramdon> header. There are two Mersenne Twister types:\n\nmt19937: generates 32-bit unsigned integer\nmt19937_64: generates 64-bit unsigned integer\n\n\n\nCode\n#include <random>\n\nint randomMT()\n{\n    std::mt19937 mt{};\n\n    for (int count{ 1 }; count <= 40; ++count)\n    {\n        std::cout << mt() << '\\t';\n\n        if (count % 5 == 0)\n            std::cout << '\\n';\n    }\n\n    return 0;\n}\n\n\n\nRolling a dice using MT\nWe use the uniform distribution that produces output between two numbers X and Y with equal probability.\nHere is the code:\n\n\nCode\n#include <random>\n#include <iostream>\n\nvoid dice()\n{\n    std::mt19937 mt{};\n\n    std::uniform_int_distribution die6{ 1, 6 };\n\n    for (int count{ 1 }; count <= 40; ++count)\n    {\n        std::cout << die6(mt) << '\\t';\n\n        if (count % 5 == 0)\n            std::cout << '\\n';\n    }\n}\n\n\nThe dice sequence is not random. If we ran many times, we see that it is the same because we initialized our MT so it has the same seed every time the program is run.\nTo deal with this we usually use the seed from:\n\nThe system clock\nThe system’s random device\n\n\n\nSeeding with the system clock\nWe use the system clock to initialize the seed for PRNG. This is from the <chrono> header and the function static_cast<unsigned int>(std::chrono::steady_clock::now().time_since_epoch().count()). Let see the example below:\n\n\nCode\nvoid diceSystemClock()\n{\n    std::mt19937 mt{ static_cast<unsigned int>(\n        std::chrono::steady_clock::now().time_since_epoch().count()\n        ) };\n\n    std::uniform_int_distribution die6{ 1, 6 };\n\n    for (int count{ 1 }; count <= 40; ++count)\n    {\n        std::cout << die6(mt) << '\\t';\n\n        if (count % 10 == 0)\n            std::cout << '\\n';\n    }\n}\n\n\n\n\nSeeding with the random device\nWe use the code std::random_device(). It will ask the OS for a random number. One potential problem is that it it not required to be non-deterministic. But, the lasted version support proper implementation of std::random_device().\n\n\n\n\n\n\nUse std::random_device() to seed PRNGs.\nOnly seed a given PRNG once, do not reseed it.\n\n\n\n\n\nCode\nint getCard()\n{\n    std::mt19937 mt{ std::random_device{}() };\n    std::uniform_int_distribution card{ 1, 52 };\n\n    return card(mt);\n}\n\n\nEverytime we call getCard(), the program creates a new seed. This is inefficient at best and cause poor random results.\n\n\nRandom numbers across multiple functions\nTo use this, we create an std::mt19937 object with std:random_device() in a namespace. This is an exception that we use non-const global variables.\n\n\nCode\n#include <random>\n#include <iostream>\n\nnamespace Random\n{\n    std::mt19937 mt{std::random_device{}()};\n    \n    int get(int min, int max)\n    {\n        std::uniform_int_distribution die{min, max};\n        return die(mt);\n    }\n    \n    \n}"
  },
  {
    "objectID": "c8_implicit_conversion.html#type-conversion",
    "href": "c8_implicit_conversion.html#type-conversion",
    "title": "9  Type conversion and Funcion Overloading",
    "section": "9.1 Type conversion",
    "text": "9.1 Type conversion\nThe compiler coverts from one data type to another data type. This si type conversion. For example, float f{ 3 }.\n\nImplicit type conversion\nThis is also called automatic type conversion or coercion: the compiler coverts implicitly when we require one type of data but different type of data is supplied.\n\n\nCode\n#' covert from int to double\n\n#double fa {3}; \nd = 6;\n\n#' non-Boolean\nif (5)\n{\n    \n}\n\n\nThe compiler will find the how to convert from current data type to the desired data type. If it can find, it will covert. Otherwise, it returns compile error.\n\n\nThe standard conversions\nC++ defines the standard conversion rules:\n\nNumeric promotions: Floating-point and integral promotion\nNumeric conversions\nArithmetic conversions\nOther conversions\n\n\nFloating-point and integral promotion\nFloating-point and integral promotion are two types of numeric promotion. Numeric promotion is the conversion of a narrower numeric type (char) to a wider numeric type (int or double).\nAll numeric promotion are value-preserving and it helps to reduce redundancy.\nFloating-point promotions: value from float to double.\nIntegral promotions:\n\nsigned char or signed short can be converted to int.\nunsigned char, char8_t, and unsigned short can be converted to int if int can hold the entire range of the type, or unsigned int otherwise.\nIf char is signed by default, it follows the signed char conversion rules above. If it is unsigned by default, it follows the unsigned char conversion rules above.\nbool can be converted to int, with false becoming 0 and true becoming 1.\n\n\n\nNumeric conversions\n\nConvert an integral type to any other integral type (excluding integral promotions)\n\n\n\nCode\nshort s = 3; # int to short\nlong l = 3; # int to long\nchar ch = s; # short to char\n\n\n\nConverting a floating point type to any other floating point type\n\n\n\nCode\nfloat f = 3.0;  # convert double to float\nlong double ld = 3.0    # covert double to long double\n\n\n\nConverting a floating point type to any integral type\n\n\n\nCode\nint d = 3.5;\n\n\n\nConverting an integral type to any floating point type\n\n\n\nCode\ndouble d = 3;\n\n\n\nConverting an integral type or a floating point type to a bool\n\n\n\nCode\nbool b1 = 3;     # convert int to bool\nbool b2 = 3.0;   # convert double to bool\n\n\nNumeric conversion sometimes causes the loss of data (from floating type to int, from wider type to narrower type,…).\nIf we want the conversion, it is better to explicit by using static_cast<type>(var).\nNarrowing conversion does not allow to use brace initialization\n\n\nCode\nint main()\n{\n    int i {3.5};    # won't be compile\n}\n\n\n\n\nArithmetic conversion\nWhat type of the following:\n\nint x{2 + 3}: both operands are int, so it is int\n??? y{2 + 3.5}: one is int and one in floating type. So, compiler use usual arithmetic conversions\n\n\nThe usual arithmetic conversion rules\nThe compiler has a prioritized list of types:\n\nlong double (highest)\ndouble\nfloat\nunsigned long long\nlong long\nlong\nunsigned int\nint (lowest)\n\nThere are two rules:\n\nIf the type of at least one of the operands is on the priority list, the operand with lower priority is converted to the type of the higher\nOtherwise, both operands use numeric promotions\n\n\n\nCode\n    int i{ 2 };\n    double d{ 3.5 };\n    std::cout << typeid(i + d).name() << ' ' << i + d << '\\n';\n\n    short a{ 4 };\n    short b{ 5 };\n    std::cout << typeid(a + b).name() << ' ' << a + b << '\\n';\n\n\nAvoid using unsigned integer.\n\n\n\n\nExplicit type conversion\nWhen we want to covert from one type to wider type, implicit type conversion is fine.\nIn the case the like double d = 10 / 4 will give the result is 2.0. We can change like this double d = 10.0 / 4.0, but if we have\n\n\nCode\nint x{10};\nint y{4};\n\ndouble d = x / y;\n\n\nHow do we tell the compiler to use floating type instead of integer. In C++, we use type casting operators to request it. This is usually called explicit type conversion.\n\nType casting\n\nC-style cast\nIn C programming, cast are done via ()operator, with name of type to convert the value placed inside the parentheses\n\n\nCode\n#|label: c-style\n\nint main()\n{\n    int x {10};\n    int y {4};\n    \n    double d { (double)x / y};  #convert x to double\n}\n\n\nBut c-style cast can create some risk: it includes static cast, const cast, and reinterpret cast. Thus, avoid using C-style cast.\n\n\nstatic_cast\nWe should use this to convert a value from one type to another type.\nUse static_cast to make the narrowing conversions explicit.\n\n\n\n\nTypedefs and type aliases\nHere is an example of type aliases:\n\n\nCode\nusing Distance = double;\nDistance mile{3.0};\n\n## Using fo legibility\n\nint gradeTest();\n### Or\nusing TestScore = int;\nTestScore gradeTest();\n\n## For easier code maintenance\n\nUsing StudentID = short\n## Then, we want to change\nusing StudentID = long\n\n\nType aliases should be used if there is clear benefit to code readability and code maintenance.\n\n\nType deduction for object using the auto keyword\nType deduction allows the compiler to deduce the object’s type basing on its initializer. We use the code auto:\n\n\nCode\nauto d{ 5.0 };\nauto i{ 1 + 2 };\nauto x{ i };\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\nint main()\n{\n    auto sum{ add(5, 6) }; # add() returns an int, so sum's type will be deduced to int\n\n    return 0;\n}\n\n#> Type deduction drop the `const`\n\n    const int x { 5 };  # x has type const int\n    auto y { x };       # y will be type int (const is dropped)\n\n    const auto z { x }; # z will be type const int (const is reapplied)\n    \n#!!! Attention to string types\n    \n    const int x { 5 };  // x has type const int\n    auto y { x };       // y will be type int (const is dropped)\n\n    const auto z { x }; // z will be type const int (const is reapplied)\n\n\nType deduction has some advantages:\n\nTwo or more variables are defined in sequential lines\nIt only works on variables that have initializers, so it helps to avoid unintentionally uninitialized variables.\n\nBut, still have some downsides\n\nSomething does not deduce as we expected auto y { 5 }; give int not double.\n\n\n\n\n\n\n\nUse type deduction for your variables, unless you need to commit to a specific type.\n\n\n\n\n\nType deduction for functions\nWe can also use type deduction for function but it requires more concensus:\n\nAll statements return in the body has to return the same type, otherwise, there is error\nFunction has to be defined before its forward declaration\n\n\n\n\n\n\n\nFavor explicit return types for function over return type deduction for normal functions.\n\n\n\n\n\n\n\n\n\nType deduction cannot be used for function’s parameters prior to C++20."
  },
  {
    "objectID": "c8_implicit_conversion.html#introduction-to-function-overloading",
    "href": "c8_implicit_conversion.html#introduction-to-function-overloading",
    "title": "9  Type conversion and Funcion Overloading",
    "section": "9.2 Introduction to function overloading",
    "text": "9.2 Introduction to function overloading\nFunction overloading allow us to create multiple functions with the same name, so long as each functions has different parameters types or can be differentiated by the compiler.\nEach function sharing a name is called an overloaded function or overload. For example, we can simply define two add() functions:\n\n\nCode\n#include <typeinfo>\n#include <string_view>\n#include <iostream>\n\nint add(int x, int y)\n{\n    return x + y;\n}\n\ndouble add(double x, double y)\n{\n    return x + y;\n}\n\nint main()\n{\n    \n    return 0;\n}\n\n\n\n\n\n\n\n\nUse function overloading to make your program simpler"
  },
  {
    "objectID": "c8_implicit_conversion.html#function-overload-differentiation",
    "href": "c8_implicit_conversion.html#function-overload-differentiation",
    "title": "9  Type conversion and Funcion Overloading",
    "section": "9.3 Function overload differentiation",
    "text": "9.3 Function overload differentiation\nIn this section, we learn how the compiler differentiates overloaded functions.\n\n\n\nHow overloaded functions are differentiated\n\n\nA function’s signature is defined as the part of the function including function’s name, parameter’s parameter, parameter’s types, and function-level qualifiers. Not return type.\n\nFunction overload resolution and ambiguous matches\nHow to match a function call for overloaded functions? The compiler has to find the best match, this is overload resolution.\nThe compiler applies a bunch of different type conversions to the arguments, then checks if any of the overloads match. There are three possibilities:\n1. No matching functions were found. Move to the next steps in the sequence\n2. A single matching functions was found. The matching process is complete, no further steps.\n3. More than one matching functions. The compiler return error.\n\nThe argument matching sequence\n\nTry to find an exact match\nIf not, apply trivial conversions: non-const type to const-type\nIf not, apply numeric promotion\nIf not, apply numeric conversion\nIf not, find user-defined type\nIf not, give up and error.\n\n\n\nAmbiguous match\nOne or more overloads are possible to match"
  },
  {
    "objectID": "c8_implicit_conversion.html#default-arguments",
    "href": "c8_implicit_conversion.html#default-arguments",
    "title": "9  Type conversion and Funcion Overloading",
    "section": "9.4 Default arguments",
    "text": "9.4 Default arguments\nA default argument is a default value provided for a function parameter.\n\n\nCode\nvoid print(int x, int y = 10)\n{\n    std::cout << \"x: \" << x << '\\n';\n    std::cout << \"y: \" << y << '\\n';\n}\n\n\nThere are some rules\n\nDefault argument can only be supplied for the rightmost parameters.\n\n\n\nCode\nvoid print(int x=10, int y); # not allowed\n\n\n\nDefault argument can not be re-declared\n\n\n\nCode\n#include <iostream>\n\nvoid print(int x, int y=4); // forward declaration\n\nvoid print(int x, int y=4) // error: redefinition of default argument\n{\n    std::cout << \"x: \" << x << '\\n';\n    std::cout << \"y: \" << y << '\\n';\n}\n\n\n\nBest practice is to declare default argument in forward declaration, not in function definition.\nCan be use in overloaded functions:\n\n\n\nCode\nvoid print(int x);\nvoid print(int x, int y = 10);\nvoid print(int x, double y = 20.5);\n\nprint(1, 2);        # will resolve to print(int, int)\nprint(1, 2.5);      # will resolve to print(int, double)\nprint(1);           # ambiguous function call"
  },
  {
    "objectID": "c8_implicit_conversion.html#function-template",
    "href": "c8_implicit_conversion.html#function-template",
    "title": "9  Type conversion and Funcion Overloading",
    "section": "9.5 Function template",
    "text": "9.5 Function template\n\n\n\n\n\n\nProblems:\n\n\n\nHow can we write a function max(x, y) to find the greater value between two variables and this function applies to type int, double, long int, long double so that we do not need to have overloaded function?\n\n\nWelcome to the world of C++ templates!\n\nIntroduction to C++ templates\nWe create a template to describe how a function or a class looks like. In the template, we have placeholders represents some unknown types that is replaced later.\nThen, compiler uses defined template to generate the overloads (or classes) using different actual types.\nTemplates work with types did not even exist when the template was written, thus it is flexible and future proof.\n\n\nFunction templates\nFunction template is a function-like definition to generate overloaded functions.\nWe use placeholder types (type template parameters) for any parameter types, return types or types in the functio body.\nWe create a template function max as an example:\n\n\nCode\ntemplate <typename T>\nT max(T x, T y)\n{\n    return (x < y) ? y / x;\n}\n\n\nCreating a function from template function is function template instantiation\nWe can also use deduction for calling a template function.\nThere are also template parameters and non-template parameters in template function.\n\n\n\n\n\n\nWe place templates in the header file to use in multiple fine by #include. This allow the compiler to see full template function and instantiate.\nUse function templates to write generic code that can work with a wide variety of types whenever you have the need.\n\n\n\n\n\nFunction templates with multiple template types\nIn one template type parameters, why does the compiler use numeric conversion for two types?\nAnswer: type conversion is only when resolving function overloads, not performing template argument deduction.\nHere is an example:\n\n\nCode\n#include <iostream>\n\ntemplate <typename T, typename U>   // multiple template types\nauto max(T x, U y)      // auto for deduction the return type.\n{\n    return (x < y) ? y : x;\n}\n\nint main()\n{\n    std::cout << max<int>(2, 3) << '\\n';\n    std::cout << max<double>(2, 3) << '\\n';\n    std::cout << max(2, 3) << '\\n';\n    std::cout << max(2, 3.5) << '\\n';\n\n    return 0;\n}\n\n\nFrom C++20:\n\n\nCode\nauto maxAuto(auto x, auto y)\n{\n    return (x < y) ? y : x;\n}\n\n\nPlease read this Chapter’s summary Here."
  },
  {
    "objectID": "c9_intro_compound_data.html#compound-data-types",
    "href": "c9_intro_compound_data.html#compound-data-types",
    "title": "10  Introduction to compound data types",
    "section": "10.1 Compound data types",
    "text": "10.1 Compound data types\nThey are constructed from fundamental data types. Each of them has its own unique properties. In the following sessions, we will learn many compound data types."
  },
  {
    "objectID": "c9_intro_compound_data.html#value-categories-lvalues-and-rvalues",
    "href": "c9_intro_compound_data.html#value-categories-lvalues-and-rvalues",
    "title": "10  Introduction to compound data types",
    "section": "10.2 Value categories (lvalues and rvalues)",
    "text": "10.2 Value categories (lvalues and rvalues)\nAll expressions in C++ have a type and a value category.\nType: Compiler will see whether the expression’s type is valid in a given context.\nValue category of an expression indicates whether an expression resolves to a value, a function, or an object of some kind.\nThere are two value categories: lvalue and rvalue.\n\nlvalue is an expression that evaluates to an identifiable object or function\n\n\n\nCode\n#int x{5};\n#int y{x};   # x is modifiable lvalue expression\n\nconst double d{};\nconst double e{d};  # d is non-modifiable lvalue expr\n\n\n\nrvalue is expression that is not lvalue such as literals, return of functions or operators.\n\nFrom this we can understand why x = 5 is valid, but not 5 = x. =assignment requires the left operand is modifiable lvalue and right operand is rvalue.\n\n\n\n\n\n\nlvalue can be implicitly converted to rvalue. Thus, x = y or x = x + 1 are valid."
  },
  {
    "objectID": "c9_intro_compound_data.html#lvalue-reference",
    "href": "c9_intro_compound_data.html#lvalue-reference",
    "title": "10  Introduction to compound data types",
    "section": "10.3 lvalue reference",
    "text": "10.3 lvalue reference\nIn C++, reference is an alias to an object. We can modify the object that are referenced (called referent) through its alias.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    int& ref{ x };      # We use (&) to define reference to x\n\n    return 0;\n}\n\n\nIn the above code, ref is bound to x.\n\n\n\n\n\n\nWe cannot bind lvalue reference to non-modifiable lvalue. We need the const reference in preceding session.\nThe type of reference must match the type of the referent.\nReferences are not objects in C++.\nReferences cannot be reseated to other lvalue."
  },
  {
    "objectID": "c9_intro_compound_data.html#lvalue-reference-to-const",
    "href": "c9_intro_compound_data.html#lvalue-reference-to-const",
    "title": "10  Introduction to compound data types",
    "section": "10.4 Lvalue reference to const",
    "text": "10.4 Lvalue reference to const\nWe can do this by const int& ref{x}. ref binds to non-modifiable lvalue const int x. ref can access its referent, but cannot modify the value being referenced:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    const int x{ 5 };\n    const int& ref{ x };\n\n    std::cout << ref << '\\n';\n    ref = 6;    #!!! Error: cannot assign to const lvalue ref\n\n    return 0;\n}\n\n\nVariable x does not need to be const to have const reference\n\n\nCode\nint main()\n{\n    int x{ 5 };\n    const int& ref{ x };\n\n    std::cout << ref << '\\n';\n    //ref = 6; error\n\n    x = 6;\n    std::cout << ref << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nFavor lvalue references to const over lvalue references to non-const\n\n\n\nWith lvalue reference to const, we can bind to rvalue too: const int& ref{ 5 };.\nThe program creates a temporary object1 as a referent. However, lifetime of temporary object extends to the lifetime of its references."
  },
  {
    "objectID": "c9_intro_compound_data.html#pass-by-lvalue-reference",
    "href": "c9_intro_compound_data.html#pass-by-lvalue-reference",
    "title": "10  Introduction to compound data types",
    "section": "10.5 Pass by lvalue reference",
    "text": "10.5 Pass by lvalue reference\nWhy does C++ allow to bind to rvalue object ?\nIn function, when we pass by value to parameters, C++ copies argument’s value to the function to use and destroys at the end of called function. Sometimes, it is not efficient for other data types.\nTo avoid this, C++ uses pass by reference instead of pass by value. To do that, we declare functions’ parameters as a reference type rather than a normal type.\n\n\nCode\n#include <iostream>\n#include <string>\n\nvoid printValue(std::string& y)\n{\n    std::cout << y << '\\n';\n}\n\nint main()\n{\n    std::string x{ \"Hello world!\" };\n    printValue(x);  // x is now passed by reference into reference parameter y\n\n    return 0;\n}\n\n\n\n\n\n\n\n\npass by reference to non-const allows us to write functions that modify value of arguments passed in\n\n\n\nWe use const reference to avoid this. And const reference can refer to modifiable lvalue, non-modifiable lvalue and rvalue too.\n\n\n\n\n\n\nFunction with multiple parameters can have both pass by value and pass by reference\nFor fundamental types, pass by value\nFor class types, pass by reference\n\n\n\n\nThe cost of pass by value vs pass by reference\nWhy do not we always use pass by reference?\nFirst, cost of copying an object depends on:\n\nThe size of object\nAdditional set up\n\nIn this view, pass by reference is faster.\nSecond, assessing an object through a reference is slightly more expensive than a normal variable identifier. In this view, pass by value is better."
  },
  {
    "objectID": "c9_intro_compound_data.html#introduction-to-pointer",
    "href": "c9_intro_compound_data.html#introduction-to-pointer",
    "title": "10  Introduction to compound data types",
    "section": "10.6 Introduction to pointer",
    "text": "10.6 Introduction to pointer\n\nPointers are one of C++’s historical boogeymen.\n\n— Alex\n\n\nWhen we define a variable, RAM assigns a piece of memory to this object. For example, define char x{}, and then RAM allocate it to address 140. Anytime, we call x, RAM will go to 140 to extract its value.\nThis is true with reference too.\n\n\nCode\nint main()\n{\n    char x{};\n    char& ref{x};\n    \n    return 0;\n}\n\n\nAnytime we call ref, the program goes to the memory address 140.\n\nThe address-of operator (&)\nThe address-of operator (&) returns the memory address of operand.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    std::cout << x << '\\n';\n    std::cout << &x << '\\n';\n\n    return 0;\n}\n\n\nThe dereference operator (*) returns the value at a given memory address as an lvalue.\n\n\nCode\nstd::cout << *(&x) << '\\n';\n\n\n\n\nPointers\nA pointer is an object that holds a memory address (typically of another variable) as its value.\nLike reference to lvalue uses (&), the pointer use an asterisk *:\n\n\nCode\nint* ptr;\n\n\nLike normal variable, pointers are not initialized by default. If not initialized, we call it wild pointer. We should always initialize pointers to a known value.\n\n\nCode\nint x{ 5 };\nint& ref{ x };\nint* ptr;           # wild pointer\nint* ptr2{};        # null pointer\nint* ptr3{ &x };    # a pointer bind to address of x\n\n\n\n\n\n\n\n\n\n“X pointer” is a short hand for “pointer to an X”.\n\n\n\n\nMuck like a reference, type of reference has to match type of object referred, type of pointer has to match the type of the object of being pointed to.\nInitializing a pointer with a literal value is disallowed.\n\n\nPointer and assignment\nWe use assignment to change the pointer points to address of other object:\n\n\nCode\nint main()\n{\n    int x{ 5 };\n    int* ptr{ &x };\n\n    std::cout << *ptr << '\\n';\n\n    int y{ 10 };\n    ptr = &y;\n    std::cout << *ptr << '\\n';\n\n    return 0;\n}\n\n\nWe use the assignment to change the value of object that a pointer is pointing to\n\n\nPointer and reference\nPointer and reference has some similarly. But they are different:\n\nFor pointer, we must use address-of and dereference explicitly. They are implicit for reference\nReference must be initialized, pointer are not required (risk of undefined behaviors)\nReference is not an object, pointer is an object\nReference cannot be reseated, pointer can be reseated\nReferences must always be bound to an object, point can point to nothing (null pointer)\nReferences are safe, pointers are inherently dangerous.\n\nThe address-of operator returns a pointer, not as a literal.\nThe size of pointers are the same regardless of size of object being pointed to\n\n\nDangling pointers\nLike dangling reference, dangling pointer is a pointer that is holding the address of an object that is no longer valid.\n\n\nConclusion\nPointers are both more flexible than references and more dangerous."
  },
  {
    "objectID": "c9_intro_compound_data.html#null-pointers",
    "href": "c9_intro_compound_data.html#null-pointers",
    "title": "10  Introduction to compound data types",
    "section": "10.7 Null pointers",
    "text": "10.7 Null pointers\nNull pointers point to nothing; it holds null value. We can assign null pointer to an object.\n\n\nCode\nint* ptr0{};            // null pointer\nptr0 = &x;             // null pointers point to an object\n\n\nIn C++, we use nullptr to initialize, assign, pass null pointer to pointer or function.\nDereferencing a null pointer may lead to undefined behavior or crash the program.\n\n\n\n\n\n\nWhenever we use a pointer, we must guarantee that there does not have any dereferencing null or dangling pointers.\n\n\n\nWe can use the if statement to test whether a pointer is null or not.\n\n\n\n\n\n\nAny pointer should either hold a valid object’s address or be set to nullptr. Thus, we can test for the pointer’s nullity and assume any non-null pointer is valid.\n\n\n\nWe should favor references over pointers unless the additional capabilities provided by pointer are needed.\nThe code for this session\n\n\nCode\n#include <iostream>\n#include <typeinfo>\n\nint main()\n{\n    int x{ 5 };\n    int* ptr0{ nullptr };// null pointer\n    int* ptr{ &x };\n\n    if (ptr == nullptr)\n    {\n        std::cout << \"ptr is null\\n\";\n    }\n    else\n    {\n        std::cout << \"ptr is non-null\\n\";\n    }\n\n    ptr0 = &x;             // null pointers point to an object\n    ptr = nullptr;\n\n    std::cout << typeid(&x).name() << '\\n';\n    std::cout << ptr << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "c9_intro_compound_data.html#pointer-and-const",
    "href": "c9_intro_compound_data.html#pointer-and-const",
    "title": "10  Introduction to compound data types",
    "section": "10.8 Pointer and const",
    "text": "10.8 Pointer and const\nA normal pointer cannot point to a const object, we need a pointer to a const value by adding const at the start of pointer’s definition.\n\n\nCode\nconst int x{5};\nconst int* ptr{ &x };   # we use the pointer to const, but it is not const itself\n\n\nFrom its definition, ptr point to const x. That pointer cannot change the value of x through assignment, but it can pointer to other object (either const or not-const). Thus, pointer is not constant itself but it cannot change the value of object pointed.\nTo create a constant pointer that it cannot point to other object, we use the code int* const ptr{ &y }. Thus, the const pointer cannot point to other object, but it can change object’s value.\nFinally, we can define const pointer to const value by using two const before the type and after the asterisk.\nLet look at the following code as a summary this session\n\n\nCode\n#include <iostream>\n#include <typeinfo>\n\nint main()\n{\n    const int x{ 5 };\n\n    //int* ptr{ &x };               # compile error: cannot initialize with const\n    const int* ptr{ &x };          # we use the pointer to const, but it is not const itself\n\n    //*ptr = 6;                  # error: cannot change value of const var\n    \n    int y{ 7 };\n    ptr = &y;                 # can change the address to point to\n\n    const int* ptr2{ &y };  # const pointer to a non-const var\n    //*ptr2 = 6;           # not allowed\n    y = 6;                # ok\n\n    int z{ 10 };\n    int* const ptr3{ &y };           # const pointer    \n\n    ptr3 = &z;                      # const pointer cannot pointer to other object\n    *ptr3 = 500;\n\n    const int* const ptr4{ &x };      # const pointer to const value\n\n    return 0;\n}"
  },
  {
    "objectID": "c9_intro_compound_data.html#pass-by-address",
    "href": "c9_intro_compound_data.html#pass-by-address",
    "title": "10  Introduction to compound data types",
    "section": "10.9 Pass by address",
    "text": "10.9 Pass by address\nWe start by looking at the following code:\n\n\nCode\n#label: print-function\n\n#include <iostream>\n#include <string>\n\n# Function use pass by value\nvoid printValue(std::string val)\n{\n    std::cout << val << '\\n';\n}\n\n# Function use pass by reference\nvoid printByReference( const std::string& ref)\n{\n    std::cout << ref << '\\n';\n}\n\nint main()\n{\n    std::string val{ \"Hello world!\" };\n\n    printValue(val);            # it copies the val's value to pass to called function\n    printByReference(val);     # it does not copies, make a reference to function\n\n    return 0;\n}\n\n\nWe learned about pass by value and pass by reference. Let recall where we use either of them.\nWe now also use pass by address as follow code:\n\n\nCode\nvoid changeValue(int* ptr)\n{\n    *ptr = 6;\n}\n\nint main()\n{\n    std::string val{ \"Hello world!\" };\n\n    printValue(val);    # it copies the val's value to pass to called function\n    printByReference(val);     # it does not copy, make a reference to function\n    printByAddress(&val);     # pass by address, does not copy val\n\n    return 0;\n}\n\n\nWe can modify the object’s value through pass by address\n\n\nCode\nvoid changeValue(int* ptr)\n{\n    *ptr = 6;\n}\n\n\nMake sure not to pass null pointer. We can test and handle it\n\n\nCode\nvoid print(int* ptr)\n{\n    assert(ptr && \"Pointer must be not null\");\n    \n    if (!ptr)   // if ptr is null pointer, return\n    {\n        return;\n    }\n\n    std::cout << *ptr << '\\n';\n}\n\n\nPass by address can only use for lvalue, not for rvalue. Pass by const reference can use for both and avoids the null problem.\n\n\n\n\n\n\nFavor pass by reference over pass by address."
  },
  {
    "objectID": "c9_intro_compound_data.html#pass-by-address-2",
    "href": "c9_intro_compound_data.html#pass-by-address-2",
    "title": "10  Introduction to compound data types",
    "section": "10.10 Pass by address 2",
    "text": "10.10 Pass by address 2\nPass by address can use for default (optional) arguments. But sometimes, we can use the overloaded functions.\n\nChanging what a pointer parameter points at\nPass by address copies the address to the parameters, so we change the pointing in the function does not change the pointing of pointer outside function.\nTo do this, we pass pointer by reference to the parameter.\n\n\nCode\nvoid printByReference( const std::string*& ref)\n{\n    std::cout << ref << '\\n';\n}\n\n\n\n\nThere is only pass by value\nCompiler implement pass by reference by using pointers. Behind the scenes, pass by reference is just pass by address with implicit dereference.\nWhen pass by address make a copies of address from caller to the called function, it is also an type of pass by value.\nWe conclude that C++ really passes everything by value!"
  },
  {
    "objectID": "c9_intro_compound_data.html#return-by-reference-and-return-by-address",
    "href": "c9_intro_compound_data.html#return-by-reference-and-return-by-address",
    "title": "10  Introduction to compound data types",
    "section": "10.11 Return by reference and return by address",
    "text": "10.11 Return by reference and return by address\nCompiler copies function’s return to pass back to caller. This sometimes expensive.\n\nReturn by reference\nWe may use return by reference to avoid this. Return by reference returns a reference that is bound to object being returned. Here is an example:\n\n\nCode\n#include <iostream>\n#include <string>\n\nconst std::string& getProgramName()\n{\n    static const std::string s_programName{ \"Calculator\" };\n    \n    return s_programName;\n}\n\nint main()\n{\n    std::cout << \"Program's name is \" << getProgramName() << '\\n';\n\n    return 0;\n}\n\n\ngetProgramName() return a const reference. When the return is executed, getProgramme() return a const reference to s_programName.\nThe object returned by reference must exit after the function returns. We cannot use the local variable for return by reference.\nAvoid returning references to non-const local static variables. The code below shows the problem:\n\n\nCode\nconst int& getId()\n{\n    static int id{ 0 };\n    ++id;\n\n    return id;\n}\n\nint main()\n{\n    //std::cout << \"Program's name is \" << getProgramName() << '\\n';\n\n    const int& id1{ getId() };\n    const int& id2{ getId() };\n\n    std::cout << id1 << id2 << '\\n';\n\n    return 0;\n}\n\n#>22\n\n\nTwo ids value are the same because we generate non-const static variable.\nWhen we assign or initialize a normal variable by a return by reference function, compiler makes a copies of the value return by reference:\n\n\nCode\nconst int& getId()\n{\n    static int id{ 0 };\n    ++id;\n\n    return id;\n}\n\nint main()\n{\n    //std::cout << \"Program's name is \" << getProgramName() << '\\n';\n\n    const int id1{ getId() };  #id1 and id2 are normal variable\n    const int id2{ getId() };\n\n    std::cout << id1 << id2 << '\\n';\n\n    return 0;\n}\n\n#>12\n\n\nNotice that the reference is left dangling before the copy is made.\nIt is fine to return reference parameters by reference\n\n\nCode\nconst std::string& firstAlphabetical(const std::string& a, const std::string& b)\n{\n    return (a < b ? a : b);\n}\n\nint main()\n{\n    const std::string a{ \"Hello\" };\n    const std::string b{ \"World\" };\n\n    std::cout << firstAlphabetical(a, b) << '\\n';\n\n    return 0;\n}\n\n\nThe caller can modify the return by reference for non-const reference.\n\n\nCode\nint& max(int& x, int& y)\n{\n    return (x > y ? x : y);\n}\n\n\nint main()\n{\n    int a{ 100 };\n    int b{ 200 };\n\n    max(a, b) = 1;\n\n    std::cout << b << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "c9_intro_compound_data.html#type-deduction-with-pointers-references-and-const",
    "href": "c9_intro_compound_data.html#type-deduction-with-pointers-references-and-const",
    "title": "10  Introduction to compound data types",
    "section": "10.12 Type deduction with pointers, references, and const",
    "text": "10.12 Type deduction with pointers, references, and const\nRecall about type deduction for object and function by using auto. Remember that auto remove const, if we want to keep it, then use const auto. Let look at the code:\n\n\nCode\n#include <iostream>\n\nint getVal()\n{\n    return 1;\n}\n\nconst double foo()\n{\n    return 5.6;\n}\n\nint main()\n{\n    auto val{ getVal() };   # val deduced as type int\n\n    auto x{ foo() };        # double, dropped const\n    const auto y{ foo() }; # const double\n\n    return 0;\n}\n\n\nType deduction also drops reference, thus we need to add again to the definition:\n\n\nCode\nstd::string& getRef()\n{\n    static std::string s_getString{ \"Hello\" };\n\n    return s_getString;\n}\n\nint main()\n{\n    auto ref1{ getRef() };  # std::string, dropped reference\n    auto& ref2{ getRef() }; # std::string&\n\n    return 0;\n}\n\n\n\nTop-level const and low-level const\nA top-level const is a const qualifier that applies to an object itself:\n\n\nCode\nconst int x{};  # this const applies directly to x\nint* const ptr{}; # this const applies directly to ptr\n\n\nA low-level const is a const qualifier that applies to the object being referenced or pointed to:\n\n\nCode\nconst int& ref{x};  # this const applies to the object being referenced\nconst int* ptr{};   # this const applies to the oject being pointed to\n\n\nA reference is not an object, so there are no top-level- const for reference.\nPointer may have both top and low level const\n\n\nCode\nconst int* const ptr{};\n\n\nType deduction only drops top-level const.\nIf the initializer is a reference to const, the reference is dropped first, and then any top-level const is dropped from the result:\n\n\nCode\nconst std::string& getRef()\n{\n    static const std::string s_getString{ \"Hello\" };\n\n    return s_getString;\n}\n\nint main()\n{\n    auto ref1{ getRef() };      # std::string: dropped reference, then dropped const\n    const auto ref2{ getRef() }; # const std::string: dropped reference\n\n    auto& ref3{ getRef() };     # const std::string&\n    const auto& ref4{ getRef() }; # const std::string&\n\n    return 0;\n}\n\n\n\n\nType deduction and pointers\nUnlike reference, type deduction does not drop pointer, thus the two codes below have the same results:\n\n\nCode\n#include <iostream>\n#include <string>\n\nstd::string* getPtr(std::string* str)\n{ \n    return str;\n}\n\nint main()\n{\n    std::string str{ \"Hello\" };\n\n    auto ptr3{ getPtr(&str) };  # std::string*\n    auto* ptr4{ getPtr(&str) }; # std::string*\n\n    std::cout << *ptr3  << ' ' << *ptr4 << '\\n';\n\n    return 0;\n}\n\n\nBut there are difference betwwen auto and auto*\n\nauto deduces including pointer\nauto* deduces not including pointer, and then reapplied the pointer.\nauto* must resolve to a pointer initialzer, otherwise, there is error\n\n\n\nCode\nauto* ptr4{ *getPtr() };     # does not compile (initializer not a pointer)\n\n\nWe can see the following code:\n\n\nCode\nstd::string* getPtr(); # some function that returns a pointer\n\nint main()\n{\n    const auto ptr1{ getPtr() };  # std::string* const\n    auto const ptr2 { getPtr() }; # std::string* const\n\n    const auto* ptr3{ getPtr() }; # const std::string*\n    auto* const ptr4{ getPtr() }; # std::string* const\n\n    return 0;\n}\n\n\nAnd a more complicated one:\n\n\nCode\n#include <string>\n\nconst std::string* const getConstPtr(); # some function that returns a const pointer to a const value\n\nint main()\n{\n    auto ptr1{ getConstPtr() };  # const std::string*\n    auto* ptr2{ getConstPtr() }; # const std::string*\n\n    auto const ptr3{ getConstPtr() };  # const std::string* const\n    const auto ptr4{ getConstPtr() };  # const std::string* const\n\n    auto* const ptr5{ getConstPtr() }; # const std::string* const\n    const auto* ptr6{ getConstPtr() }; # const std::string*\n\n    const auto const ptr7{ getConstPtr() };  # error: const qualifer can not be applied twice\n    const auto* const ptr8{ getConstPtr() }; # const std::string* const\n\n    return 0;\n}\n\n\nPlease read the Chapter’s summary here."
  },
  {
    "objectID": "c10_enums_structs.html#introduction-to-program-defined-user-defined-types",
    "href": "c10_enums_structs.html#introduction-to-program-defined-user-defined-types",
    "title": "11  Compound Types: Enums and Structs",
    "section": "11.1 Introduction to program-defined (user-defined) types",
    "text": "11.1 Introduction to program-defined (user-defined) types\nWe create directly the fundamental types such as int, double and bool. This is true for compound types extended from fundamentals types: functions, pointers, references, and arrays)\n\n\nCode\nint x;\ndouble y;\n\nvoid fcn(int)   # function type void()(int)\nint* ptr;\nint& ref;\nint arr[5];     # an array of 5 int\n\n\nWe also have type alias be defined through using. If we do not define it before using it, compiler will return error:\n\n\nCode\nusing length = int;\n\nint main()\n{\n    length x{5};\n    std::cout << x << '\\n';\n    \n    return 0;\n}\n\n\n:::\nWhat will happen if we need a compound type that does not exit in C++ like fraction type?\n:::\nC++ allows us to create entirely new, custom types for use in our programs. We call it: program-defined types or user-defined types.\nProgram-defined types must be defined before they are used. This definition is type definition.\nThis is an example to define a new type named Fraction:\n\n\nCode\nstruct Fraction {\n    int numerator{};\n    int numerator{};\n};\n\nint main() {\n    \n    Fraction f{ 3, 4 };\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nAlways end the program-defined type definitions by a semicolon. If not, there will be an error.\n\n\n\n\n\n\n\n\n\n\nName your program-defined types starting with a capital letter and do not use a suffix.\nA program-defined type used in only one code file should be defined in that code file as close to the first point of use as possible.\nA program-defined type used in multiple code files should be defined in a header file with the same name as the program-defined type and then #included into each code file as needed.\n\n\n\n\nProgram-defined type are partially exempt from the one-definition rule. Because the compiler needs to know the whole definition of type, forward declaration is not enough."
  },
  {
    "objectID": "c10_enums_structs.html#enumerations",
    "href": "c10_enums_structs.html#enumerations",
    "title": "11  Compound Types: Enums and Structs",
    "section": "11.2 Enumerations",
    "text": "11.2 Enumerations\nAn enumeration (enumarated type or enum) is a compound data type, program-defined type where every possible value is defined as a symbolic constant (enumerator).\nC++ supports two kinds of enumerations: unscoped enumerations and scoped enumerations."
  },
  {
    "objectID": "c10_enums_structs.html#unscoped-enumerations",
    "href": "c10_enums_structs.html#unscoped-enumerations",
    "title": "11  Compound Types: Enums and Structs",
    "section": "11.3 Unscoped enumerations",
    "text": "11.3 Unscoped enumerations\nThis is defined via the enum keyword. Let learn from the code:\n\n\nCode\nenum Color\n{\n    // Here are enumerators\n\n    red,\n    green,\n    blue,\n};\n\nint main() {\n    \n    Color apple{ red };\n    Color shirt{ green };\n    Color cup{ blue };\n\n\n    return 0;\n}\n\n\nOur enum should start with a capital letter.\nEach enum types are distinct types. Thus, enumerators defined as part of one enumerated type cannot be used with object of another enummerated type\nEnumerated types are best used when we have a smallish set of related constants.\nEnumerators exist in the scope creating the enumeration. For example, enum Color defined in global scope, thus all the name red, green, and blue are defined in global scope. This sometimes invoke the name collision if there are enumerators with same name but in different enum.\nTo deal with this we can:\n\nUse Color::green\nOr put the enum Color in a namespace (preferred)\n\n\n\nCode\nnamespace color\n{\n    enum Color{\n        red,\n        green, \n        blue,\n    };\n}"
  },
  {
    "objectID": "c10_enums_structs.html#unscoped-enumeration-input-and-output",
    "href": "c10_enums_structs.html#unscoped-enumeration-input-and-output",
    "title": "11  Compound Types: Enums and Structs",
    "section": "11.4 Unscoped enumeration input and output",
    "text": "11.4 Unscoped enumeration input and output\nEach enumerator is assigned by computer or by programmer an integral.\n\n\nCode\nenum Color\n{\n        red, # = 1\n        green, # = 2\n        blue, # 3\n};\n\n# we can assigne number too\n\nenum Color\n{\n        red, # = 1\n        green, # = 2\n        blue = 5,\n};\n\n\nBecause the unscoped enumeration implicitly converses to integer and the std::cout<< does not know how to print our define type, program prints unscoped enumration as integer, not its enumerators.\n\n\nCode\n#include <iostream>\n\nenum Color\n{\n    black, \n    red,\n    blue,\n    green,\n    white,\n    cyan,\n    yellow,\n    magenta,\n};\n\nint main()\n{\n    Color shirt{ blue };\n    \n    std::cout << \"Your shirt is \" << shirt << '\\n';\n\n    return 0;\n}\n\n#> Your shirt is 2\n\n\nTO solve this problem, we can create a function to get enumerators and assign it to string to print out:\n\n\nCode\n#include <iostream>\n\nenum Color\n{\n    black, \n    red,\n    blue,\n    green,\n    white,\n    cyan,\n    yellow,\n    magenta,\n};\n\n#' We create a function helping to print:\nconst std::string_view getColor(Color& color)   # C++17\n{\n    switch (color)\n    {\n    case black:\n        return \"black\";\n    case red:\n        return \"red\";\n    case green:\n        return \"green\";\n    default:\n        return \"???\";\n    }\n}\n\nint main()\n{\n    Color shirt{ blue };\n    \n    std::cout << \"Your shirt is \" << shirt << '\\n';\n\n    return 0;\n}\n\n\nThe other code we can do it to use std::ostream:\n\n\nCode\n#label: teach-operator>>\n\nstd::ostream& operator<<(std::ostream& out, Color color)\n{\n    switch (color)\n    {\n    case black: \n        out << \"black\";\n        break;\n    case red:\n        out << \"red\";\n        break;\n    case blue:\n        out << \"blue\";\n        break;\n    default:\n        out << \"???\";\n        break;\n    }\n\n    return out;\n}\n\n\nThis is similar to std::cin: it does not know how to input our defined type. We need a function or an overload to teach it:\n\n\nCode\nstd::istream& operator>>(std::istream& in, Pet& pet)\n{\n    int input{};\n    in >> input;\n\n    pet = static_cast<Pet>(input);\n    \n    return in;\n\n}\n\nstd::ostream& operator<<(std::ostream& out, Pet& pet)\n{\n    switch (pet)\n    {\n    case cat:\n        out << \"cat\";\n        break;\n    case dog:\n        out << \"dog\";\n        break;\n    case pig:\n        out << \"pig\";\n        break;\n    case whale:\n        out << \"whale\";\n        break;\n    }\n\n    return out;\n}\n\n\nint main()\n{\n    std::cout << \"Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): \";\n\n    Pet pet{};\n    std::cin >> pet; // input our pet using std::cin\n\n    std::cout << pet << '\\n'; // prove that it worked\n\n    return 0;\n}"
  },
  {
    "objectID": "c10_enums_structs.html#scope-enumeration-enum-class",
    "href": "c10_enums_structs.html#scope-enumeration-enum-class",
    "title": "11  Compound Types: Enums and Structs",
    "section": "11.5 Scope enumeration (enum class)",
    "text": "11.5 Scope enumeration (enum class)\nWe use enum class for scoped enumeration. There are two differences with unscoped enumeration:\n\nThey are strong type: do not implicitly cover to integer\nThey are strongly scoped: enumerators only place in the scope of its enum\n\nHere is an example code:\n\n\nCode\nenum class Color\n{\n    red,\n    blue,\n};\n\nenum class Fruit\n{\n    banana,\n    fruit,\n};\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    Color color{ Color::red };\n    Fruit fruit{ Fruit::banana };\n\n    if (color == fruit) # Compile error: can in unscope, but error in scoped enum\n        std::cout << \"color and fruit are equal\\n\";\n    else\n        std::cout << \"color and fruit are not equal\\n\";\n}\n\n\n\n\n\n\n\n\nAlthough we use class keyword, scope enum are not a class type (structs, classes, and unions).\n\n\n\nNotice the errors below:\n\n\nCode\n    std::cout << red << '\\n';   # red is not in global scope, it is in Color scope\n    std::cout << Color::red << '\\n'; #operator<< does not know how to print Color type\n\n\nWe can use using enum Define_type inside a function to simplify the codes:\n\n\nCode\nconstexpr std::string_view getColor(Color color)\n{\n    using enum Color;\n\n    switch (color)\n    {\n    case black:\n        return \"black\";\n    case red:\n        return \"red\";\n    case blue:\n        return \"blue\";\n    default:\n        return \"???\";\n    }\n}\n\n\nFinally, learn from exercise:\n\n\nCode\nenum class Animal\n{\n    pig,\n    chicken,\n    goat,\n    cat,\n    dog,\n    duck,\n    snake,\n};\n\nconstexpr std::string_view get_animal_name(Animal animal)\n{\n    using enum Animal;\n\n    switch (animal)\n    {\n    case pig:\n        return \"pig\";\n    case chicken:\n        return \"chicken\";\n    case cat:\n        return \"cat\";\n    case dog:\n        return \"dog\";\n    case duck:\n        return \"duck\";\n    default:\n        std::cerr << \"Error: cannot find the animal.\\n\";\n    }\n}\n\nint print_number_legs(Animal animal)\n{\n    using enum Animal;\n\n    switch (animal)\n    {\n    case pig:\n    case cat:\n    case dog:\n        return 4;\n    case duck:\n    case chicken:\n        return 2;\n    default:\n        std::cerr << \"Error: cannot find the animal.\\n\";\n        std::abort();\n    }\n}\n\nvoid print_number_legs_ref(Animal animal)\n{\n    using enum Animal;\n\n    switch (animal)\n    {\n    case pig:\n    case cat:\n    case dog:\n        std::cout << 4;\n        break;\n    case duck:\n    case chicken:\n        std::cout << 2;\n        break;\n    default:\n        std::cerr << \"Error: cannot find the animal.\\n\";\n        break;\n    }\n\n    std::cout << \" legs.\\n\";\n}\n\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    Color color{ Color::red };\n    Fruit fruit{ Fruit::banana };\n\n    // We can explicitly cover to integer\n    std::cout << static_cast<int>(color) << '\\n';\n\n    //Get animal's name\n\n    Animal animal{ Animal::chicken };\n    std::cout << get_animal_name(Animal::snake) << '\\n';\n    std::cout << \"A \" << get_animal_name(animal) << \" has \" << print_number_legs(animal) << \" legs.\\n\";\n    std::cout << \"A \" << get_animal_name(animal) << \" has \";\n    print_number_legs_ref(animal);\n\n    return 0;\n}"
  },
  {
    "objectID": "c10_enums_structs.html#introduction-to-structs-members-and-member-selection",
    "href": "c10_enums_structs.html#introduction-to-structs-members-and-member-selection",
    "title": "11  Compound Types: Enums and Structs",
    "section": "11.6 Introduction to structs, members, and member selection",
    "text": "11.6 Introduction to structs, members, and member selection\nstruct(structure) is a keyword that group the related variables into one data types. Each variable defined in struct is a member of that struct type.\nWe can use operator. to call each member in the struct and use it as a normal variable for programming.\nHere is an example:\n\n\nCode\n#include <iostream>\n\nstruct Employee\n{\n    int id{};\n    int age{};\n    double wage{};\n};\n\nint main()\n{\n    Employee joe{};\n    joe.id = 14;\n    joe.age = 40;\n    joe.wage = 4000.0;\n\n    Employee frank{};\n    frank.id = 20;\n    frank.age = 30;\n    frank.wage = 3000.0;\n\n    std::cout << \"Joe's earning: \" << joe.wage << '\\n';\n    std::cout << \"Frank's earning: \" << frank.wage << '\\n';\n\n    if (joe.wage > frank.wage)\n        std::cout << \"Joe earns more than Frank.\\n\";\n    else if (joe.wage < frank.wage)\n        std::cout << \"Joe earns less than Frank.\\n\";\n    else\n        \"They have the same wage.\\n\";\n\n    // Frank got promotion\n    ++frank.wage;\n\n    // Today is Joe's birthday\n    ++joe.age;\n\n    return 0;\n}"
  },
  {
    "objectID": "c10_enums_structs.html#struct-aggregate-initialization",
    "href": "c10_enums_structs.html#struct-aggregate-initialization",
    "title": "11  Compound Types: Enums and Structs",
    "section": "11.7 Struct aggregate initialization",
    "text": "11.7 Struct aggregate initialization\nStruct is an aggregate so it uses aggregate initialization by providing the initializer list, a list of valuers separated by comma:\n\n\nCode\nEmployee joe{14, 32, 4000.0};\n\n\nIs some values is missing in initialization, it will be 0.\nValue of a struct type can be const such as const Employee joe{14, 32, 4000.0};\nWe can add new member (variable) in struct, but should be at the bottom to avoid shift the value.\n\nAssignment with an initializer list\nWe can use initializer list to assign values to members:\n\n\nCode\nEmployee joe{14, 32, 4000.0};\n\njoe = {joe.id, 33, 4500.0};\n\njoe = {.id = joe.id, .age = 33, .Wage = 4600.0} # from C++20\n\n\n\n\n\n\n\n\nProvide a default value for all members.\nIf no explicit initializer values will be provided for an aggregate, prefer value initialization (with empty braces initializers) to default initialization( with no braces)."
  },
  {
    "objectID": "c10_enums_structs.html#struct-passing-and-miscellany",
    "href": "c10_enums_structs.html#struct-passing-and-miscellany",
    "title": "11  Compound Types: Enums and Structs",
    "section": "11.8 Struct passing and miscellany",
    "text": "11.8 Struct passing and miscellany\nThe important advantage of struct is pass by reference to struct so that we onmy one variable instead of many member variables in struct for the variable:\n\n\nCode\nstruct Employee\n{\n    int id{};\n    int age{};\n    double wage{};\n};\n\nvoid print_employee(const Employee& employee)\n{\n    std::cout << \"ID: \" << employee.id << '\\n';\n    std::cout << \"Age: \" << employee.age << '\\n';\n    std::cout << \"Wage: \" << employee.wage << \"\\n\\n\";\n}\n\nint main()\n{\n    Employee joe{ 10, 25, 3000.00 };\n    Employee frank{ 16, 30, 3500.00 };\n\n    print_employee(joe);\n    print_employee(frank);\n\n    return 0;\n}\n\n\nWe can also return by struct:\n\n\nCode\nEmployee get_employee()\n{\n    return {};\n    \n    #or\n    return {0, 0, 0.0};\n    \n    #or\n    return Employee {0, 0, 0.0};\n    \n    #or\n    Employee emp{};\n    return emp;\n}\n\n\n\nStruct with program-defined members\nStruct can include member as another struct.\n\n\nCode\nstruct Employee\n{\n    int id{};\n    int age{};\n    double wage{};\n};\n\nstruct Company\n{\n    int number_employees{};\n    Employee CEO{};\n};\n\nint main()\n{\n    Company my_company{ 10, {1, 30, 230000.00} };\n    std::cout << my_company.CEO.age << '\\n';\n\n    return 0;\n}\n\n\n\n\n\n\n\n\nClass is the heart of C++ and object oriented programming. It is built on top of structs. It is important to understand struct.\n\n\n\nGenerally, we use . to call members of a struct. If it is a reference to a struct, we also use ..\nFor a pointer to a struct, we cannot use ., we use operator -> instead:\n\n\nCode\n#include <iostream>\n#include <string>\n\nstruct Paw\n{\n    int claw{};\n};\n\nstruct Animal\n{\n    std::string name{};\n    Paw paw{};\n};\n\nint main()\n{\n    Animal puma{ \"Puma\", {5} };\n    Animal* ptr{ &puma };\n\n    std::cout << (ptr->paw).claw << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "c10_enums_structs.html#class-template",
    "href": "c10_enums_structs.html#class-template",
    "title": "11  Compound Types: Enums and Structs",
    "section": "11.9 Class template",
    "text": "11.9 Class template\nWe come to the property that type definition cannot be overloaded like function. We can use class template:\n\n\nCode\n#include <iostream>\n\ntemplate <typename T>\nstruct Pair\n{\n    T first{};\n    T second{};\n};\n\ntemplate <typename T>\nconstexpr T max(Pair<T> pair)\n{\n    return (pair.first > pair.second ? pair.first : pair.second);\n}\n\nint main()\n{\n    Pair<int> p1{ 5, 6 };\n    std::cout << p1.first << ' ' << p1.second << '\\n';\n    std::cout << max<int>(p1) << '\\n';\n\n    Pair<double> p2{ 3.2, 6.4 };\n    std::cout << p2.first << ' ' << p2.second << '\\n';\n    std::cout << max(p2) << '\\n';\n\n    return 0;\n}\n\n\nClass template can have normal variable and template variable:\n\n\nCode\ntemplate <typename T>\nstruct Pair\n{\n    T first{};\n    int second{};\n}\n\n\nClass template can have multiple types:\n\n\nCode\ntemplate< typename T, typename U>\nstruct Pair\n{\n    T first{};\n    U second{};\n};\n\ntemplate <typename T, typename U>\nvoid print(Pair<U, T> p)\n{\n    std::cout << '[' << p.first << \" , \" << p.second << ']';\n}\n\nvoid print(Pair2<T, U> pair)\n{\n    std::cout << '[' << pair.first << \", \" << pair.second << ']';\n}\n\nint main()\n{\n    Pair<int> p1{ 5, 6 };\n    std::cout << p1.first << ' ' << p1.second << '\\n';\n    std::cout << max<int>(p1) << '\\n';\n\n    Pair<double> p2{ 3.2, 6.4 };\n    std::cout << p2.first << ' ' << p2.second << '\\n';\n    std::cout << max(p2) << '\\n';\n\n    Pair2<int, double> p3{ 2, 8.6 };\n    print(p3);\n\n    return 0;\n}\n\n\n\nstd::pair\nC++ provide std::pair to work exactly as the pair template that we created above:\n\n\nCode\ntemplate <typename T, typename U>\nvoid print2(std::pair<T, U> pair)\n{\n    std::cout << '[' << pair.first << \", \" << pair.second << ']' << '\\n';\n}\n\nint main()\n{\n\n    std::pair<int, double> p4{ 10, 25.5 };\n    print2(p4);\n\n    return 0;\n}\n\n\nWe can put template definition (function, type) and type definition in the header for using in multiple files. They are exempt from one-definition rule.\n\n\nCode\n#ifndef PAIR_H\n#define PAIR_H\n\ntemplate <typename T>\nstruct Pair\n{\n    T first{};\n    T second{};\n};\n\ntemplate <typename T>\nconstexpr T max(Pair<T> p)\n{\n    return (p.first < p.second ? p.second : p.first);\n}\n\n#endif"
  },
  {
    "objectID": "c10_enums_structs.html#class-template-argument-deduction-and-deduction-guides",
    "href": "c10_enums_structs.html#class-template-argument-deduction-and-deduction-guides",
    "title": "11  Compound Types: Enums and Structs",
    "section": "11.10 Class template argument deduction and deduction guides",
    "text": "11.10 Class template argument deduction and deduction guides\nFrom C++17, we can define the template, but the compiler need a guide to deduce the member’s type, thus we write the deduction guide:\n\n\nCode\n#include <iostream>\n#include <utility>\n\ntemplate <typename T, typename U>\nstruct Pair\n{\n    T first{};\n    U second{};\n};\n\n# Deduction guide\ntemplate <typename T, typename U>\nPair(T, U) -> Pair<T, U>;\n\nint main()\n{\n    std::pair<int, int> p1{ 3, 4 };\n    std::pair p2{ 1, 2 };\n\n    Pair p2{ 3, 2 }; # need deduction guide\n\n}\n\n\nThe chapter’s summary is here."
  },
  {
    "objectID": "c11_arrays_1.html#loop-and-arrays",
    "href": "c11_arrays_1.html#loop-and-arrays",
    "title": "12  Arrays (Part 1)",
    "section": "12.1 Loop and arrays",
    "text": "12.1 Loop and arrays\nWe can always use array with loop\n\n\nCode\n#include <iostream>\n#include <iterator>\n\nint main()\n{\n    constexpr int scores[]{ 84, 92, 76, 81, 56 };\n    constexpr int number_students{ static_cast<int>(std::size(scores)) };\n\n    int total_scores{ 0 };\n\n    for (int i = 0; i < number_students; i++)\n    {\n        total_scores += scores[i];\n    }\n\n    auto average_scores{ static_cast<double>(total_scores) / number_students };\n\n    return 0;\n}\n\n\nAn example that use loop to find the max in an array:\n\n\nCode\n    int max_scores{ 0 };\n\n    for ( int i = 0; i < number_students; i++)\n    {\n        if (scores[i] > max_scores)\n            max_scores = scores[i];\n    }\n\n    std::cout << \"The best score was \" << max_scores << '\\n';\n\n\nHere is from exercise:\n\n\nCode\n#include <iostream>\n#include <iterator>\n#include <random>\n\n// Create random generators\n\nstd::mt19937 mt{ std::random_device{}() };\nstd::uniform_int_distribution array10{ 1, 9 };\n\nvoid get_array(int array[10])\n{\n    for (int counter{ 0 }; counter < 10; ++counter)\n    {\n        array[counter] = array10(mt);\n    }\n}\n\nvoid print(int array[10])\n{\n    for (int counter = 0; counter < 10; counter++)\n    {\n        std::cout << array[counter] << ' ';\n    }\n\n    std::cout << '\\n';\n}\nint get_index()\n{\n    while (true)\n    {\n        std::cout << \"Enter an integer between 1 and 9: \";\n        int index{};\n        std::cin >> index;\n        if (std::cin.fail())\n        {\n            std::cin.clear();\n            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n        }\n        else\n            return index;\n    }\n}\n\nint search_index(int array[10], int number)\n{\n    for (int index{ 0 }; index < 10; ++index)\n    {\n        if (number == array[index])\n            return index;\n    }\n\n    std::cout << \"There does not exit  your number in our array.\\n\";\n}\n\nint main()\n{\n    \n    int array[10]{ 4, 6, 7, 3, 8, 2, 1, 9, 5 };\n    //get_array(array);\n    print(array);\n    \n    int number{ get_index() };\n\n    //std::cout << \"The index \" << index << \" has number \" << array[index] << '\\n';\n    \nstd::cout << \"The number \" << number << \" has index \";\n    std::cout << search_index(array, number) << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "c11_arrays_1.html#sorting-an-array-using-selection-sort",
    "href": "c11_arrays_1.html#sorting-an-array-using-selection-sort",
    "title": "12  Arrays (Part 1)",
    "section": "12.2 Sorting an array using selection sort",
    "text": "12.2 Sorting an array using selection sort\nIn this session, we can use the function std::swap() from header utility to swap the positions of two variables.\n\nSelection sort\nThis is the easy method, but lowest one:\n\nStarting at array index 0, search the entire array to find the smallest value\nSwap the smallest value found in a array with the value at index 0\nRepeat step 1 and 2 starting from the next index\n\nHere is an example selection sorting:\n\n\nCode\n#include <iostream>\n#include <iterator>\n#include <utility>\n#include <random>\n\nvoid sort(int array[], int length)\n{\n    for (int start_index{ 0 }; start_index < length; ++start_index)\n    {\n        int smallest_index{ start_index };\n\n        for (int current_index{ start_index + 1 }; current_index < length; ++current_index)\n        {\n            if (array[current_index] < array[smallest_index])\n                smallest_index = current_index;\n        }\n\n        std::swap(array[start_index], array[smallest_index]);\n    }\n}\n\nvoid print(int array[], int length)\n{\n    for (int index{ 0 }; index < length; ++index)\n    {\n        std::cout << array[index] << ' ';\n    }\n\n    std::cout << '\\n';\n}\n\nvoid random_array(int array[], int length)\n{\n    std::mt19937 mt{ std::random_device{}() };\n\n    std::uniform_int_distribution value{ 1, 100 };\n\n    for (int index{ 0 }; index < length; ++index)\n    {\n        array[index] = value(mt);\n    }\n}\n\nint main()\n{\n    int array[20]{};\n    constexpr int length{ static_cast<int>(std::size(array)) };\n\n    random_array(array, length);\n    std::cout << \"Array before sorting: \\n\";\n    print(array, length);\n\n    sort(array, length);\n    std::cout << \"Array after sorting: \\n\";\n    print(array, length);\n}\n\n\nHere is an example of bubble sorting:\n\n\nCode\ntemplate <typename T>\nvoid sort_bubble(T array[], int length)\n{\n    for (int start_index{ 0 }; start_index < length - 1; ++start_index)\n    {\n        int count_swap{ 0 };\n        for (int index{ 0 }; index < length - start_index - 1; ++index)\n        {\n            if (array[index] > array[index + 1])\n            {\n                std::swap(array[index], array[index + 1]);\n                ++count_swap;\n            }\n        }\n\n        if (count_swap == 0)\n        {\n            std::cout << \"\\nEarly termination on interation \" << start_index << '\\n';\n            break;\n        }\n    }\n}\n\n\n\n\nstd::sort\nWe can use std::sort from the algorithm header."
  },
  {
    "objectID": "c11_arrays_1.html#multidimensional-arrays",
    "href": "c11_arrays_1.html#multidimensional-arrays",
    "title": "12  Arrays (Part 1)",
    "section": "12.3 Multidimensional Arrays",
    "text": "12.3 Multidimensional Arrays\nAn array can include any data type, even an array too. We can create a multidimensional array:\n\n\nCode\n    int array[3][5]\n    {\n        {1, 2, 3, 4, 5 },\n        {6, 7, 8, 9, 10},\n        {11, 12, 13, 14, 15},\n    };\n\n\nWe can ommit the left-most length, but not the rightmost; we can use zero initializer:\n\n\nCode\n    int array2[][3]\n    {\n        {1, 2, 3},\n        {4, 5, 6},\n    }\n\n    // Zero initializer\n    int array3[3][3]{};\n\n\nPrint array:\n\n\nCode\ntemplate <typename T>\nvoid print(T array[][3])\n{\n    for (int row{ 0 }; row < 2; ++row)\n    {\n        for (int column{ 0 }; column < 3; ++column)\n        {\n            std::cout << array[row][column] << ' ';\n        }\n\n        std::cout << '\\n';\n    }\n}"
  },
  {
    "objectID": "c11_arrays_1.html#c-style-string",
    "href": "c11_arrays_1.html#c-style-string",
    "title": "12  Arrays (Part 1)",
    "section": "12.4 C-style string",
    "text": "12.4 C-style string\nA C-style string is simply an array of characters that uses null terminator \\0.\nThis is an example of C-Style string:\n\n\nCode\n#include <iostream>\n#include <iterator>\n\nint main()\n{\n    char myString[]{ \"string\" };\n    const int length{ static_cast<int>(std::size(myString)) };\n\n    std::cout << myString << \" has \" << length << \" characters.\\n\";\n\n    return 0;\n}\n\n\nstd::cout only print the string until encountering \\0, the rest of array are ignored.\n\n\nCode\nint main()\n{\n    char name[20]{ \"Alex\" }; // only use 5 characters (4 letters + null terminator)\n    std::cout << \"My name is: \" << name << '\\n';\n\n    return 0;\n}\n\n#> Alex\n\n\n\n\n\n\n\n\nDo not use C-style string. Use std::string or std::string_view.\n\n\n\n\nC-style strings and std::cin\nSome cases that we do not know in advance how long our string is going to be. To cope with this, we use the code getline(name, std::size(name)).\nFor example:\n\n\nCode\n#include <iostream>\n#include <iterator> // for std::size\n\nint main()\n{\n    char name[255] {}; // declare array large enough to hold 254 characters + null terminator\n    std::cout << \"Enter your name: \";\n    std::cin.getline(name, std::size(name));\n    std::cout << \"You entered: \" << name << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "c11_arrays_1.html#stdstring_view-part-2",
    "href": "c11_arrays_1.html#stdstring_view-part-2",
    "title": "12  Arrays (Part 1)",
    "section": "12.5 std::string_view (part 2)",
    "text": "12.5 std::string_view (part 2)\nstd::string make a copy for the string created:\n\n\nCode\nint main()\n{\n\n    char text[]{ \"Hello\" };\n    std::string str{ text };\n    std::string more{ str };\n\n\n\n    return 0;\n}\n\n\nIn the above example, there are 4 copies Hello. First, the literal string store in the binary as the compile-time. Second is when we create char[] and the other two from std::string.\nThe std::string_view provides a view of a string defined elsewhere: it does not copy the string.\n\n\nCode\n    using namespace std::literals # using the prefix `sv`    \n\n    const char text[]{ \"Hello\" };\n    std::string_view str{ text };\n    std::string_view more{ str };\n    \n    auto str2{\"Hello\" sv};\n\n\nThere are useful operations (functions) to use for string_view that can be found at https://en.cppreference.com/w/cpp/string/basic_string_view.\n\n\nCode\n    auto str2{ \"Today is sunny\"sv };\n\n    std::cout << str2.length() << '\\n';\n    std::cout << std::boolalpha;\n    std::cout\n        << str2.starts_with(\"Today\") << '\\n'\n        << str2.starts_with(\"Yesterday\") << '\\n'\n        << str2.substr(0, str2.find(' ')) << '\\n';\n\n\nNotice that if we change the text, then the string_view str changes too.\n\nstd::string_view works with non-null-terminated strings\nstd::string_view does not use null terminators to mark the end of the string. It keeps track of its length to know the string ends.\n\n\nCode\n    char vowel[]{ 'a', 'e', 'i', 'o', 'u' };\n    std::string_view str3{ vowel, std::size(vowel) };\n\n    std::cout << str3 << '\\n';\n\n\n\n\nWhy are std::string_view parameters more efficient than const std::string&?\nThe figure below summaries our answer:\n\n\nCode\ninclude.graphic\n\n\nWe can use str.data() to access the string that is viewed. This function return a C-style string.\nAs I understand, when we create a string_view object, the viewed object is as C-style string (literal initializer) or std::string with null terminator. It is fine to use data() to point to the first character of viewed object. But, when we use str.remove_suffix(), it remove null terminator. The use of data() results undefined behavior."
  },
  {
    "objectID": "c11_arrays_1.html#array-and-pointer",
    "href": "c11_arrays_1.html#array-and-pointer",
    "title": "12  Arrays (Part 1)",
    "section": "12.6 Array and pointer",
    "text": "12.6 Array and pointer\nWhen a fixed array is used as an expression, it will decay into a pointer that points to the first element of the array.\nBut array and pointer are not identical. Array is of type int[], pointer is of type int*.\nWe can access the array’s element value through the pointer.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int array[5]{ 1, 2, 3, 4, 5 };\n\n    std::cout \n        << \"First element of array has address: \" \n        << &array[0] \n        << '\\n';\n\n    std::cout\n        << \"The array decays to a pointer holding address: \"\n        << array    // array as an expression\n        << '\\n';\n\n    # Access element's value by pointer\n    std::cout << *array << '\\n';\n\n    return 0;\n}\n\n\nWe can assign a pointer to point at the array:\n\n\nCode\n    int array[5]{ 1, 2, 3, 4, 5 };\n    int* ptr{ array };  # point to the first element\n\n\nArray and pointer have some differences:\n\nThe fixed array knows how long the array it is pointing to is. A pointer to the array does not.\nTaking the address of a pointer yields the memory address of the pointer variable. Of an array return pointer to the entire array.\n\nType of &array is int(*)[]\n\n\n\nRevisiting passing fixed arrays to functions\nWhen passing an array as an argument to a function, a fixed array decays into a pointer, and the pointer is passed to the function:\n\n\nCode\nvoid print_size(int* array)\n{\n    std::cout << sizeof(array) << '\\n';\n}\n#// the size of a pointer, not an array\n\n#// If the parameter is int array, C++ implicitly converses to pointer\n\n\nThe two functions are the same: void print_size(int* array) and void print_size(int array[])."
  },
  {
    "objectID": "c11_arrays_1.html#pointer-arithmetic-and-array-indexing",
    "href": "c11_arrays_1.html#pointer-arithmetic-and-array-indexing",
    "title": "12  Arrays (Part 1)",
    "section": "12.7 Pointer arithmetic and array indexing",
    "text": "12.7 Pointer arithmetic and array indexing\n\nPointer arithmetic\nIf ptr points to an integer, then ptr + 1 is the address of the next integer in memory after ptr; similar to ptr - 1.\nptr + 1 does not return to memory address after ptr, but the memory address of next object of the type the ptr points to.\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    int value{ 7 };\n    int* ptr{ &value };\n\n    std::cout\n        << ptr << '\\n'\n        << ptr + 1 << '\\n'\n        << ptr + 2 << '\\n'\n        << ptr + 3 << '\\n';\n\n    return 0;\n}\n\n\nArray’s elements are in sequence in memory. We know that fixed array return a pointer to an address of first element. Thus, adding 1 to an array array + 1, should point to the second element of the array.\nLet look at the following code:\n\n\nCode\nbool is_vowel(char ch)\n{\n    switch (ch)\n    {\n    case 'A':\n    case'a':\n    case 'E':\n    case 'e':\n    case 'I':\n    case 'i':\n    case 'O':\n    case 'o':\n    case 'U':\n    case 'u':\n        return true;\n    default:\n        return false;\n    }\n}\n\nint main()\n{\n    char name[]{ \"Phuong\" };\n    int array_length{ static_cast<int>(std::size(name)) };\n    int number_vowel{ 0 };\n\n    for (char* ptr{ name }; ptr != (name + array_length); ++ptr)\n    {\n        if (is_vowel(*ptr))\n        {\n\n            ++number_vowel;\n        }\n    }\n\n    std::cout << name << \" has \" << number_vowel_func(name) << \" vowels.\\n\";\n\n    return 0;\n}\n\n\nWe can use std::count_if from algorithm header:\n\n\nCode\n# use the function std::count_if from algorithm header\nauto number_vowel_std{ std::count_if(std::begin(name), std::end(name), is_vowel) };\nstd::cout << name << \" has \" << number_vowel_std << \" vowels.\\n\";"
  },
  {
    "objectID": "c11_arrays_1.html#dynamic-memory-allocation-with-new-and-delete",
    "href": "c11_arrays_1.html#dynamic-memory-allocation-with-new-and-delete",
    "title": "12  Arrays (Part 1)",
    "section": "12.8 Dynamic memory allocation with new and delete",
    "text": "12.8 Dynamic memory allocation with new and delete\nStatic variable and local variable has static allocation and auto allocation respectively. These allocation is on the stack memory which is size limited. They also require that the compiler knows the size at their definition.\nThe allocations invoke some limitation in programing if we need the size change frequently or big size memory.\nTo solve that, C++ has dynamic memory allocation; it requests memory from the memory pool in system (heap) when it needs.\n\nSingle variable’s dynamic allocation\nWe use the keyword new to tell the program create a dynamic allocation. The computer returns a pointer to the address of the memory allocated.\nWe need to create a pointer to keep track of that memory.\nTo release the memory back to the computer we use delete ptr; this does not delete the ptr, so that pointer is dangling pointer and may cause undefined behavior. We can assign that pointer to nullptr, a null pointer.\nHere is an example code:\n\n\nCode\n#include <iostream>\n\nint main()\n{\nint* ptr{ new int };\n*ptr = 7;\n    \ndelete ptr; \n#' return the memory back to the computer, ptr is dangling pointer\n\nstd::cout << *ptr << '\\n';  \ndelete ptr; \n#' try to deallocate the memory again lead to undefined behavior\n\nreturn 0;\n}\n\n\n\nOperator new can fail\nWe can add std::nothrow between the new keyword and the allocation type such as int* ptr{new (std::nothrow) int};. Using this code, if the operator fail, it returns a null pointer.\n\n\nNull pointer and dynamic allocation\nNull pointer is very useful to work with dynamic memory allocation. It says “no memory has been allocated to this pointer”. It allows us to do things like conditionally allocate memory\n\n\nCode\nif (!ptr)\n    ptr = new int;\n\n\n\n\nMemory leak\nThe pointer to a dynamic allocation memory is a normal variable so its scope follows the normal rule. The dynamic allocation object is only return to operate when we call delete keyword. There are some cases that the pointer to it goes out of scope without call delete. From that fact, our operate system still keep that memory for the program but we neither access it nor delete it because we do not know its address. We call it memory leak."
  },
  {
    "objectID": "c11_arrays_1.html#dynamic-allocation-arrays",
    "href": "c11_arrays_1.html#dynamic-allocation-arrays",
    "title": "12  Arrays (Part 1)",
    "section": "12.9 Dynamic allocation arrays",
    "text": "12.9 Dynamic allocation arrays\nWe use the following code to create and delete dynamic allocation arrays:\n\n\nCode\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter a positive integer for array's length: \";\n    int length{};\n    std::cin >> length;\n\n    int* array{ new int[length] {} };\n    std::cout << \"I just allocated an array of integers of length \" << length << '\\n';\n\n    array[0] = 5;\n\n    delete[] array;      \n    #//use array delete[] to deallocate array\n    #// array is going out of scope inmmeidately after this anyway\n\n    return 0;\n}\n\n\nRemember using delete[] not delete.\nDynamic array are almost identical to fixed arrays:\n\nIt decays to pointer to the first element\nIt does not know its length or size (return from std::size is a pointer size; return from sizeof is pointer size * number of element).\n\nDynamic array allows us to set the array’s length at the time of allocation, but C++ does not allow us to resize it.\nTo do this, we can use a resizable array called std::vector.\nHere is the code for the exercise:\n\n\nCode\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nauto get_number_name()\n{\n    std::cout << \"How many names would you like to enter?: \\n\" << \"Your repsonse: \";\n    int number_name{};\n    std::cin >> number_name;\n\n    return number_name;\n}\n\nauto enter_name()\n{\n        std::string name{};\n        std::getline(std::cin >> std::ws, name);\n    \n        return name;\n}\n\nvoid assign_array_value(std::string* array, int length)\n{\n    for (int index{ 0 }; index < length; ++index)\n    {\n        std::cout\n            << \"Enter name #\"\n            << index + 1\n            << \" : \";\n        std::getline(std::cin >> std::ws, array[index]);\n    }\n}\n\nvoid print(std::string* array, int length)\n{\n    for (int index{ 0 }; index < length; ++index)\n    {\n        std::cout\n            << \"Enter name #\"\n            << index + 1\n            << \" : \"\n            << array[index]\n            << '\\n';\n    }\n}\n\nint main()\n{\n    int number_name{ get_number_name() };\n    std::string* array_name{ new std::string[number_name]{} };\n\n    std::cout << \"\\nPlease enter the names: \\n\";\n    assign_array_value(array_name, number_name);\n\n    std::sort(array_name, array_name + number_name);\n    \n    std::cout << \"\\nHere is your sorted list: \\n\";\n    print(array_name, number_name);\n\n    delete[] array_name;\n\n    return 0;\n}"
  },
  {
    "objectID": "c11_arrays_1.html#for-each-loop",
    "href": "c11_arrays_1.html#for-each-loop",
    "title": "12  Arrays (Part 1)",
    "section": "12.10 For-each loop",
    "text": "12.10 For-each loop\nThe for-each statement has the syntax:\n\n\nCode\nfor (element_statment: array)\n    statement;\n\n\nThe loop will iterate through each element in array, assigning the value of the current array element to the variable declared in element_declaration:\n\n\nCode\nconstexpr int scores2[]{ 1, 2, 3, 4, 5 };\n\n#// Print the array\nfor (int score : scores2)\n{\n    std::cout << score << ' ';\n}\n\nstd::cout << '\\n';\n\n\n\nFor-each loops and the auto keyword\nThe type of element_statement is the same type of array’s element, so we can use the auto keyword.\n\n\nCode\nconstexpr int scores2[]{ 1, 2, 3, 4, 5 };\n\n#// Print the array\nfor (auto score : scores2)\n{\n    std::cout << score << ' ';\n}\n\nstd::cout << '\\n';\n\n\n\n\nfor-each loops and references\nIn for-each loops, the statement_element copies the element’s value. This is expensive. To avoid this, we can create the statement_element that refer to the array’s element value\n\n\nCode\nfor (auto& score : scores2)\n    {\n        std::cout << score << ' ';\n    }\n\n\nWe can also make it constant, if we just want to read only it.\n\n\n\n\n\n\nTo use for-each, the array:\n\nNot to be decayed to a pointer\nHave size information\n\n\n\n\n\n\nFor-each and non-arrays\nFor-array can work with other types of data like vector"
  },
  {
    "objectID": "c11_arrays_1.html#void-pointer",
    "href": "c11_arrays_1.html#void-pointer",
    "title": "12  Arrays (Part 1)",
    "section": "12.11 Void pointer",
    "text": "12.11 Void pointer\nWe can create a void pointer that can point to any type of data. But the void pointer does not know the data type that it is pointing to, we cannot dereference it to get value.\nIf we want to dereference, we create another pointer which initialize by the cast the void pointer to the true type.\n\n\nCode\n#include <iostream>\n#include <cassert>\n\nint nValue{};\nfloat fValue{};\n\nstruct Something\n{\n    int n;\n    float f;\n};\n\n\nint main()\n{\n    void* ptr;\n\n    Something sValue{0, 2.0};\n    int value{ 5 };\n\n    ptr = &nValue;  #// valid\n    ptr = &fValue;  #// valid\n    ptr = &sValue;  #// valid\n    ptr = &value;\n\n    std::cout << *ptr << '\\n';  #// illegal: dereference of void pointer\n\n    int* intPtr{ static_cast<int*>(ptr) };\n\n    std::cout << *intPtr << '\\n';   #// valid\n\n    return 0;\n}\n\n\nThis is impossible to do pointer arithmetic on void pointer because the pointer has to know what size object it is pointing to."
  },
  {
    "objectID": "c11_arrays_1.html#an-introduction-to-stdarray",
    "href": "c11_arrays_1.html#an-introduction-to-stdarray",
    "title": "12  Arrays (Part 1)",
    "section": "12.12 An introduction to std::array",
    "text": "12.12 An introduction to std::array\nBuild-in array has limitations:\n\nDecay to pointer when we pass it to a function’s parameter, so it does known its size\nProblem of dealloation of dynamic allocation array\n\nThus, there is std::array in the array header. Here the code to create it:\n\n\nCode\n#include <iostream>\n#include <array>\n\nint main()\n{\n    std::array<int, 5> array1{ 1, 2, 3, 4, 5 };\n    std::array array2{ 1, 2, 3 };   // From C++17, allow to omit both type and length\n\n    #// Use function `at()` or `[]` to access the array's element\n    #// But at() does the boundary check to avoid out-of-bound program at runtime\n    array2.at(1) = 3;   #// Equivalent to array2[1] = 3\n}\n\n\nWe can use at() to access array’s element. It is slower than [], but is safer.\n\nSize and sorting\nUse myArray.size() to get the array’s size. The std::array() does not decay to pointer when we pass it to function, so we can use size() inside a called function.\n\n\nCode\nvoid print_length(const std::array<int, 5>& my_array) #// why have to put int, 5\n{\n    std::cout << \"Length: \" << my_array.size() << '\\n';\n}\n\n\n\n\n\n\n\n\nAlways pass std::array object by reference or const reference to function’s parameter\n\n\n\n\n\nPassing std::array of different length to a function\nWe use the template for array type (typename T) and array size (std::size_t):\n\n\nCode\n#include <array>\n#include <cstddef>  // for std::size_t\n#include <iostream>\n\n//array_print() is a template function\ntemplate <typename T, std::size_t size>\nvoid array_print(const std::array<T, size>& array)\n{\n    for (auto element : array)\n        std::cout << element << ' ';\n    \n    std::cout << '\\n';\n}\n\nint main()\n{\n    std::array my_array{ 9.0, 7.2, 3.6, 1.8 };\n    array_print(my_array);\n\n    std::array my_array2{ 1, 3, 4, 2, 6 , 5, 9 ,7 };\n    array_print(my_array2);\n\n    return 0;\n}\n\n\nWith std::array, the element type and array length are part of type information, thus we have to specify them as a function parameter.\nWe use template <typename T, std::size_t size> to create a function work with std::array.\n\nsize_t\nIn std::array, the function size() and the operator[] return the object type size_t, thus we intitialize std::size_t in for loops.\n\n\nCode\n    #// Use std::array with for loops\n    for (std::size_t index{ 0 }; index < my_array2.size(); ++index)\n        std::cout << my_array2.at(index) << ' ';\n\n\n\n\n\nArray of struct\nWe can have a std::array of struct:\n\n\nCode\ntruct House\n{\n    int number{};\n    int stories{};\n    int room_per_story{};\n};\n\nint main()\n{\n    #// Array of struct\n    std::array<House, 3> houses{};\n    houses[0] = { 14, 3, 30 };\n    houses[1] = { 14, 3, 10 };\n    houses[2] = { 15, 3, 40 };\n\n    #// Other way to initialize array of struct\n    std::array<House, 3> houses2{\n        {\n            {14, 3, 30},\n            {14, 3, 10},\n            {15, 3, 40},\n        }\n    };\n\n    return 0;\n}"
  },
  {
    "objectID": "c11_arrays_1.html#introduction-to-stdvector",
    "href": "c11_arrays_1.html#introduction-to-stdvector",
    "title": "12  Arrays (Part 1)",
    "section": "12.13 Introduction to std::vector",
    "text": "12.13 Introduction to std::vector\nstd::vector provides dynamic array functionality that handles its own memory management. We can create an array that have its length set at run-time, without using new and delete.\nWe use std::vector from header vector.\n\n\nCode\n#include <iostream>\n#include <cstddef>\n#include <vector>\n\nint main()\n{\n    std::vector<int> v1;\n    std::vector<int> v2 = { 9, 7, 5, 3, 1 };\n    std::vector<int> v3{ 9, 7, 5, 3, 1 };\n    \n    #// From C++17:\n    std::vector v4{9, 7, 5, 3, 1};\n    \n    #// Declare a vector size\n    std::vector<TYPE> v6(vector_size);\n\n    int vec_length{};\n    std::cout << \"Enter the vector's length: \";\n    std::cin >> vec_length;\n\n    std::vector<int> v5(vec_length);\n\n    for (int index{ 0 }; index < vec_length; ++index)\n    {\n        std::cout << \"Enter value #\" << index + 1 << \": \";\n        std::cin >> v5.at(index);\n    }\n\n    return 0;\n}\n\n\nWe use operator [] and also function at() to access vector’s elements.\n\n\nCode\n#// Assign value to vector's element\nv4[1] = 2;\nv4.at(3) = 4;\n\n\nBuilt-in dynamics array does not know its length they are pointing to, std::vector keeps track of its length and can extract from size(). Notice that size() always returns object type size_type, full type std::vector<int>::size_type, which is an unsigned integer.\nWe can resize a vector by resize() function:\n\n\nCode\nv4.resize(6);"
  },
  {
    "objectID": "c11_arrays_1.html#introduction-to-iterators",
    "href": "c11_arrays_1.html#introduction-to-iterators",
    "title": "12  Arrays (Part 1)",
    "section": "12.14 Introduction to iterators",
    "text": "12.14 Introduction to iterators\nAn iterator is an object designed to traverse through a container, providing access to each element along the way.\n\nPointer as an iterator\nThe simplest kind of iterators is a pointer that work for data stored sequentially. We can use the pointer and pointer arithmetic to access the element and use in loops.\nThe std::array provides functions begin() and end() to access the pointer to the begin and end of an array.\nHere is an example code:\n\n\nCode\n#//Pointer as an iterators\n\nstd::array arr{ 1, 3, 4, 7, 8, 5, 9 };  \n\nstd::cout << \"Use pointer: \\n\";\nauto begin{ arr.begin()};\nauto end{ arr.end()};\n\nfor (auto ptr{ begin }; ptr != end; ++ptr)\n{\n    std::cout << *ptr << ' ';\n}\n\nstd::cout << '\\n';\n\n#// Use the iterator header\n\nbegin = std::begin(arr);\nend = std::end(arr);\n\n\n\n\nInvalidated iterators\nIf iterated elements are deleted or changed the address, the iterators to that element is invalidated; this iterator has undefined behaviors:\n\n\nCode\n    #// Invalidated iterators\n    std::vector v{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    \n    auto it{ v.begin() };\n    ++it;\n    std::cout << *it << '\\n';\n    v.erase(it);    #// ecrease element currently being iterated over\n\n    ++it;   #// undefined behavior\n    std::cout << *it << '\\n';"
  },
  {
    "objectID": "c11_arrays_1.html#introduction-to-standard-library-algorithm",
    "href": "c11_arrays_1.html#introduction-to-standard-library-algorithm",
    "title": "12  Arrays (Part 1)",
    "section": "12.15 Introduction to standard library algorithm",
    "text": "12.15 Introduction to standard library algorithm\nHeader algorithm contains the functions help us work with data efficiently and safely.\n\nstd::find to find an element by a value\nThe function takes three parameters: an iterator to the starting element, an iterator to the end of element, and the value to search for.\nstd::find returns a pointer to the element found.\nFor example:\n\n\nCode\n#include <iostream>\n#include <array>\n#include <algorithm>\n\nvoid handle_cin_fail()\n{\n        std::cin.clear();\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n}\n\nint get_input()\n{\n    int input{};\n    std::cin >> input;\n\n    while (std::cin.fail())\n    {\n        handle_cin_fail();\n\n        std::cout << \"Invalid value. Enter again: \";\n        std::cin >> input;\n    }\n\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n    return input;\n}\n\nbool confirm()\n{\n    char c{};\n    std::cin >> c;\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n    switch (c)\n    {\n    case 'y':\n        return true;\n    case 'n':\n        return false;\n    default:\n        std::cerr << \"Invalid response!\";\n        std::abort();\n    }\n}\n\n\nint main()\n{\n    #// This program such a value in an array and replace it by a user's value\n    std::array arr{ 13, 20, 25, 32, 100, 56, 30, 14, 32 };\n\n    int search{};\n    int replace{};\n\n    while (true)\n    {\n        std::cout << \"Please enter the value which you want to search, and then a new replaced value: \";\n        search = get_input();\n        replace = get_input();\n\n        std::cout << \"Your search value: \" << search << '\\n';\n        std::cout << \"Replace by: \" << replace << '\\n';\n\n        std::cout << \"Do you confirm? (y or n): \";\n        bool con{ confirm() };\n        if (con)\n            break;\n        else\n        {\n            std::cout << \"You chose 'n', do you want to re-enter? (y or n): \";\n            con = confirm();\n            if (!con)\n            {\n                std::cout << \"You decided to end. Thank you! Exiting...\\n\";\n                break;\n            }\n                \n        }\n    }\n\n    auto found{ std::find(arr.begin(), arr.end(), search) };\n\n    if (found == arr.end())\n    {\n        std::cout << \"Could not find \" << search << \" in the array.\\n\";\n    }\n    else\n    {\n        *found = replace;\n    }\n\n    for (int i : arr)\n    {\n        std::cout << i << ' ';\n    }\n\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\n\n\nstd::find_if to find an element that matches some condition\nThis function finds the element that return true in a predicate function. There are 3 parameters in this function: the start position, the end position, and a bool function.\nHere is an example:\n\n\nCode\n#include <algorithm>\n#include <array>\n#include <iostream>\n#include <string>\n#include <string_view>\n\nbool str_exit(const std::string_view str)\n{\n    return (str.find(\"nut\") != std::string_view::npos);\n}\n\nint main()\n{\n    std::array<std::string_view, 5> str{ \"apple\", \"banananut\", \"walnut\", \"lemon\" };\n\n    #//std::string str_chose{};\n    #//std::cout << \"What string do you want to find?: \";\n    #//std::cin >> str_chose;\n\n    auto found{ std::find_if(str.begin(), str.end(), str_exit) };\n\n    if (found == str.end())\n    {\n        std::cout << \"Cannot find your string\\n\";\n    }\n    else\n    {\n        std::cout << \"Found: \" << *found << '\\n';\n    }\n\n    return 0;\n}\n\n\n\n\nUsing std::for_each to do something to all elements of a container\nstd::for_each takes a list as input and applies a custom function to every element.\nHere is an example:\n\n\nCode\nvoid double_number(int& i)\n{\n    i *= 2;\n}\n\nint main()\n{\n    #// std::for_each\n    std::array arr{ 1, 2, 3 };\n    std::for_each(arr.begin(), arr.end(), double_number);\n\n    for (auto i : arr)\n    {\n        std::cout << i << ' ';\n    }\n\n    std::cout << '\\n';\n\n    return 0;\n}\n\n\nHere is chapter’s summary: https://www.learncpp.com/cpp-tutorial/chapter-11-comprehensive-quiz/."
  },
  {
    "objectID": "c12_function.html#function-pointers",
    "href": "c12_function.html#function-pointers",
    "title": "13  Function",
    "section": "13.1 Function pointers",
    "text": "13.1 Function pointers\nLet consider the following function:\n\n#include <iostream>\n\nint foo()\n{\n    return 5;\n}\n\nint main()\n{\n    std::cout << foo << '\\n';   #// print function's address\n    \n    std::cout << reinterpret_cast<void*>(foo) << '\\n'\n    #// force the compiler print function's address\n\n    return 0;\n}\n\n#> 00009F3CB\n\nIdentifer foo is the function’s name. It has its own l-value function type which is function that return an int and takes no parameters.\nLike a variable, system assigns an address to a function.\nWhen we use the operator(), the program jumps to an address of called function to execute. If we send a function without calling it (omit the operator()) to std::cout, we get function’s address instead. We added an example to the chunk foo above.\n\nPointers to functions\nHere is a code:\n\nint (*fcnPtr)()\n\n#// this is a pointer to a function that takes no parameter and return an integer\n#// remember to put in parentheses\n\n\nint (*const fcnPtr)();\n#// const function pointer\n\n\n\nAssigning a function to a function pointer\nFunction pointers can be initialized with a function (a non-const function pointer can be assgined a function).\nThe pointer function has to same return type and parameters with the function pointed. Here is an example:\n\n#include <iostream>\n\nint foo()\n{\n    return 5;\n}\n\ndouble goo()\n{\n    return 6.0;\n}\n\nint hoo(int x)\n{\n    return x;\n}\n\nint main()\n{\n    std::cout << foo << '\\n';\n\n    int (*f_ptr1)() { &foo };\n    double (*f_ptr2)() { &goo };\n    int (*f_ptr3)(int) { &hoo };\n    \n    #// C++ implicitly convert a function into a function pointer\n    int (*f_ptr4)(){foo};   #// do not need use \"&\"\n\n    return 0;\n}\n\nFunction pointers can also be initialzed or assgined to nullptr:\n\nint (*fcnptr)() {nullptr};\n\n\n\nCalling a function using a function pointer\nThere are two ways: explicit dereference and implicit dereference. Here is the code:\n\n#// Explicitly:\n(*f_ptr3)(5);\n\n#// Implicitly:\nf_ptr3(5);\n\nNote: the default parameter cannot work with function call by a pointer. Because default parameter is evaluated at compile-time, while function pointers are at run-time. We need to explicitly give the value to the function pointers.\n\n\nPassing functions as arguments to other functions\nWe can pass a function as an argument of other function, that arguments is callback functions.\nWith this, we can make a function more flexible by letting user’s put their function. An example for this is the sorting function.\nWe write a sorting program that allow the users to sort the list ascending or descending. This function use a function as its parameter; the callback function work on how to sort the list by varying the comparison between two elements.\nThis is a code that does not use the function pointer:\n\n#include <utility>\n\nbool ascending(int x, int y)\n{\n    return x > y;\n}\n\nvoid selection_sort( int* array, int size )\n{\n    for (int start_index{ 0 }; start_index < size - 1; ++start_index)\n    {\n        int smallest_index{ start_index };\n\n        for (int current_index{ start_index + 1 }; current_index < size; ++current_index)\n        {\n            if (ascending(array[smallest_index], array[current_index]))\n                smallest_index = current_index;\n        }\n\n        std::swap(array[start_index], array[smallest_index]);\n    }\n}\n\nWe want the caller decide how the sorting will be done, we can use the function pointer. In the above code, the comparison returns a boolean object, thus we create a pointer to a boolean function that takes two int parameters:\n\nbool (*compare_fcn)(int, int)\n\nThus we rewrite the code as:\n\n#include <utility>  #\\\\ using the `std::swap`\n\nbool ascending(int x, int y)\n{\n    return x > y;\n}\n\nbool descending(int x, int y)\n{\n    return x < y;\n}\n\n#// We can add many customization function:\nbool even_first(int x, int y)\n{\n    if ((x % 2 == 0) && !(y % 2 == 0))\n        return false;\n    if (!(x % 2 == 0) && (y % 2 == 0))\n        return true;\n\n    return ascending(x, y);\n}\n\nvoid selection_sort( int* array, int size, bool (*compare_fcn)(int, int))\n{\n    for (int start_index{ 0 }; start_index < size - 1; ++start_index)\n    {\n        int smallest_index{ start_index };\n\n        for (int current_index{ start_index + 1 }; current_index < size; ++current_index)\n        {\n            if (compare_fcn(array[smallest_index], array[current_index]))\n                smallest_index = current_index;\n        }\n\n        std::swap(array[start_index], array[smallest_index]);\n    }\n}\n\nint main()\n{\n    int array[11]{ 3, 7, 0 ,5 ,8, 9 ,10, 2, 15, 20, 15 };\n\n    selection_sort(array, 11, ascending);\n    print(array, 11);\n\n    selection_sort(array, 11, descending);\n    print(array, 11);\n\n    selection_sort(array, 11, even_first);\n    print(array, 11);\n\n    return 0;\n}\n\nWe can provide default functions to a function pointer parameter:\n\nvoid selection_sort( int* array, int size, bool (*compare_fcn)(int, int) = ascending);\n\nWe can make function pointer prettier with type aliases:\n\n#// Name alias for function pointer type\nusing Validate_fcn = bool(*)(int, int);\n\n#// The the sorting function is rewrite as:\nvoid selection_sort( int* array, int size, Validate_fcn pfcn = ascending);\n\n\n\nUsing std::function\nWe use std::function from header functional header like this:\n\n#include <functional>\n\nstd::function<bool(int, int) > fcnPtr{};\nfcnPtr = &ascending;\n\n#// Using alias name for clear code\nusing validate_fcn = std::function<bool(int, int)>;\n\nWe only use implicit dereference with std::function.\nFrom C++17, compiler can deduce the return type and parameter of pointer function from pointed function initializer. But, this does not work with type alias.\nWe can use keyword auto with function pointer, but this is not recommended because we easily make mistakes.\n\n\nExercsise\nHere is the full code of the exercise for this session:\n\n\nCode\n#include <functional>\n#include <cassert>\n#include <iostream>\n\nstruct Inputs\n{\n    int first{};\n    int second{};\n    char op{};\n};\n\nint get_integer()\n{\n    int x{};\n    std::cin >> x;\n\n    while (std::cin.fail())\n    {\n        std::cin.clear();\n        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n        std::cout \n            << \"Invalid integer. \"\n            << \"Please enter again your integer: \";\n        std::cin >> x;\n    }\n\n    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n    return x;\n}\nauto get_operator()\n{\n    char op{};\n    do\n    {\n        std::cout << \"Please enter your operators ( +, -, *, /): \";\n        std::cin >> op;\n    } while (op != '+' && op != '-' && op != '*' && op != '/');\n\n    return op;\n}\n\n\nThen, we create a function to take the operator:\n\nauto add(int x, int y)\n{\n    return x + y;\n}\n\nauto substract(int x, int y)\n{\n    return x - y;\n}\n\nauto multiply(int x, int y)\n{\n    return x * y;\n}\n\nauto divide(int x, int y)\n{\n    assert(y != 0 && \"Cannot devide by zero! Return error.\");\n    \n    return x / y;\n}\n\nCreate a pointer function to get the arithmetic function:\n\nusing Arithmetic_fcn = std::function<int(int, int)>;\n\nArithmetic_fcn get_arithmetic_fcn(char op)\n{\n    switch (op)\n    {\n    case '+':\n        return &add;\n    case '-':\n        return &substract;\n    case '*':\n        return  &multiply;\n    case '/':\n        return &divide;\n    default:\n        return nullptr;\n    }\n}\n\nint main()\n{\n    std::cout << \"Please enter your first integer: \";\n    auto first{ get_integer() };\n\n    std::cout << \"Please enter your second integer: \";\n    auto second{ get_integer() };\n\n    std::cout << \"Please enter your operator: \";\n    auto op{ get_operator() };\n\n    Arithmetic_fcn fcn{ get_arithmetic_fcn(op) };\n\n    if (fcn)\n    {\n        std::cout\n            << first << ' ' << op << ' ' << second << \" = \"\n            << fcn(first, second) << '\\n';\n    }\n    else\n    {\n        std::cout << \"Error: cannot execute your request.\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "objectID": "c11_arrays_1.html#further-from-the-exercises",
    "href": "c11_arrays_1.html#further-from-the-exercises",
    "title": "12  Arrays (Part 1)",
    "section": "12.16 Further from the exercises",
    "text": "12.16 Further from the exercises\n\nUsing name alias for non-fundamental data type\nHere is the code example:\n\n\nCode\nstruct Student\n{\n    std::string name{};\n    double grade{};\n}\n\nusing Students = std::vector<Student>;\n\nenum Item_types\n{\n    health,\n    torchs,\n    arrows,\n    max_numbers,\n};\n\nusing Items = std::array<Item_types, max_numbers>\n\n\nWhen use for-each loop with struct data type, we can access its member\n\n\nCode\nfor(auto& student: Students)\n{\n    std::cin >> student.name;\n    std::cin >> student.grade;\n}\n\n\n\nRemember to avoid the off-by-one error when use loop for array.\nCannot change value of x: const int* ptr{&x}\nIf length is not a compile-time constant, we cannot define int temp[length]{}. Ex: length is a parameter in a function. We can use std::vector."
  },
  {
    "objectID": "c12_function.html#the-stack-and-the-heap",
    "href": "c12_function.html#the-stack-and-the-heap",
    "title": "13  Function",
    "section": "13.2 The stack and the heap",
    "text": "13.2 The stack and the heap\n\nThe heap segment\nHeap segment (also called “free store”) keeps track of memory used for dynamic memory allocation.\nIn C, using new operator results in the allocation in heap segment.\n\nint* ptr{new int};\nint* array{new int[10]}\n\nSubsequent call the memory allocation, does not guarantee sequential memory address. For example, ptr and array may not have sequential addresses.\nThe heap has advantage and disadvantages:\n\n\n\nAvantages\n\nDo not need to assign size at the compile time\nLarge arrays, structures, or classes can be allocated there.\n\n\n\nDisavantages\n\nComparatively slow\nNeed to be deallocated or application ends\nMust be accessed through a pointer\n\n\n\n\n\n\nThe call stack\nThe call stack keeps track of all the active functions from the start of the program to the current point of execution, and handles allocation of all function parameters and local variables.\nIt is a stack data structure.\n\nThe stack data structure\nA data structure is a programming mechanism for organizing data so that it can be used efficiently.\nExample of data structure is arrays and structs. And stack is one of these.\nLet image stack as a stack of plates. In computer programming, a stack contains multiple variables (much like an array). A stack is more limited that we can not access and modify as we wish. We only perform on stack three things:\n\nLook at the top item on the stack: top() or sometimes peek().\nTake the top item off of the stack: pop().\nPut a new item on top of the stack: push().\n\nA stack is “last-in, first-out”. Let use an analogy: mailboxes. Each mailbox holds one item, they are stacked together. Each mailbox nails to the mailbox below, so the number of mailboxes cannot be changed.\nWe use a marker to keep track of where the bottom-most empty mailbox is. When we push an item onto our mailbox stack, we put in the mailbox that is marked, and move the marker up on mailbox; when we pop an item off, we move the marker down one mailbox\nAnything below the mailbox is on the stack; anything at the marker or above the marker is not on the stack.\nWhen program encounter a function call, it pushes the function onto the call stack. When a function ends, function is popped off the call stack. We see all of the functions that were called to get to the current point of execution.\nThe stack itself is a fixed-sized chunk of memory addresses. The mailboxes are memory addresses, and the items pushing or popping out on the stack are call stack frame.\nA stack frame keeps track of all of data associated with one function call. The “marker” is a register as a the stack pointer.\n\n\nThe call stack in action\nWhen a function is called:\n\nThe program encounters a function call\nA stack frame is constructed and pushed on the stack. The stack frame consists of:\n\nReturn address: the address of the instruction where to return after the called function exits.\nAll functions arguments\nMemory fo any local variables\nSaved copies of any registers modified by the function that need to be restored when the function returns.\n\nThe CPU jumps to the function’s start point\nThe instructions inside of the function begin executing.\n\nWhen the function terminates:\n\nRegisters are restored from the call stack\nThe stack frame is popped off the stack (free local variables, arguments).\nThe return value is handled\nThe CPU resumes executions at the return address.\n\n\n\nStack overflow\nStack overflow happens when all the memory in the stack has been allocated."
  },
  {
    "objectID": "c12_function.html#stdvector-capacity-and-stack-behavior",
    "href": "c12_function.html#stdvector-capacity-and-stack-behavior",
    "title": "13  Function",
    "section": "13.3 std::vector capacity and stack behavior",
    "text": "13.3 std::vector capacity and stack behavior\nstd::vector is a dynamic array that both remembers its length and be resized as required. This array has another attribute, it is capacity: how many elements were allocated in memory; length is how many elements are being used in the array.\nLook at the code below to see the difference between length and capacity:\n\n#include <vector>\n#include <iostream>\n\nint main()\n{\n    std::vector<int> array{};\n    array = { 0, 1, 2, 3, 4, 5 };   // array of length 5\n    std::cout\n        << \"Length :\" << array.size()\n        << \". Capacity: \" << array.capacity() << '\\n';\n\n    array = { 9, 8, 7 };\n    std::cout\n        << \"Length :\" << array.size()\n        << \". Capacity: \" << array.capacity() << '\\n';\n\n    return 0;\n}\n#> Length: 6. Capacity: 6\n#> Length: 3. Capacity: 6\n\nNotice that range for subscript operator([]) and at() is from vector’s length, not the capacity.\n\nStack behavior with std::vector\nstd::vector can also be used as a stack with 3 functions:\n\npush_back(): pushes an element on the stack\nback(): returns the value of the top element on the stack\npop_back(): pops an element off the stack\n\nUnlike the array subscript or at(), the stack-based function resizes the std::vector if necessary. But, resizing is expensive. We avoid by allocating a certain amount of capacity up front using the function reserve() function.\nHere is a code for the above ideas:\n\n#include <vector>\n#include <iostream>\n\nvoid print_stack(const std::vector<int>& stack)\n{\n    for (auto element : stack)\n        std::cout << element << ' ';\n    std::cout \n        << \"(cap \" << stack.capacity() \n        << \" length \" << stack.size() << \")\\n\";\n}\n\nint main()\n{\n    \n    std::vector<int> stack{};\n    stack.reserve(5);\n\n    print_stack(stack);\n\n    stack.push_back(5);\n    print_stack(stack);\n\n    stack.push_back(4);\n    print_stack(stack);\n\n    stack.push_back(3);\n    print_stack(stack);\n\n    std::cout << \"top: \" << stack.back() << '\\n';\n\n    stack.pop_back();\n    print_stack(stack);\n\n    stack.pop_back();\n    print_stack(stack);\n\n    return 0;\n}\n\nWhen vector resizes, it may allocate more capacity than needed; this is called “breathing room”. For example, when we use the push_back() another element, it would not need to resize immediately."
  },
  {
    "objectID": "c12_function.html#recursion",
    "href": "c12_function.html#recursion",
    "title": "13  Function",
    "section": "13.4 Recursion",
    "text": "13.4 Recursion\nA recursion function in C++ is a function that calls itself. It works like a normal function, but we must include a recursive termination condition, or they will run “forever”.\nA recursive termination is condition that, when met, will cause the recursive function to stop calling itself. We usually use the if statement.\nHere is the example code:\n\n#include <iostream>\n\nvoid count_down(int count)\n{\n    std::cout << \"push \" << count << '\\n';\n\n    if (count > 1)\n        count_down(count - 1);\n\n    std::cout << \"pop: \" << count << '\\n';\n}\n\nint main()\n{\n    count_down(5);\n\n    return 0;\n}\n\n#> push 5\n#> push 4\n#> push 3\n#> push 2\n#> push 1\n#> pop 1\n#> pop 2\n#> pop 3\n#> pop 4\n#> pop 5\n\nHere is another example:\n\nauto sum_to(int sumto)\n{\n    if (sumto <= 0)\n        return 0;\n    \n    if (sumto == 1)\n        return 1;\n\n    return sum_to(sumto - 1) + sumto;\n}\n\nRecursion uses to catch the fibonacci numbers:\n\nauto fibonacci(int count)\n{\n    if (count == 0)\n        return 0;\n    if (count == 1)\n        return 1;\n\n    return fibonacci(count - 1) + fibonacci(count - 2);\n}\n\nThe above code call too many functions, so it is inefficiently. One technique called, memorization, caches the results of expensive function calls so the results can be returned when the same input occurs again:\n\nint fibonacci_memo(int count)\n{\n    static std::vector results{ 0, 1 };\n\n    if (count < static_cast<int>(std::size(results)))\n        return results[count];\n\n    results.push_back(fibonacci_memo(count - 1) + fibonacci(count - 2));\n\n    return results[count];\n}\n\nint main()\n{\n    for (int count{ 0 }; count < 15; ++count)\n        std::cout << fibonacci_memo(count) << ' ';\n    std::cout << '\\n';\n\n    return 0;\n}\n\nThe recursion is a good choice when most of following are true:\n\nThe code is much simpler to implement\nThe recursion depth can be limited\nThe iterative version of the algorithm requires managing stack of data\nThis is not a performance-critical section of code"
  },
  {
    "objectID": "c12_function.html#command-line-arguments",
    "href": "c12_function.html#command-line-arguments",
    "title": "13  Function",
    "section": "13.5 Command line arguments",
    "text": "13.5 Command line arguments\nWhen a program is run, execution starts at the top of the function main(). We have seen that main() takes no parameters. However, some programs need parameters to run.\nCommand line arguments are optional string arguments that are passed by the operating system to the program when it is launched. The program can use them as inputs or ignore them.\nMuck like function parameters provide a way for a function to provide inputs to another functions, command line arguments provide a way for people or programs to provide inputs to a program.\n\nUsing command line arguments\nAfter providing the command line arguments, we can access them from C++ program. We define a new form of main() such as\n\nint main(int argc, char* argv[])\n\n\nargc is an integer containing the count of the number of arguments passed to the program.\nargv is where the actual argument values are stored as an array of C-style strings, the length of array is argc.\n\nHere is a simple program use the command line:\n\n#include <iostream>\n\nint main(int argc, char* argv[])\n{\n    std::cout << \"There are \" << argc << \" arguments:\\n\";\n\n    for (int count{ 0 }; count << argc; ++count)\n    {\n        std::cout << count << ' ' << argv[count] << '\\n';\n    }\n\n    return 0;\n}\n\nThe command line arguments are as strings, if we want to use them as numeric type, we need to cover it.\nHere is an example:\n\n#// Program: MyArgs\n#include <sstream>      // use std::stringstream\n#include <string>\n#include <iostream>\n\nint main(int argc, char* argv[])\n{\n    std::cout << \"There are \" << argc << \" arguments:\\n\";\n\n    if (argc <= 1)\n    {\n        if (argv[0])\n        {\n            std::cout << \"Usage: \" << argv[0] << \"<number>\" << '\\n';\n        }\n        else\n            std::cout << \"Usage: <program name> <number>\" << '\\n';\n        return 1;\n    }\n\n    std::stringstream covert{ argv[1] };\n\n    int my_int{};\n    if (!(covert >> my_int))\n        my_int = 0;\n\n    std::cout << \"Got integer: \" << my_int << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "c12_function.html#ellisis-and-why-to-avoid-them",
    "href": "c12_function.html#ellisis-and-why-to-avoid-them",
    "title": "13  Function",
    "section": "13.6 Ellisis (and why to avoid them)",
    "text": "13.6 Ellisis (and why to avoid them)\nThe number of function’s parameters must be known in advance. But, some cases where it can be useful to be able to pass a variable number of parameters. C++ provide a special specifier known as ellipsis ... to do it precisely.\nThe authors recommended avoid using ellipsis.\nHere is a way to declare:\n\nreturn_type function_name(parameter_list, ...)\n\nThe ellipsis captures additional arguments and it like an array that contains the parameters\n\nAn ellipsis example\nWe write a program to return an average of a list of integer.\n\n#include <cstdarg>  // use ellipsis: std::va_list, va_start, va_arg, va_end\n#include <iostream>\n\nauto mean(int count, ...)\n{\n    int sum{ 0 };\n\n    std::va_list list;\n    \n    va_start(list, count);\n\n    for (int i{ 0 }; i < count; ++i)\n    {\n        sum += va_arg(list, int);   #// va_arg: point to the next arg in list\n    }\n\n    va_end(list);\n\n    return static_cast<double>(sum) / count;\n}\n\nint main()\n{\n    std::cout << \"mean: \" << mean(5, 1, 2, 3, 4, 5) << '\\n';\n\n    return 0;\n}\n\n\n\nWhy using ellipsis is dangerous\n\nType checking on the parameters is suspended. In some cases, our program will just produce garbage or crash.\nEllipsis don’t know how many parameters were passed. Thus, to keep track of parameters’ numbers, there are three ways:\n\nMethod 1: Pass a length parameter like above example\nMethod 2: use a sentinel value. A sentinel value terminates a loop when it is encountered such as \\0 for string. For ellipsis,the sentinel is passed in as the last parameter.For example, we assign -1 to the last parameter in ellipsis:\n\n\n\n#include <cstdarg>  // use ellipsis: std::va_list, va_start, va_arg, va_end\n#include <iostream>\n\nauto mean(int first, ...)\n{\n    int sum{ first };\n\n    std::va_list list;\n    \n    va_start(list, first);\n    \n    int count{ 1 };\n\n    while (true)\n    {\n        int arg{ va_arg(list, int) };\n\n        if (arg == -1)\n            break;\n\n        sum += arg;\n        ++count;\n    }\n\n    va_end(list);\n\n    return static_cast<double>(sum) / count;\n}\n\nint main()\n{\n    std::cout << \"mean: \" << mean(1, 2, 3, 4, 5, -1) << '\\n';\n\n    return 0;\n}"
  },
  {
    "objectID": "c12_function.html#introduction-to-lambdas-anonymous-functions",
    "href": "c12_function.html#introduction-to-lambdas-anonymous-functions",
    "title": "13  Function",
    "section": "13.7 Introduction to lambdas (anonymous functions)",
    "text": "13.7 Introduction to lambdas (anonymous functions)\nLambda expression allows us to define an anonymous function inside another function. This is the structure:\n\n[ capture clause] (parameters) -> returnType(#//optional)\n    {\n        statements;\n    }\n\nHere is an example:\n\n#include <algorithm>\n#include <array>\n#include <string_view>\n#include <iostream>\n\nint main()\n{\n    constexpr std::array<std::string_view, 4> arr{ \"apple\", \"banana\", \"walnut\", \"lemon\" };\n\n    const auto found\n    {\n        std::find_if\n        (\n            arr.begin(), arr.end(),\n            [](std::string_view str)\n            {\n                return (str.find(\"nut\") != std::string_view::npos);\n            }\n        )\n    };\n\n    if (found == arr.end())\n        std::cout << \"Cannot found\\n\";\n    else\n    {\n        std::cout << \"Found \" << *found << '\\n';\n    }\n\n    return 0;\n}\n\n\nType of a lambda\nLike in the above example, we defined lambda right where it was needed; we called this function literal.\nWe can make the code clearer by initializing a lambda variable with a lambda definition and then use it later.\nHere is an example for lambda variable named l_found:\n\nauto l_found\n{\n    [](std::string_view str)\n    {\n        return (str.find(\"nut\") != std::string_view::npos);\n    }\n};\n\n#// Then we use it in function `find_if`\nconst auto found{ std::find_if(arr.begin(), arr.end(), l_found) };\n\nLambda does not have a type that we can explicitly use. Lambda is not a function (to avoid the limitation of C++ not supporting nested functions). Lambda is a special kind of object called functor, with an overloaded operator() callable like a function.\nIf the capture clause is empty, we can use normal function pointer, std::function or type deduction auto (from C++20) to define lambda variable. Here is an example:\n\n#include <functional>\n#include <iostream>\n\nint main()\n{\n    std::function add_number\n    {\n        [](double a, double b)\n        {\n            return a + b;\n        }\n    };\n\n    add_number(2, 3);\n\n    auto add_number2{\n        [](double a, double b) {\n            return a + b;\n        }\n    };\n\n    add_number2(5, 6);\n}\n\nIn cases, we pass lambda to a function’s parameter, we define the function parameter by std::function which works with regular functions and lambdas:\n\nvoid repeat(int repetitions, const std::function<void(int)>& fn)\n{\n    for (int i{ 0 }; i < repetitions; ++i)\n    {\n        fn(i);\n    }\n}\n\nint main()\n{\n    auto l_print{\n        [](int i) {\n            std::cout << i << '\\n';\n        }\n    };\n    \n    repeat(5, [](int i) {\n        std::cout << i << '\\n';\n        });\n\n    repeat(2, l_print); #// From C++20\n\n    return 0;\n}\n\n\n\n\n\n\n\nWhen storing a lambda in a variable, use auto.\nWhen passing a lambda to a function:\n\nIf C++20, use auto as parameter’s type\nOtherwise, use std::function.\n\n\n\n\n\n\nGeneric lambdas\nWe can use auto keyword for the parameters in the lambda. This is call generic lambdas.\n\nReturn type deduction and trailing return types\nIf in lambda, we call return keyword more than one times and the return types are different. It is better to explicitly specify return type for the lambda.\nHere is an example from using lambdas:\n\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <string_view>\n\nstruct Season \n{\n    std::string_view name{};\n    double averageTemperature{};\n};\n\nint main()\n{\n    std::array<Season, 4> seasons{\n        {\n            { \"Spring\", 285.0 },\n            { \"Summer\", 296.0 },\n            { \"Fall\", 288.0 },\n            { \"Winter\", 263.0 }\n        }\n    };\n\n    std::sort(seasons.begin(), seasons.end(),\n        [](Season& a, Season& b) {\n            return a.averageTemperature < b.averageTemperature;\n        });\n\n    for (const auto& season : seasons)\n    {\n        std::cout << season.name << '\\n';\n    }\n}"
  },
  {
    "objectID": "c12_function.html#type-of-a-lambda",
    "href": "c12_function.html#type-of-a-lambda",
    "title": "13  Function",
    "section": "13.8 Type of a lambda",
    "text": "13.8 Type of a lambda\nLike in the above example, we defined lambda right where it was needed; we called this function literal.\nWe can make the code clearer by initializing a lambda variable with a lambda definition and then use it later.\nHere is an example for lambda variable named l_found:\n\nauto l_found\n{\n    [](std::string_view str)\n    {\n        return (str.find(\"nut\") != std::string_view::npos);\n    }\n};\n\n#// Then we use it in function `find_if`\nconst auto found{ std::find_if(arr.begin(), arr.end(), l_found) };\n\nLambda does not have a type that we can explicitly use. Lambda is not a function (to avoid the limitation of C++ not supporting nested functions). Lambda is a special kind of object called functor, with an overloaded operator() callable like a function.\nIf the capture clause is empty, we can use normal function pointer, std::function or type deduction auto (from C++20) to define lambda variable. Here is an example:\n\n#include <functional>\n#include <iostream>\n\nint main()\n{\n    std::function add_number\n    {\n        [](double a, double b)\n        {\n            return a + b;\n        }\n    };\n\n    add_number(2, 3);\n\n    auto add_number2{\n        [](double a, double b) {\n            return a + b;\n        }\n    };\n\n    add_number2(5, 6);\n}\n\nIn cases, we pass lambda to a function’s parameter, we define the function parameter by std::function which works with regular functions and lambdas:\n\nvoid repeat(int repetitions, const std::function<void(int)>& fn)\n{\n    for (int i{ 0 }; i < repetitions; ++i)\n    {\n        fn(i);\n    }\n}\n\nint main()\n{\n    auto l_print{\n        [](int i) {\n            std::cout << i << '\\n';\n        }\n    };\n    \n    repeat(5, [](int i) {\n        std::cout << i << '\\n';\n        });\n\n    repeat(2, l_print); #// From C++20\n\n    return 0;\n}\n\n\n\n\n\n\n\nWhen storing a lambda in a variable, use auto.\nWhen passing a lambda to a function:\n\nIf C++20, use auto as parameter’s type\nOtherwise, use std::function.\n\n\n\n\n\nGeneric lambdas\nWe can use auto keyword for the parameters in the lambda. This is call generic lambdas.\n\nReturn type deduction and trailing return types\nIf in lambda, we call return keyword more than one times and the return types are different. It is better to explicitly specify return type for the lambda.\nHere is an example from using lambdas:\n\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <string_view>\n\nstruct Season \n{\n    std::string_view name{};\n    double averageTemperature{};\n};\n\nint main()\n{\n    std::array<Season, 4> seasons{\n        {\n            { \"Spring\", 285.0 },\n            { \"Summer\", 296.0 },\n            { \"Fall\", 288.0 },\n            { \"Winter\", 263.0 }\n        }\n    };\n\n    std::sort(seasons.begin(), seasons.end(),\n        [](Season& a, Season& b) {\n            return a.averageTemperature < b.averageTemperature;\n        });\n\n    for (const auto& season : seasons)\n    {\n        std::cout << season.name << '\\n';\n    }\n}"
  },
  {
    "objectID": "c12_function.html#lambda-capture",
    "href": "c12_function.html#lambda-capture",
    "title": "13  Function",
    "section": "13.8 Lambda capture",
    "text": "13.8 Lambda capture\nIf we want a program that allows user to give a string to search for, this variable is known at the run-time, not compile time.\nThe nested block can access variables in the outer blocks, but lambda can only access variables either global identifiers, or known at the compile time. Thus, we cannot write this program without using capture clause.\n\nCapture clause\nThis gives a lambda access to variables available in the surrounding scope that it normally would not have access to. Here is the code:\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <array>\n#include <string_view>\n\nint main()\n{\n    std::array<std::string_view, 4> arr{ \"apple\", \"banana\", \"walnut\", \"lemon\" };\n\n    std::cout << \"Search for: \";\n\n    std::string search{};\n    std::cin >> search;\n\n    auto found{ std::find_if(arr.begin(), arr.end(), [search](std::string_view str) {\n        return (str.find(search) != std::string_view::npos);\n    })\n    };\n\n    if (found == arr.end())\n    {\n        std::cout << \"Not found\\n\";\n    }\n    else\n    {\n        std::cout << \"Found \" << *found << '\\n';\n    }\n\n    return 0;\n}\n\nThe capture variables are clones of the outer scope variables, not actual variables. It may not have the same type as the original variable.\nWhen lambda captures, it captures const value. It cannot modify the capture variables; if we do that inside lambda, there is compile error.\n\n#include <iostream>\n\nint main()\n{\n  int ammo{ 10 };\n\n  #// Define a lambda and store it in a variable called \"shoot\".\n  auto shoot{\n    [ammo]() {\n      #// Illegal, ammo was captured as a const copy.\n      --ammo;\n\n      std::cout << \"Pew! \" << ammo << \" shot(s) left.\\n\";\n    }\n  };\n\n  #// Call the lambda\n  shoot();\n\n  std::cout << ammo << \" shot(s) left\\n\";\n\n  return 0;\n}\n\nIf we want to modify the captures, we have to use keyword mutable:\n\n#include <iostream>\n\nint main()\n{\n    int amo{ 10 };\n\n    auto shoot{\n        [amo]() mutable {\n            --amo;\n\n            std::cout << \"Pew!\" << amo << \" shot(s) left.\\n\";\n        }\n    };\n\n    shoot();\n    shoot();\n\n    std::cout << amo << \" outer\\n\";\n\n    return 0;\n}\n\n#> 9\n#> 8\n#> 10\n\n\n\n\n\n\n\nRemember that, captures is a copy of original ones, thus we just changed copier’s value inside lambda, the original does not change.\nSecondly, capture is a member of lambda object, so its value are persisted across multiple calls to the lambda!\n\n\n\n\n\nCapture by reference\nLike normal variable, we can capture by reference using &; we prefer this whenever we capture non-fundamental data types. We modify the code above for reference to amo:\n\n#include <iostream>\n\nint main()\n{\n    int amo{ 10 };\n\n    auto shoot{\n        [&amo]() {\n            --amo;\n\n            std::cout << \"Pew!\" << amo << \" shot(s) left.\\n\";\n        }\n    };\n\n    shoot();\n    shoot();\n\n    std::cout << amo << \" outer\\n\";\n\n    return 0;\n}\n\n#> 9\n#> 8\n#> 8\n\nHere is another example:\n\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <string>\n\nstruct Car\n{\n    std::string make{};\n    std::string model{};\n};\n\nint main()\n{\n    std::array<Car, 3> cars{\n        {\n            { \"Volkswagen\", \"Golf\" },\n            { \"Toyota\", \"Corolla\" },\n            { \"Honda\", \"Civic\" }\n        }\n    };\n\n    int comparision{ 0 };\n\n    std::sort(cars.begin(), cars.end(),\n        [&comparision](const Car& a, const Car& b) {\n            \n            ++comparision;\n\n            return a.make < b.make;\n        }\n    );\n\n    std::cout << \"Comparisions: \" << comparision << '\\n';\n\n    for (const auto& car : cars)\n        std::cout << car.make << ' ' << car.model << '\\n';\n\n    std::cout << '\\n';\n\n    return 0;\n}\n\nWe can capture multiple variables by using commas ,.\n\n\nDefault capture\nA default capture captures all variables that are mentioned inside lambda.\n\nTo capture all used variables by value, we use =.\nTo capture all used variables by reference, we use &.\nWe can mixed normal capture and default capture. But put default capture before normal one\n\nThe code below is an example:\n\n#include <iostream>\n#include <array>\n\nint main()\n{\n    std::array areas{ 100, 25, 121, 40, 56 };\n\n    int width{};\n    int heigth{};\n\n    std::cout << \"Enter width and height: \";\n    std::cin >> width >> heigth;\n\n    auto found{ std::find_if(areas.begin(), areas.end(),\n        [=](int known_area) { // will default capture width and heigth by value\n            return (width * heigth == known_area);\n        })\n    };\n\n    if (found == areas.end())\n        std::cout << \"Cannot found.\\n\";\n    else\n        std::cout << \"Area found.\\n\";\n\n    return 0;\n}\n\nHere is the mixing rules:\n\nint health{ 33 };\nint armor{ 100 };\nstd::vector<CEnemy> enemies{};\n\n#// Capture health and armor by value, and enemies by reference.\n[health, armor, &enemies](){};\n\n#// Capture enemies by reference and everything else by value.\n[=, &enemies](){};\n\n#// Capture armor by value and everything else by reference.\n[&, armor](){};\n\n#// Illegal, we already said we want to capture everything by reference.\n[&, &armor](){};\n\n#// Illegal, we already said we want to capture everything by value.\n[=, armor](){};\n\n#// Illegal, armor appears twice.\n[armor, &health, &armor](){};\n\n#// Illegal, the default capture has to be the first element in the capture group.\n[armor, &](){};\n\nWe can define a new variable inside the capture. This variable is only visible to the lambda. Only define if its value is short and their type is obvious, otherwise, best to define outside of the lambda and capture it.\n\n\n\n\n\n\nBe extra careful when you capture variables by reference, especially with a default reference capture. The captured variables must outlive the lambda.\n\n\n\n\n\nUnintended copies of mutable lambdas\nLambda is an object, it can be copied; this property sometimes causes problems.\nLet look at the following example to see the unexpected results:\n\n#include <iostream>\n\nint main()\n{\n    int i{ 0 };\n\n    auto count{ [i]() mutable {\n        std::cout << ++i << '\\n';\n        }\n    };\n\n    count();\n\n    auto otherCount{ count };\n\n    count();\n    otherCount();\n\n    return 0;\n}\n#> 1\n#> 2\n#> 2\n\nWe expect that the results are 1, 2, 3. otherCount() copied the functor/object count which is initialized as 1. Then, we called the functor otherCount(), it printed 2.\nThe problem persists to the function pointer parameters created with std::function from functional Here is an example:\n\nvoid my_invoke(const std::function<void()>& fn)\n{\n    fn();\n}\n\nint main()\n{\n    int i{ 0 };\n\n    auto count{ [i]() mutable {\n        std::cout << ++i << '\\n';\n        }\n    };\n\n    my_invoke(count);\n    my_invoke(count);\n    my_invoke(count);\n\n    return 0;\n}\n\n#> 1\n#> 1\n#> 1\n\nTo prevent this happen, we need to prevent the copy behavior of std::function and pass as reference to the lambda by using std::ref() function to wrap lambda in a std::reference_wrapper type. That will make std::function copy the reference rather than the actual object.\nHere is the new code with expected results:\n\n#include <iostream>\n#include <functional>\n\nvoid my_invoke(const std::function<void()>& fn)\n{\n    fn();\n}\n\nint main()\n{\n    int i{ 0 };\n\n    auto count{ [i]() mutable {\n        std::cout << ++i << '\\n';\n        }\n    };\n\n    my_invoke(std::ref(count));\n    my_invoke(std::ref(count));\n    my_invoke(std::ref(count));\n\n    return 0;\n}\n\n#> 1\n#> 2\n#> 3\n\n\n\n\n\n\n\n\nStandard library functions may copy function objects (reminder: lambdas are function objects). If you want to provide lambdas with mutable captured variables, pass them by reference using std::ref().\nTry to avoid mutable lambdas. Non-mutable lambdas are easier to understand and don’t suffer from the above issues, as well as more dangerous issues that arise when you add parallel execution."
  }
]