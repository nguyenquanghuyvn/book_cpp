{
  "hash": "6df75b77329262b123a568b39f26fd51",
  "result": {
    "markdown": "---\ntitle: \"Function\"\n---\n\n\n## Function pointers\n\nLet consider the following function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint foo()\n{\n\treturn 5;\n}\n\nint main()\n{\n\tstd::cout << foo << '\\n';   #// print function's address\n    \n    std::cout << reinterpret_cast<void*>(foo) << '\\n'\n    #// force the compiler print function's address\n\n\treturn 0;\n}\n\n#> 00009F3CB\n```\n:::\n\n\nIdentifer `foo` is the function's name. It has its own `l-value` function type which is function that return an `int` and takes no parameters.\n\nLike a variable, system **assigns an address to a function**. \n\nWhen we use the `operator()`, the program jumps to an address of called function to execute. If we send a function without calling it (omit the operator`()`) to `std::cout`, we get function's address instead. We added an example to the chunk `foo` above.\n\n#### Pointers to functions\nHere is a code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint (*fcnPtr)()\n\n#// this is a pointer to a function that takes no parameter and return an integer\n#// remember to put in parentheses\n\n\nint (*const fcnPtr)();\n#// const function pointer\n```\n:::\n\n\n#### Assigning a function to a function pointer\n\nFunction pointers can be initialized with a function (a non-const function pointer can be assgined a function).\n\nThe pointer function has to same return type and parameters with the function pointed. Here is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint foo()\n{\n\treturn 5;\n}\n\ndouble goo()\n{\n\treturn 6.0;\n}\n\nint hoo(int x)\n{\n\treturn x;\n}\n\nint main()\n{\n\tstd::cout << foo << '\\n';\n\n\tint (*f_ptr1)() { &foo };\n\tdouble (*f_ptr2)() { &goo };\n\tint (*f_ptr3)(int) { &hoo };\n    \n    #// C++ implicitly convert a function into a function pointer\n    int (*f_ptr4)(){foo};   #// do not need use \"&\"\n\n\treturn 0;\n}\n```\n:::\n\n\nFunction pointers can also be initialzed or assgined to `nullptr`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint (*fcnptr)() {nullptr};\n```\n:::\n\n\n#### Calling a function using a function pointer\n\nThere are two ways: explicit dereference and implicit dereference. Here is the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#// Explicitly:\n(*f_ptr3)(5);\n\n#// Implicitly:\nf_ptr3(5);\n```\n:::\n\n\n**Note:** the default parameter cannot work with function call by a pointer. Because default parameter is evaluated at compile-time, while function pointers are at run-time. We need to explicitly give the value to the function pointers.\n\n### Passing functions as arguments to other functions\n\nWe can **pass a function as an argument of other function**, that arguments is **callback functions**.\n\nWith this, we can make a function more flexible by letting user's put their function. An example for this is the *sorting function*.\n\nWe write a sorting program that allow the users to sort the list ascending or descending. This function use a function as its parameter; the callback function work on how to sort the list by varying the comparison between two elements.\n\nThis is a code that does not use the function pointer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <utility>\n\nbool ascending(int x, int y)\n{\n\treturn x > y;\n}\n\nvoid selection_sort( int* array, int size )\n{\n\tfor (int start_index{ 0 }; start_index < size - 1; ++start_index)\n\t{\n\t\tint smallest_index{ start_index };\n\n\t\tfor (int current_index{ start_index + 1 }; current_index < size; ++current_index)\n\t\t{\n\t\t\tif (ascending(array[smallest_index], array[current_index]))\n\t\t\t\tsmallest_index = current_index;\n\t\t}\n\n\t\tstd::swap(array[start_index], array[smallest_index]);\n\t}\n}\n```\n:::\n\n\nWe want the caller decide how the sorting will be done, we can use the function pointer. In the above code, the comparison returns a boolean object, thus we create a pointer to a boolean function that takes two `int` parameters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbool (*compare_fcn)(int, int)\n```\n:::\n\nThus we rewrite the code as:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <utility>  #\\\\ using the `std::swap`\n\nbool ascending(int x, int y)\n{\n\treturn x > y;\n}\n\nbool descending(int x, int y)\n{\n\treturn x < y;\n}\n\n#// We can add many customization function:\nbool even_first(int x, int y)\n{\n\tif ((x % 2 == 0) && !(y % 2 == 0))\n\t\treturn false;\n\tif (!(x % 2 == 0) && (y % 2 == 0))\n\t\treturn true;\n\n\treturn ascending(x, y);\n}\n\nvoid selection_sort( int* array, int size, bool (*compare_fcn)(int, int))\n{\n\tfor (int start_index{ 0 }; start_index < size - 1; ++start_index)\n\t{\n\t\tint smallest_index{ start_index };\n\n\t\tfor (int current_index{ start_index + 1 }; current_index < size; ++current_index)\n\t\t{\n\t\t\tif (compare_fcn(array[smallest_index], array[current_index]))\n\t\t\t\tsmallest_index = current_index;\n\t\t}\n\n\t\tstd::swap(array[start_index], array[smallest_index]);\n\t}\n}\n\nint main()\n{\n\tint array[11]{ 3, 7, 0 ,5 ,8, 9 ,10, 2, 15, 20, 15 };\n\n\tselection_sort(array, 11, ascending);\n\tprint(array, 11);\n\n\tselection_sort(array, 11, descending);\n\tprint(array, 11);\n\n\tselection_sort(array, 11, even_first);\n\tprint(array, 11);\n\n\treturn 0;\n}\n```\n:::\n\n\nWe can provide **default functions** to a function pointer parameter:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid selection_sort( int* array, int size, bool (*compare_fcn)(int, int) = ascending);\n```\n:::\n\n\nWe can make function pointer prettier with type aliases:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#// Name alias for function pointer type\nusing Validate_fcn = bool(*)(int, int);\n\n#// The the sorting function is rewrite as:\nvoid selection_sort( int* array, int size, Validate_fcn pfcn = ascending);\n```\n:::\n\n\n### Using `std::function`\n\nWe use `std::function` from header `functional` header like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <functional>\n\nstd::function<bool(int, int) > fcnPtr{};\nfcnPtr = &ascending;\n\n#// Using alias name for clear code\nusing validate_fcn = std::function<bool(int, int)>;\n```\n:::\n\n\nWe only use implicit dereference with `std::function`.\n\nFrom C++17, compiler can deduce the return type and parameter of pointer function from pointed function initializer. But, this does not work with *type alias*.\n\nWe can use keyword `auto` with function pointer, but this is not recommended because we easily make mistakes.\n\n### Exercsise\n\nHere is the full code of the exercise for this session:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\n#include <functional>\n#include <cassert>\n#include <iostream>\n\nstruct Inputs\n{\n\tint first{};\n\tint second{};\n\tchar op{};\n};\n\nint get_integer()\n{\n\tint x{};\n\tstd::cin >> x;\n\n\twhile (std::cin.fail())\n\t{\n\t\tstd::cin.clear();\n\t\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n\t\tstd::cout \n\t\t\t<< \"Invalid integer. \"\n\t\t\t<< \"Please enter again your integer: \";\n\t\tstd::cin >> x;\n\t}\n\n\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n\treturn x;\n}\nauto get_operator()\n{\n\tchar op{};\n\tdo\n\t{\n\t\tstd::cout << \"Please enter your operators ( +, -, *, /): \";\n\t\tstd::cin >> op;\n\t} while (op != '+' && op != '-' && op != '*' && op != '/');\n\n\treturn op;\n}\n```\n:::\n\n \n Then, we create a function to take the operator:\n \n\n::: {.cell}\n\n```{.r .cell-code}\nauto add(int x, int y)\n{\n\treturn x + y;\n}\n\nauto substract(int x, int y)\n{\n\treturn x - y;\n}\n\nauto multiply(int x, int y)\n{\n\treturn x * y;\n}\n\nauto divide(int x, int y)\n{\n\tassert(y != 0 && \"Cannot devide by zero! Return error.\");\n\t\n\treturn x / y;\n}\n```\n:::\n\n \n Create a pointer function to get the arithmetic function:\n \n\n::: {.cell}\n\n```{.r .cell-code}\nusing Arithmetic_fcn = std::function<int(int, int)>;\n\nArithmetic_fcn get_arithmetic_fcn(char op)\n{\n\tswitch (op)\n\t{\n\tcase '+':\n\t\treturn &add;\n\tcase '-':\n\t\treturn &substract;\n\tcase '*':\n\t\treturn  &multiply;\n\tcase '/':\n\t\treturn &divide;\n\tdefault:\n\t\treturn nullptr;\n\t}\n}\n\nint main()\n{\n\tstd::cout << \"Please enter your first integer: \";\n\tauto first{ get_integer() };\n\n\tstd::cout << \"Please enter your second integer: \";\n\tauto second{ get_integer() };\n\n\tstd::cout << \"Please enter your operator: \";\n\tauto op{ get_operator() };\n\n\tArithmetic_fcn fcn{ get_arithmetic_fcn(op) };\n\n\tif (fcn)\n\t{\n\t\tstd::cout\n\t\t\t<< first << ' ' << op << ' ' << second << \" = \"\n\t\t\t<< fcn(first, second) << '\\n';\n\t}\n\telse\n\t{\n\t\tstd::cout << \"Error: cannot execute your request.\\n\";\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n \n\n## The stack and the heap\n\n### The heap segment\n\n**Heap segment** (also called \"free store\") keeps track of memory used for *dynamic memory allocation*.\n\nIn C, using `new` operator results in the allocation in *heap segment*. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nint* ptr{new int};\nint* array{new int[10]}\n```\n:::\n\nSubsequent call the memory allocation, does not guarantee sequential memory address. For example, `ptr` and `array` may not have sequential addresses.\n\nThe heap has advantage and disadvantages:\n\n:::{layout-ncol=2}\n\n#### Avantages\n\n- Do not need to assign size at the compile time\n- Large arrays, structures, or classes can be allocated there.\n\n#### Disavantages\n\n- Comparatively slow\n- Need to be deallocated or application ends\n- Must be accessed through a pointer\n\n:::\n\n### The call stack\n\nThe **call stack** keeps track of all the active functions from the start of the program to the current point of execution, and handles allocation of all function parameters and local variables.\n\nIt is a *stack data structure*.\n\n#### The stack data structure\n\nA **data structure** is a programming mechanism for organizing data so that it can be used efficiently.\n\nExample of data structure is arrays and structs. And **stack** is one of these.\n\nLet image stack as a stack of plates. In computer programming, a stack contains multiple variables (much like an array). A stack is more limited that we can not access and modify as we wish. We only perform on stack three things:\n\n1. Look at the top item on the stack: `top()` or sometimes `peek()`.\n2. Take the top item off of the stack: `pop()`.\n3. Put a new item on top of the stack: `push()`.\n\nA stack is \"last-in, first-out\". Let use an analogy: mailboxes. Each mailbox holds one item, they are stacked together. Each mailbox nails to the mailbox below, so the number of mailboxes cannot be changed.\n\nWe use a *marker* to keep track of where the bottom-most empty mailbox is. When we push an item onto our mailbox stack, we put in the mailbox that is marked, and move the marker up on mailbox; when we pop an item off, we move the *marker* down one mailbox\n\nAnything below the mailbox is **on the stack**; anything at the marker or above the marker is **not on the stack**.\n\nWhen program encounter a function call, it pushes the function onto the call stack. When a function ends, function is popped off the call stack. We see all of the functions that were called to get to the current point of execution.\n\nThe stack itself is a fixed-sized chunk of memory addresses. The mailboxes are memory addresses, and the items pushing or popping out on the stack are call **stack frame**.\n\nA stack frame keeps track of all of data associated with one function call. The \"marker\" is a register as a the stack pointer.\n\n#### The call stack in action\n\nWhen a function is called:\n\n1. The program encounters a function call\n2. A **stack frame** is constructed and pushed on the stack. The stack frame consists of:\n    * **Return address**: the address of the instruction where to return after the called function exits.\n    * All functions arguments\n    * Memory fo any local variables\n    * Saved copies of any registers modified by the function that need to be restored when the function returns.\n\n3. The CPU jumps to the function's start point\n4. The instructions inside of the function begin executing.\n\nWhen the function terminates:\n\n5. Registers are restored from the call stack\n6. The stack frame is popped off the stack (free local variables, arguments).\n7. The return value is handled\n8. The CPU resumes executions at the return address.\n\n#### Stack overflow\n\n**Stack overflow** happens when all the memory in the stack has been allocated.\n\n## `std::vector` capacity and stack behavior\n\n`std::vector` is a dynamic array that both remembers its length and be resized as required. This array has another attribute, it is **capacity**: how many elements were allocated in memory; **length** is how many elements are being used in the array.\n\nLook at the code below to see the difference between **length** and **capacity**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <vector>\n#include <iostream>\n\nint main()\n{\n\tstd::vector<int> array{};\n\tarray = { 0, 1, 2, 3, 4, 5 };\t// array of length 5\n\tstd::cout\n\t\t<< \"Length :\" << array.size()\n\t\t<< \". Capacity: \" << array.capacity() << '\\n';\n\n\tarray = { 9, 8, 7 };\n\tstd::cout\n\t\t<< \"Length :\" << array.size()\n\t\t<< \". Capacity: \" << array.capacity() << '\\n';\n\n\treturn 0;\n}\n#> Length: 6. Capacity: 6\n#> Length: 3. Capacity: 6\n```\n:::\n\n\nNotice that range for subscript operator(`[]`) and `at()` is from vector's length, not the capacity.\n\n### Stack behavior with `std::vector`\n\n`std::vector` can also be used as a stack with 3 functions:\n\n* `push_back()`: pushes an element on the stack\n* `back()`: returns the value of the top element on the stack\n* `pop_back()`: pops an element off the stack\n\nUnlike the array subscript or  `at()`, the stack-based function resizes the `std::vector` if necessary. But, resizing is expensive. We avoid by allocating a certain amount of **capacity up front** using the function `reserve()` function.\n\nHere is a code for the above ideas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <vector>\n#include <iostream>\n\nvoid print_stack(const std::vector<int>& stack)\n{\n\tfor (auto element : stack)\n\t\tstd::cout << element << ' ';\n\tstd::cout \n\t\t<< \"(cap \" << stack.capacity() \n\t\t<< \" length \" << stack.size() << \")\\n\";\n}\n\nint main()\n{\n\t\n\tstd::vector<int> stack{};\n\tstack.reserve(5);\n\n\tprint_stack(stack);\n\n\tstack.push_back(5);\n\tprint_stack(stack);\n\n\tstack.push_back(4);\n\tprint_stack(stack);\n\n\tstack.push_back(3);\n\tprint_stack(stack);\n\n\tstd::cout << \"top: \" << stack.back() << '\\n';\n\n\tstack.pop_back();\n\tprint_stack(stack);\n\n\tstack.pop_back();\n\tprint_stack(stack);\n\n\treturn 0;\n}\n```\n:::\n\n\nWhen vector resizes, it may allocate more capacity than needed; this is called \"breathing room\". For example, when we use the `push_back()` another element, it would not need to resize immediately.\n\n\n## Recursion\n\nA **recursion function** in C++ is a function that calls itself. It works like a normal function, but we must include a **recursive termination condition**, or they will run \"forever\".\n\nA **recursive termination** is condition that, when met, will cause the recursive function to stop calling itself. We usually use the `if statement`.\n\nHere is the example code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid count_down(int count)\n{\n\tstd::cout << \"push \" << count << '\\n';\n\n\tif (count > 1)\n\t\tcount_down(count - 1);\n\n\tstd::cout << \"pop: \" << count << '\\n';\n}\n\nint main()\n{\n\tcount_down(5);\n\n\treturn 0;\n}\n\n#> push 5\n#> push 4\n#> push 3\n#> push 2\n#> push 1\n#> pop 1\n#> pop 2\n#> pop 3\n#> pop 4\n#> pop 5\n```\n:::\n\n\nHere is another example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nauto sum_to(int sumto)\n{\n\tif (sumto <= 0)\n\t\treturn 0;\n\t\n\tif (sumto == 1)\n\t\treturn 1;\n\n\treturn sum_to(sumto - 1) + sumto;\n}\n```\n:::\n\n\nRecursion uses to catch the fibonacci numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nauto fibonacci(int count)\n{\n\tif (count == 0)\n\t\treturn 0;\n\tif (count == 1)\n\t\treturn 1;\n\n\treturn fibonacci(count - 1) + fibonacci(count - 2);\n}\n```\n:::\n\n\nThe above code call too many functions, so it is inefficiently. One technique called, **memorization**, caches the results of expensive function calls so the results can be returned when the same input occurs again:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint fibonacci_memo(int count)\n{\n\tstatic std::vector results{ 0, 1 };\n\n\tif (count < static_cast<int>(std::size(results)))\n\t\treturn results[count];\n\n\tresults.push_back(fibonacci_memo(count - 1) + fibonacci(count - 2));\n\n\treturn results[count];\n}\n\nint main()\n{\n\tfor (int count{ 0 }; count < 15; ++count)\n\t\tstd::cout << fibonacci_memo(count) << ' ';\n\tstd::cout << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nThe recursion is a good choice when most of following are true:\n\n* The code is much simpler to implement\n* The recursion depth can be limited\n* The iterative version of the algorithm requires managing stack of data\n* This is not a performance-critical section of code\n\n\n\n## Command line arguments\n\nWhen a program is run, execution starts at the top of the function `main()`. We have seen that `main()` takes no parameters. However, some programs need parameters to run.\n\n**Command line arguments** are optional string arguments that are passed by the operating system to the program when it is launched. The program can use them as inputs or ignore them.\n\nMuck like function parameters provide a way for a function to provide inputs to another functions, command line arguments provide a way for people or programs to provide inputs to a program.\n\n### Using command line arguments\n\nAfter providing the command line arguments, we can access them from C++ program. We define a new form of `main()` such as\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main(int argc, char* argv[])\n```\n:::\n\n\n* **argc** is an integer containing the count of the number of arguments passed to the program.\n* **argv** is where the actual argument values are stored as an array of C-style strings, the length of array is `argc`.\n\nHere is a simple program use the command line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main(int argc, char* argv[])\n{\n\tstd::cout << \"There are \" << argc << \" arguments:\\n\";\n\n\tfor (int count{ 0 }; count << argc; ++count)\n\t{\n\t\tstd::cout << count << ' ' << argv[count] << '\\n';\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n\nThe command line arguments are as strings, if we want to use them as numeric type, we need to cover it.\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#// Program: MyArgs\n#include <sstream>\t\t// use std::stringstream\n#include <string>\n#include <iostream>\n\nint main(int argc, char* argv[])\n{\n\tstd::cout << \"There are \" << argc << \" arguments:\\n\";\n\n\tif (argc <= 1)\n\t{\n\t\tif (argv[0])\n\t\t{\n\t\t\tstd::cout << \"Usage: \" << argv[0] << \"<number>\" << '\\n';\n\t\t}\n\t\telse\n\t\t\tstd::cout << \"Usage: <program name> <number>\" << '\\n';\n\t\treturn 1;\n\t}\n\n\tstd::stringstream covert{ argv[1] };\n\n\tint my_int{};\n\tif (!(covert >> my_int))\n\t\tmy_int = 0;\n\n\tstd::cout << \"Got integer: \" << my_int << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n## Ellisis (and why to avoid them)\n\nThe number of function's parameters must be known in advance. But, some cases where it can be useful to be able to pass a variable number of parameters. C++ provide a special specifier known as ellipsis `...` to do it precisely.\n\nThe authors recommended avoid using ellipsis.\n\nHere is a way to declare:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreturn_type function_name(parameter_list, ...)\n```\n:::\n\n\nThe ellipsis captures additional arguments and it like an array that contains the parameters\n\n### An ellipsis example\n\nWe write a program to return an average of a list of integer.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <cstdarg>\t// use ellipsis: std::va_list, va_start, va_arg, va_end\n#include <iostream>\n\nauto mean(int count, ...)\n{\n\tint sum{ 0 };\n\n\tstd::va_list list;\n\t\n\tva_start(list, count);\n\n\tfor (int i{ 0 }; i < count; ++i)\n\t{\n\t\tsum += va_arg(list, int);\t#// va_arg: point to the next arg in list\n\t}\n\n\tva_end(list);\n\n\treturn static_cast<double>(sum) / count;\n}\n\nint main()\n{\n\tstd::cout << \"mean: \" << mean(5, 1, 2, 3, 4, 5) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n### Why using ellipsis is dangerous\n\n* Type checking on the parameters is suspended. In some cases, our program will just produce garbage or crash.\n* Ellipsis don't know how many parameters were passed. Thus, to keep track of parameters' numbers, there are three ways:\n    \n    - Method 1: Pass a length parameter like above example\n    - Method 2: use a sentinel value. A *sentinel* value terminates a loop when it is encountered such as `\\0` for string. For ellipsis,the sentinel is passed in as the last parameter.For example, we assign `-1` to the last parameter in ellipsis:\n    \n\n::: {.cell}\n\n```{.r .cell-code}\n#include <cstdarg>\t// use ellipsis: std::va_list, va_start, va_arg, va_end\n#include <iostream>\n\nauto mean(int first, ...)\n{\n\tint sum{ first };\n\n\tstd::va_list list;\n\t\n\tva_start(list, first);\n\t\n\tint count{ 1 };\n\n\twhile (true)\n\t{\n\t\tint arg{ va_arg(list, int) };\n\n\t\tif (arg == -1)\n\t\t\tbreak;\n\n\t\tsum += arg;\n\t\t++count;\n\t}\n\n\tva_end(list);\n\n\treturn static_cast<double>(sum) / count;\n}\n\nint main()\n{\n\tstd::cout << \"mean: \" << mean(1, 2, 3, 4, 5, -1) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n## Introduction to lambdas (anonymous functions)\n\n**Lambda expression** allows us to define an anonymous function inside another function. This is the structure:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n[ capture clause] (parameters) -> returnType(#//optional)\n    {\n        statements;\n    }\n```\n:::\n\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <algorithm>\n#include <array>\n#include <string_view>\n#include <iostream>\n\nint main()\n{\n\tconstexpr std::array<std::string_view, 4> arr{ \"apple\", \"banana\", \"walnut\", \"lemon\" };\n\n\tconst auto found\n\t{\n\t\tstd::find_if\n\t\t(\n\t\t\tarr.begin(), arr.end(),\n\t\t\t[](std::string_view str)\n\t\t\t{\n\t\t\t\treturn (str.find(\"nut\") != std::string_view::npos);\n\t\t\t}\n\t\t)\n\t};\n\n\tif (found == arr.end())\n\t\tstd::cout << \"Cannot found\\n\";\n\telse\n\t{\n\t\tstd::cout << \"Found \" << *found << '\\n';\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n\n### Type of a lambda\n\nLike in the above example, we defined lambda right where it was needed; we called this **function literal**.\n\nWe can make the code clearer by initializing a **lambda variable** with a **lambda definition** and then use it later. \n\nHere is an example for lambda variable named `l_found`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nauto l_found\n{\n\t[](std::string_view str)\n\t{\n\t\treturn (str.find(\"nut\") != std::string_view::npos);\n\t}\n};\n\n#// Then we use it in function `find_if`\nconst auto found{ std::find_if(arr.begin(), arr.end(), l_found) };\n```\n:::\n\n\nLambda does not have a type that we can explicitly use. Lambda is not a function (to avoid the limitation of C++ not supporting nested functions). Lambda is a special kind of object called **functor**, with an overloaded `operator()` callable like a function.\n\nIf the *capture clause* is empty, we can use normal function pointer, `std::function` or type deduction `auto` (from C++20) to define lambda variable. Here is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <functional>\n#include <iostream>\n\nint main()\n{\n\tstd::function add_number\n\t{\n\t\t[](double a, double b)\n\t\t{\n\t\t\treturn a + b;\n\t\t}\n\t};\n\n\tadd_number(2, 3);\n\n\tauto add_number2{\n\t\t[](double a, double b) {\n\t\t\treturn a + b;\n\t\t}\n\t};\n\n\tadd_number2(5, 6);\n}\n```\n:::\n\nIn cases, we pass lambda to a function's parameter, we define the function parameter by `std::function` which works with regular functions and lambdas:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid repeat(int repetitions, const std::function<void(int)>& fn)\n{\n\tfor (int i{ 0 }; i < repetitions; ++i)\n\t{\n\t\tfn(i);\n\t}\n}\n\nint main()\n{\n\tauto l_print{\n\t\t[](int i) {\n\t\t\tstd::cout << i << '\\n';\n\t\t}\n\t};\n\t\n\trepeat(5, [](int i) {\n\t\tstd::cout << i << '\\n';\n\t\t});\n\n\trepeat(2, l_print); #// From C++20\n\n\treturn 0;\n}\n```\n:::\n\n\n:::{.callout-tip}\n\nWhen storing a lambda in a variable, use `auto`.\n\nWhen passing a lambda to a function:\n\n* If C++20, use `auto` as parameter's type\n* Otherwise, use `std::function`.\n\n:::\n\n### Generic lambdas\n\nWe can use `auto` keyword for the parameters in the lambda. This is call **generic lambdas**.\n\n#### Return type deduction and trailing return types\n\nIf in lambda, we call `return` keyword more than one times and the return types are different. It is better to explicitly specify return type for the lambda.\n\nHere is an example from using **lambdas**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <string_view>\n\nstruct Season \n{\n\tstd::string_view name{};\n\tdouble averageTemperature{};\n};\n\nint main()\n{\n\tstd::array<Season, 4> seasons{\n\t\t{\n\t\t\t{ \"Spring\", 285.0 },\n\t\t\t{ \"Summer\", 296.0 },\n\t\t\t{ \"Fall\", 288.0 },\n\t\t\t{ \"Winter\", 263.0 }\n\t\t}\n\t};\n\n\tstd::sort(seasons.begin(), seasons.end(),\n\t\t[](Season& a, Season& b) {\n\t\t\treturn a.averageTemperature < b.averageTemperature;\n\t\t});\n\n\tfor (const auto& season : seasons)\n\t{\n\t\tstd::cout << season.name << '\\n';\n\t}\n}\n```\n:::\n\n\n## Lambda capture\n\nIf we want a program that allows user to give a string to search for, this variable is known at the *run-time*, not compile time.\n\nThe nested block can access variables in the outer blocks, but lambda can only access variables either global identifiers, or known at the compile time. Thus, we cannot write this program without using **capture clause**.\n\n### Capture clause\n\nThis gives a lambda access to variables available in the surrounding scope that it normally would not have access to. Here is the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <array>\n#include <string_view>\n\nint main()\n{\n\tstd::array<std::string_view, 4> arr{ \"apple\", \"banana\", \"walnut\", \"lemon\" };\n\n\tstd::cout << \"Search for: \";\n\n\tstd::string search{};\n\tstd::cin >> search;\n\n\tauto found{ std::find_if(arr.begin(), arr.end(), [search](std::string_view str) {\n\t\treturn (str.find(search) != std::string_view::npos);\n\t})\n\t};\n\n\tif (found == arr.end())\n\t{\n\t\tstd::cout << \"Not found\\n\";\n\t}\n\telse\n\t{\n\t\tstd::cout << \"Found \" << *found << '\\n';\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n\nThe capture variables are **clones** of the outer scope variables, not **actual variables**. It may not have the same type as the original variable.\n\nWhen lambda captures, it captures `const value`. It cannot modify the capture variables; if we do that inside lambda, there is compile error.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n  int ammo{ 10 };\n\n  #// Define a lambda and store it in a variable called \"shoot\".\n  auto shoot{\n    [ammo]() {\n      #// Illegal, ammo was captured as a const copy.\n      --ammo;\n\n      std::cout << \"Pew! \" << ammo << \" shot(s) left.\\n\";\n    }\n  };\n\n  #// Call the lambda\n  shoot();\n\n  std::cout << ammo << \" shot(s) left\\n\";\n\n  return 0;\n}\n```\n:::\n\n\nIf we want to modify the captures, we have to use keyword `mutable`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tint amo{ 10 };\n\n\tauto shoot{\n\t\t[amo]() mutable {\n\t\t\t--amo;\n\n\t\t\tstd::cout << \"Pew!\" << amo << \" shot(s) left.\\n\";\n\t\t}\n\t};\n\n\tshoot();\n\tshoot();\n\n\tstd::cout << amo << \" outer\\n\";\n\n\treturn 0;\n}\n\n#> 9\n#> 8\n#> 10\n```\n:::\n\n\n:::{.callout-warning}\n\nRemember that, captures is a copy of original ones, thus we just changed copier's value inside lambda, the original does not change.\n\nSecondly, capture is a member of lambda object, so its value are persisted across multiple calls to the lambda!\n\n:::\n\n### Capture by reference\n\nLike normal variable, we can capture by reference using `&`; we prefer this whenever we capture *non-fundamental data types*. We modify the code above for reference to `amo`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tint amo{ 10 };\n\n\tauto shoot{\n\t\t[&amo]() {\n\t\t\t--amo;\n\n\t\t\tstd::cout << \"Pew!\" << amo << \" shot(s) left.\\n\";\n\t\t}\n\t};\n\n\tshoot();\n\tshoot();\n\n\tstd::cout << amo << \" outer\\n\";\n\n\treturn 0;\n}\n\n#> 9\n#> 8\n#> 8\n```\n:::\n\n\n\nHere is another example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <algorithm>\n#include <array>\n#include <string>\n\nstruct Car\n{\n\tstd::string make{};\n\tstd::string model{};\n};\n\nint main()\n{\n\tstd::array<Car, 3> cars{\n\t\t{\n\t\t\t{ \"Volkswagen\", \"Golf\" },\n\t\t\t{ \"Toyota\", \"Corolla\" },\n\t\t\t{ \"Honda\", \"Civic\" }\n\t\t}\n\t};\n\n\tint comparision{ 0 };\n\n\tstd::sort(cars.begin(), cars.end(),\n\t\t[&comparision](const Car& a, const Car& b) {\n\t\t\t\n\t\t\t++comparision;\n\n\t\t\treturn a.make < b.make;\n\t\t}\n\t);\n\n\tstd::cout << \"Comparisions: \" << comparision << '\\n';\n\n\tfor (const auto& car : cars)\n\t\tstd::cout << car.make << ' ' << car.model << '\\n';\n\n\tstd::cout << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nWe can capture multiple variables by using commas `,`.\n\n### Default capture\n\nA **default capture** captures all variables that are mentioned inside lambda.\n\n* To capture all used variables by value, we use `=`.\n* To capture all used variables by reference, we use `&`.\n* We can mixed normal capture and default capture. But put default capture before normal one\n\nThe code below is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <array>\n\nint main()\n{\n\tstd::array areas{ 100, 25, 121, 40, 56 };\n\n\tint width{};\n\tint heigth{};\n\n\tstd::cout << \"Enter width and height: \";\n\tstd::cin >> width >> heigth;\n\n\tauto found{ std::find_if(areas.begin(), areas.end(),\n\t\t[=](int known_area) { // will default capture width and heigth by value\n\t\t\treturn (width * heigth == known_area);\n\t\t})\n\t};\n\n\tif (found == areas.end())\n\t\tstd::cout << \"Cannot found.\\n\";\n\telse\n\t\tstd::cout << \"Area found.\\n\";\n\n\treturn 0;\n}\n```\n:::\n\n\nHere is the mixing rules:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint health{ 33 };\nint armor{ 100 };\nstd::vector<CEnemy> enemies{};\n\n#// Capture health and armor by value, and enemies by reference.\n[health, armor, &enemies](){};\n\n#// Capture enemies by reference and everything else by value.\n[=, &enemies](){};\n\n#// Capture armor by value and everything else by reference.\n[&, armor](){};\n\n#// Illegal, we already said we want to capture everything by reference.\n[&, &armor](){};\n\n#// Illegal, we already said we want to capture everything by value.\n[=, armor](){};\n\n#// Illegal, armor appears twice.\n[armor, &health, &armor](){};\n\n#// Illegal, the default capture has to be the first element in the capture group.\n[armor, &](){};\n```\n:::\n\n\nWe can define a new variable inside the capture. This variable is only visible to the lambda. Only define if its value is short and their type is obvious, otherwise, best to define outside of the lambda and capture it.\n\n:::{.callout-warning}\n\nBe extra careful when you capture variables by reference, especially with a default reference capture. The captured variables must outlive the lambda.\n\n:::\n\n### Unintended copies of mutable lambdas\n\nLambda is an object, it can be copied; this property sometimes causes problems.\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}