{
  "hash": "f7a317282ca53e7a06413b8a19c1f318",
  "result": {
    "markdown": "# Introduction to C++\n\n## Statements {#sec-statements}\n\n**Statements** are the instructions that cause the program to *perform some actions*. Most of the statements end with *semicolon*.\n\n## Function\n\nIn C++, statements are typically grouped into units called **functions**. Function is a collection of statements that execute sequentially (in order, from top to bottom).\n\nFunctions are written to do a **specific tasks**.\n\n## Syntax and syntax error\n\n**Syntax** is the rules how the programs must be constructed in order to be considered valid. If we violate a rule, the compiler will complain and issue a **syntax error**.\n\nProgram's compilation will only complete once **all** syntax errors are resolved.\n\n## Comments\n\nA comment is a programmer-readable note inserted directly into a source code of the program (compiler ignores the comments).\n\n*Single-line comments:* `//` symbol begins a C++ single-line comment.\n\n*Multi-line comments*: `/*` and `*/` pair of symbols denotes a multi-line comment.\n\n**Proper use of comments**\n\n* Describe *what* the library, program, or functions, do. These are typically placed on the top of the file or library.\n\n* Second, inside the lib, program, or function, comments are used to describe *how* the code is going to accomplish the goal.\n\n* Third, at the *statement* level, comments can describe *why* the code is doing something. The **bad** statement comment describe *what* the code is doing.\n\nComments are good way to remind the reason a programmer made one decision instead of another.\n\n::: {.callout-tip collapse=\"false\"}\n\n### Best practice\n\nComment your code liberally, and write your comments as if speakings to someone who has *no idea* what the code does. Don't assume that you'll remember why you mad specific choices.\n\n:::\n\nYou can also *comment out* the code block if:\n\n1.  You're working on a new piece of code that won't compile yet.\n2.  You have written a new code that results the errors and you do not have time to fix it.\n3.  To find the source of the errors.\n4.  You want to replace one piece of code with another piece of code.\n\n**Summary**\n\n* At the library, program, or function level, use comments to describe *what*.\n* Inside them, use comments to describe *how*.\n* At the statement level, use comments to describe *why*.\n\n## Objects and Variables {#sec-intro_var}\n## Data\n\nIn @sec-statements, statements inside function perform actions that generate whatever result the program was designed to produce.\n\nBut, **how do programs actually produce results?**: bref, by *manipulating* data.\n\nIn computing, **data** is *any information* that can be moved, processed and stored by computer.\n\n::: {.callout-note collapse=\"false\"}\n\n#### Key insight\n\nPrograms are collections of instructions that manipulate data to produce a desired results.\n\n:::\n\nA program can acquire data to work in many ways: file, database, network, user providing input on keyboard, or from the programmer putting data directly into a source code.\n\nData on computer is typically stored in a efficient format (and thus is not human readable).\n\n### Objects and variables\n\n* A single piece of data stored in memory somewhere is called **value**.\n* An **object** is a region of storage that has a value and other associated properties. We use the object to store and retrieve values.\n* Objects can be named or unnamed. A named object is called **variable**, the name of object is call **identifier**.\n\n### Variable instantiation\n\nTo create a **variable**, we have to **define** it. Here is an example of defining a variable named x:\n\n\n::: {.cell labels='cd-var_define'}\n\n```{.r .cell-code}\nint x;\n```\n:::\n\n\nWhen the program run, it will instantiate the **variable**: object will be created and assigned a memory address. Variable must be instantiated *before* they can be used to store value.\n\n### Data types\n\nVariables are named region of storage that can store value. A **data type** tells the compiler what type of value the variable will be store.\n\n### Define multiple variables\n\nWe can define muliple variables in one statement by separating them by `,`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint a, b;\n```\n:::\n\n\nBut, variables of different types must be defined in separate statements:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint a, double b;  # false\nint a; double b;  # correct\n\n# Correct and recommended\nint a;\ndouble b;\n```\n:::\n\n\n::: {.callout-tip}\n\n#### Best practice\n\nAvoid defining multiple variables of the same type in a simple statement. Instead, define each variable in a separate statement on it own line\n\n:::\n\n## Variable assignment and initialization\n\nIn previous session @sec-intro_var, we know how to define a variable. In this session, we'll explore how to actually *put values into variables* and use those values.\n\nRecall the variable's definitions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint x;\nint y;\nint z;\n```\n:::\n\n\n### Variable assignment\n\nAfter variable has been defined, you can give it a value by using `=`, **copy assignment** or **assignment**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main() {\n  \n  int width;\n  width = 5;  // copy assignment of value 5 into variable width\n\n  width = 7;\n  \n  return 0;\n}\n```\n:::\n\n\n### Initialization\n\nWith *initialization*, we can define and assign value to variable as the same time. There are many ways to initiate:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint a;\nint a = 5;  #copy initialization\nint c( 6 )  # direct initialization\n\n# List initialization methods\nint d { 7 };\nint e = { 8 };\nint f {}\n```\n:::\n\n\n#### Default initialization\n\nWe do not provide any initialization value.\n\n#### Copy initialization\n\nWith `=`: copy the value on the right-hand side of the equals into the variable being created. It does not use much in modern C++.\n\n#### Direct initialization\n\nSimilar to copy initialization, not popular in modern C++.\n\n#### List initialization\n\nThis is the modern way to initialize. Prior to this, some types of initialization require using the direct one, and other types required indirect one. The *list initialization*  introduce to provide more consistent initialization syntax.\n\nList initialization disallows \"narrowing conversion\": return errors if we initialize a variable using a value that the variable cannot safely hold:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint width { 4.5};   # return error\n```\n:::\n\n\n::: {.callout-tip}\n\n##### Best practice\n\n* Favor list initialization whenever possible.\n* Initialize your variables upon creation.\n\n:::\n\n## Introduction to iostream: cout, cin, and endl\n\n### The input and output (io) library\n\n`io` library is part of C++ standard library that works with inpur and output. We use the functionality in  `iostream` to get *input* from keyboard and *output* data to console.\n\nWe use the library by including it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n```\n:::\n\n\n\nOne of the most useful is `std::cout`: send data to the console to be printed as text\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n  std::cout << \"Hello World!\\n\";\n  \n  return 0;\n}\n```\n:::\n\n\nIt can print a *number* too:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n  std::cout << 4;\n  \n  return 0;\n}\n```\n:::\n\n\nIt can print value of a variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n  int x{ 5 };\n  std::cout << x;\n  \n  return 0;\n}\n```\n:::\n\n\nTo print more than one thing in the same line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    std::cout << \"x is equal to \" << x;\n\n    return 0;\n}\n```\n:::\n\n\nUse `std::endl` to make the cursor in the next line.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    std::cout << \"Hi!\" << std::endl;\n    std::cout << \"My name is Huy.\" << std::endl;\n\n    return 0;\n}\n```\n:::\n\n\n::: {.callout-tip}\n\n### Best practice\n\nOutput a newline whenever a line of output is complete.\n\n:::\n\n### std::cout is buffered\n\nStatements request that output be sent to the console. However, output is typically not sent to the console immediately. Instead, the requested output *gets in line*, and is stored in a region of memory set aside to collect later, called **buffer**. Periodically, buffer is **flushed**, all data is transferred to its destination.\n\n### std::endl vs `\\n`\n\n`std::endl` move the cursor to the next line and *flushes* the buffer. Sometimes, we do not need to flush the buffer and prefer the system do it periodically. \n\nThus, use of `\\n`  is preferred instead:\n\n::: {.callout-tip}\n\n#### Best practice\n\nPrefer `\\n` over std::endl when ouputing text to the console.\n\n:::\n\n### std::cin\n\n`std::cin` reads the data from keyboard using extraction operator `>>`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter a number: \";\n    \n    int x{ };\n    std::cin >> x;\n\n    std::cout << \"You endtered: \" << x << '\\n';\n    return 0;\n}\n```\n:::\n\n\n\nWe can input many variables in the same line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter two numbers separated by a space: \";\n    \n    int x{ };\n    int y{ };\n    std::cin >> x >> y;\n\n    std::cout << \"You entered \" << x << \" and \" << y << \".\\n\";\n    std::cout << \"Thank you!\\n\";\n    return 0;\n}\n```\n:::\n\n\n\n::: {.callout-note}\n\n### Best practice\n\nInitialize variable first, then use `std::in`.\n\n:::\n\n## Uninitialized variables and undefined behavior\n\nC++ does not initialize the variable automatically. Thus, when a variable is given a memory address to use to store data, the default value of that variable is whatever value happens to already be in that memory address.\n\nLet be clear that:\n\n* Initialization = the object is given a known value at the point of definition.\n* Assignment = The object is given a known value beyond the point of definition\n* Uninitialized = The object has not been given a known value yet.\n\nIn some case, we do not know what the value printed from the following code because uninitialized `x` is given any value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    int x;\n    std::cout << x << '\\n';\n\n    return 0;\n}\n```\n:::\n\n\n\n::: {.callout-warning}\n\nUsing uninitialized is one of the most common mistakes\n\n:::\n\n### Undefined behavior\n\nUninitialized variables are one example of undefined behavoir: we cannot know the results, or they can change, be incorrect, sometime correct, or crash.\n\n## Basic formatting\n\nThe recommendations for basic formatting:\n\n1.  It fine to use either tab or spaces for indentation.\n2.  Function braces can be:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main() {\n}\n```\n:::\n\n\nor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main() \n{\n}\n```\n:::\n\n\nThe author recommended the later.\n\n3.  Each statement should start one tab from the opening space.\n4.  Line should not be too long. Typically, 80 characters is the maximum length in a line.\n5.  If line is too long, split with an operator (eg. +, -). The operator should be placed at the beginning of the next line.\n6. Use whitespaces to make the code easier to read.\n\n## Literals and operators\n\n### Literals\n\n**Literal** is a fixed value that has been inserted directly into the source code.\n\n### Operators\n\n**Operator** is the specific operation to be performed.\n\n### Return values and side effects\n\nAn operator that has some observable effect beyond producing return value is said to have a side effect. For example, `x = 5` is evaluated, side effect is to assign 5 to `x`; the changed value of `x` is observable, or `std::cout <<` too.\n\n## Expression\n\n**Expression** is a combination of literals, variables, operators, and function calls that calculates a single value.\n\nThe process of executing an expression is called **evaluation**. The single value is called **result**.\n\nExpressions do not end in a semicolon, and cannot be compiled by themselves (they must exist within a statement), example that\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint x{ 2 + 3 } ;\n```\n:::\n\n\n`2 + 3` is an expression and do not need a semicolon.\n\nExpressions also involve operators with side effects:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 5;\nx = 2 + 3;\nstd::cout << x;\n```\n:::\n\n\n### Expression statement\n\nExpression cannot compile by itself. We can add `=` to make it compile. We call this **expression statement**, an expression following by a semicolon.\n\n### Useless expression statements\n\nWe can make an expression without assigning or having any side effect, such that\n\n\n::: {.cell}\n\n```{.r .cell-code}\n2 * 3\n```\n:::\n\n\n## Developing first program\n### Multiply by 2\n\n::: {.callout-tip}\n\n#### Best practice\n\nNew programmers often try to write an entire program all at once, and then get overwhelmed when it produces a lot of errors. A better strategy is to add one piece at a time, make sure it compiles, and test it. Then when you’re sure it’s working, move on to the next piece.\n\n:::\n\nThere are many solutions, from bad to good. Let take time to find the good one (not override input value, avoid complexity).\n\n* We should firstly try to make the program work\n* Then, spend time to cleanup the code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tstd::cout << \"Enter an integer: \";\n\t\n\tint num{ };\n\tstd::cin >> num;\n\t\n\tstd::cout << \"Double \" << num << \" is: \" << num * 2 << \".\\n\";\n\tstd::cout << \"Triple \" << num << \" is: \" << num * 3 << \".\\n\";\n\n\treturn 0;\n}\n```\n:::\n",
    "supporting": [
      "C1_Introduction_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}