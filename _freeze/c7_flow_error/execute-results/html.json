{
  "hash": "d85a5a1f83e01e34609e4f36a9ce5e43",
  "result": {
    "markdown": "---\ntitle: \"Control flow and Error Handling\"\n---\n\n\nIn C++, CPU run the program from the beginning of main() function to its end. \nThis running follows a sequence called **execution path**. There are types of\npath:\n\n* **Straight-line program**: take tge same path every time they are run\n* C++ provides different **control flow statements**: allow us to change the \nnormal execution path through the program.One example of the control flow is \n`if statements`.\n* **Branching**: when control flow statement causes execution point to change\nto a non-sequential statement.\n\nFigure @fig-flow-categories below show the categories of **flow control statement**:\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Categories of flow control statements](figure/c7_flow_categories.PNG){#fig-flow-categories width=552}\n:::\n:::\n\n\n## Conditional flow control statement\n\n### If statements and blocks\n\nC++ have two kinds of conditional statement: `if statement` and `switch statement`.\n\nWe already worked with `if statement` in previous chapters, one thing to be noted\nhere is that the author recommends to use the '{}' for the statements, even if\nwe just have single statement after `if` and/or `else`.\n\n### Common `if statement` problem\n\n1. `if_statements` within other `if statements`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n\n    return 0;\n}\n```\n:::\n\n\nThe ambiguity arises when there is an `else statement`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n        \n    else std::cout << x << \" is negative\\n\"; #// else for which if?\n\n    return 0;\n}\n```\n:::\n\n\nC++ understands `else` for the last unmatched `if statement`. We should use the **block** for being clear:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n\n    int x{};\n    std::cin >> x;\n\n    if (x >= 0)\n    {\n        if (x <= 20)\n            std::cout << x << \" is between 0 and 20\\n\";\n        else std::cout << x << \" is greater than 20\\n\"; #// else for which if?\n    }\n    else\n        std::cout << x << \" is negative\\n\";\n\n    return 0;\n}\n```\n:::\n\n\nNested `if statement` can be flattened by either restructuring the logic or\nby using local operators:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    if (x < 0)\n        std::cout << x << \" is negative\\n\";\n    else if (x <= 20)\n        std::cout << x << \" is between 0 and 20\\n\";\n    else\n        std::cout << x << \" is greater than 20\";\n\n    return 0;\n}\n```\n:::\n\n\n\n### Switch statement basics\n\nThe idea behind a **switch statement** is that: an expression (condition) is\nevaluated to produce a value. If the expression's value is equal to the value\nafter any of `case labels`, the statements after the matching  `case label` are\nexecuted. If there does not have any match, `default label` are executed instead.\n\n:::{.callout-note}\n\n* One restriction: condition has to be in **integral type**.\n\n* The `case` follows by a constant expression.\n\n* If matching, first statements after `case label` start and then continues\nsequentially.\n\n:::\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n\tswitch (x)\n\t{\n\tcase 1:\n\t\tstd::cout << \"One\";\n\t\treturn;\n\tcase 2:\n\t\tstd::cout << \"Two\";\n\t\treturn;\n\tcase 3:\n\t\tstd::cout << \"Three\";\n\t\treturn;\n\tdefault:\n\t\tstd::cout << \"Unknown\";\n\t\tbreak;\n\t}\n}\n\nint main()\n{\n\tprintDigitName(2);\n\tstd::cout << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nUsing the `return` in `switch`, the program ends when there is a match or at default. We can use `break` to tell the program stop at the point matching or default and jump to the next statement next to `switch`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n\tswitch (x)\n\t{\n\tcase 1:\n\t\tstd::cout << \"One\";\n\t\tbreak;\n\tcase 2:\n\t\tstd::cout << \"Two\";\n\t\tbreak;\n\tcase 3:\n\t\tstd::cout << \"Three\";\n\t\tbreak;\n\tdefault:\n\t\tstd::cout << \"Unknown\";\n\t\tbreak;\n\t}\n\n\tstd::cout << \"\\nOut of switch!\\n\";\n}\n\nint main()\n{\n\tprintDigitName(3);\n\tstd::cout << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nWhat does the execution of `switch` when we miss `return` or `break` statement? It will continue to the next case and have unexpected result.\n\nIf we intentionally omit the end statement after the case, we can use the attribute `[[fallthrough]]`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid printDigitName(int x)\n{\n\tswitch (x)\n\t{\n\tcase 1:\n\t\tstd::cout << \"One\";\n\t\tbreak;\n\tcase 2:\n\t\tstd::cout << \"Two\";\n\t\t[[fallthrough]];\n\tcase 3:\n\t\tstd::cout << \"Three\";\n\t\tbreak;\n\tdefault:\n\t\tstd::cout << \"Unknown\";\n\t\tbreak;\n\t}\n\n\tstd::cout << \"\\nOut of switch!\\n\";\n}\n\nint main()\n{\n\tprintDigitName(2);\n\tstd::cout << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n**Sequential case labels**: we can use switch statements by placing multiple case labels in sequence:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbool isVowel(char c)\n{\n    switch (c)\n    {\n        case 'a': // if c is 'a'\n        case 'e': // or if c is 'e'\n        case 'i': // or if c is 'i'\n        case 'o': // or if c is 'o'\n        case 'u': // or if c is 'u'\n        case 'A': // or if c is 'A'\n        case 'E': // or if c is 'E'\n        case 'I': // or if c is 'I'\n        case 'O': // or if c is 'O'\n        case 'U': // or if c is 'U'\n            return true;\n        default:\n            return false;\n    }\n}\n```\n:::\n\n\nIf defining variables used in a case statement, do so in a block inside the case.\n\n## Goto statements\n\nThis is a type of unconditional jump. In C++, we use **goto statement** and the spot to jump by using **statement label**.\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <cmath>\n\nint main()\n{\n\tdouble x{};\n\tint tryTime{ 0 };\n\t\ntryHere:\n\tstd::cout << \"Enter a non-negative number: \";\n\tstd::cin >> x;\n\t\n\tif (x < 0.0 && tryTime < 5)\n\t{\n\t\t++tryTime;\n\t\tstd::cout << \"You entered a negative number.\\n\";\n\t\tgoto tryHere;\n\t}\n\t\t\n\tif (tryTime < 5)\n\t\tstd::cout << \"The square root of \" << x << \" is \" << std::sqrt(x) << '\\n';\n\telse\n\t\tstd::cout << \"You cannot enter more than 5 times. Closing program.\\n\";\n\n\treturn 0;\n}\n```\n:::\n\n\n\n:::{.callout-tip}\n\nAvoid using `goto statement`\n\n:::\n\n\n## Introduction to loops and while statements\n\nLoops are control flow statements that allow a group of code execute repeatedly *until meeting defined condition*.\n\nHere is an program that print integer number to 10:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tint count{1};\n\twhile (count <= 100)\n\t{\n\t\tstd::cout << count << ' ';\n\t\t++count;\n\t}\n\n\tstd::cout << \"done!\\n\";\n\n\treturn 0;\n}\n```\n:::\n\n\nIf the condition in `while` is always true, the program run infinitely or we have **infinite loop**.\n\n**Intentional** infinite loop: we can add the break, return, or goto statement to end the infinite loop.\n\n**Loop variable**:: to count how many times a loop has executed. This is also called **counter**\n\n**Iteration**: each time loop executes. We write a program to count from 1 to 50, each line have 10 numbers:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    int count{1};\n    while(count <= 50)\n    {\n        if (count < 10)\n        {\n            std::cout << '0';\n        }\n        \n        std::cout << count << ' ';\n        \n        if (count % 10 == 0)\n        {\n            std::cout << '\\n';\n        }\n        \n        ++count;\n    }\n    \n    return 0;\n}\n```\n:::\n\n\n### Nested loop\n\nA loop can be inside other loop. The inner loop can use outer loop's counter. Here is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    int outer{ 1 };\n    while (outer <= 10)\n    {\n        int inner{ 1 };\n        while (inner <= outer)\n        {\n            std::cout << inner << ' ';\n            ++inner;\n        }\n        std::cout << '\\n';\n        ++outer;\n    }\n\n    return 0;\n}\n```\n:::\n\n\nIn the exercise, we write a small program to print the characters from 'a' to 'z' and its ASCII code. From this, we need to recall the function `static_cast<type>(variable)` to transform characters to its integer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include<iostream>\n\nint main()\n{\n\tchar myChar{ 'a' };\n\twhile (myChar <= 'z')\n\t{\n\t\tstd::cout << myChar << ' ' << static_cast<int>(myChar) << '\\n';\n\t\t++myChar;\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n\nThe next exercise ask us to print an inverse triangle:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|label: while-inverse-triangle\n\n#include <iostream>\n\nint main()\n{\n\tint outer{ 5 };\n\twhile (outer >= 1)\n\t{\n\t\tint inner{ outer };\n\t\twhile ((inner >= 1))\n\t\t{\n\t\t\tstd::cout << inner-- << ' ';\n\t\t\t#//--inner;\n\t\t}\n\n\t\tstd::cout << '\\n';\n\t\t--outer;\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n\nThe most exercise is to create a right-handside triangle:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tint outer{ 1 };\n\twhile (outer <= 5)\n\t{\n\t\tint inner{ 5 };\n\t\t\n\t\twhile (inner >= 1)\n\t\t{\n\t\t\tif (inner <= outer)\n\t\t\t\tstd::cout << inner << ' ';\n\t\t\telse\n\t\t\t\tstd::cout << \"  \";\n\t\t\t--inner;\n\t\t}\n\t\t\n\t\tstd::cout << '\\n';\n\t\touter++;\n\t}\n\t\n\treturn 0;\n}\n```\n:::\n\n\n## Do while statement\n\nThis is just like while loop but the statement always executes at least once. After the statement has been executed, the do-while loop checks the condition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    // selection must be declared outside of the do-while so we can use it later\n    int selection{};\n\n    do\n    {\n        std::cout << \"Please make a selection: \\n\";\n        std::cout << \"1) Addition\\n\";\n        std::cout << \"2) Subtraction\\n\";\n        std::cout << \"3) Multiplication\\n\";\n        std::cout << \"4) Division\\n\";\n        std::cin >> selection;\n    }\n    while (selection != 1 && selection != 2 &&\n        selection != 3 && selection != 4);\n\n    // do something with selection here\n    // such as a switch statement\n\n    std::cout << \"You selected option #\" << selection << '\\n';\n\n    return 0;\n}\n```\n:::\n\n\nThe author recommend favor `while` loops over `do-while` when given equal choice.\n\n## For statements\n\nIn this session, we learn about the classic for statements with the form: `for (init-statement; condition; end-expression) statements`.\n\nWe can easily link to the while statement:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninit_statement;\nwhile(condition)\n{\n    statement;\n    end_expression;\n}\n```\n:::\n\n\nWe can write a very simple for loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main()\n{\n\tfor (int count{ 1 }; count <= 10; ++count)\n\t\tstd::cout << count << ' ';\n\t\n\tstd::cout << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nWe can easily change to `while statement`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main()\n{\n    {\n        int count{1};\n        while (count <= 10)\n        {\n            std::cout << count << ' ';\n            ++count\n        }\n    }\n    \n    std::cout << '\\n';\n}\n```\n:::\n\n\nWe can define multiple counters:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include \"io.h\"\n#include <iostream>\n\nint main()\n{\n\n\tfor (int x{ 0 }, y{ 9 }; x < 10; ++x, --y)\n\t\tstd::cout << x << ' ' << y << '\\n';\n\t\n\treturn 0;\n}\n```\n:::\n\n\nLoop can nest in other loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid charNumber()\n{\n\tfor (char c{ 'a' }; c <= 'h'; ++c)\n\t{\n\t\tstd::cout << c;\n\t\t\n\t\tfor (int i{ 0 }; i < 4; i++)\n\t\t{\n\t\t\tstd::cout << i;\n\t\t}\n\n\t\tstd::cout << '\\n';\n\t}\n}\n```\n:::\n\n\n:::{.callout-note}\n\n### Best practice\n\n*   `For statements` are the mostly important used loop in C++.\n*   Prefer `for loop` over `while loop` when there is an obvious loop variable.\n*   Prefer `while loop` over `for loops` when there is no obvious loop variable.\n\n:::\n\n\n## Break and continue\n\n`break statement` terminates the switch or loop, and execution continue at the\n*first statement* beyond the switch or loop.\n\n`return statement` *terminate the entire function that the loop is within*, and\nexecution continues at point where the function was called.\n\n### Continue\n\n**Continue statement** tells the program end current iteration, and continue next iteration.\n\nThe author advise to use the break, continue statement or *early return* when they simplify the loop logic.\n\n## Halts {#sec-halts}\n\nThe last category of flow control statement is **halt**: terminates the program.\n\n### The `std::exit()` function\n\nIt terminates the program normally. The term **normal termination** means that \nthe program exits in an expected way; it does not imply about whether the program was successful or not.\n\n`std::exit()` cleans up some static storage objects, returned back to OS.\n\nThe program does not execute any statements after `std::exit()`.\n\n`std::exit()` does not clean up local variables in the current function or up in the call stack.\n\nFunction `std::atexit()` take the arguments as functions to remember to do the clean up when we call `std::exit()`.\n\n### `std::abort()`\n\nThis function ends the program *abnormally*. It means that the program has some kind of unusual runtime error and could not continue to run.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <cstdlib> // for std::abort()\n#include <iostream>\n\nint main()\n{\n    std::cout << 1 << '\\n';\n    std::abort();\n\n    // The following statements never execute\n    std::cout << 2 << '\\n';\n\n    return 0;\n}\n```\n:::\n\n\n\nIt does not clean up anything.\n\n:::{.callout-tip}\n\nOnly use a halt if there is no safe way to return normally from the main function.\n\n:::\n\n## Introduction to testing the code\n\n### Test your programs in small pieces\n\nWe should write small functions (or classes), and then compile and test immediately. This test is call **unit testing**; each unit test assures a correct-particular behavior of that unit.\n\nThese are some method to test your unit code:\n\n#### Informal testing\n\nYou write your function and run it with some inputs to see whether it runs as expected or not. \n\nWe have a function that check whether a character is lower Vowel, then we add some character to see that it works well\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include \"io.h\"\n#include <iomanip>\n#include <iostream>\n\nint main()\n{\n\tstd::cout << std::boolalpha;\n\tstd::cout << isVowvel('0') << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n#### Preserving your tests\n\nInstead of testing informal, we can write a program to test the unit function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid testVowel()\n{\n\tstd::cout << \"Choose 'a': \" << isVowvel('a') << '\\n';\n\tstd::cout << \"Choose 'b': \" << isVowvel('b') << '\\n';\n}\n```\n:::\n\n\n## Common semantic errors in C++\n\n**Semantic errors** means that the codes do not do what we intended, and it leads to `undefined behavior`. There are some common semantic errors:\n\n* Conditional logic errors: errors occurs when the programmer incorrectly codes the logic of a conditional statement or loop condition.\n* Infinite loop\n* Off-by-one errors: counter are not correctly condition\n* Incorrect operator precedence\n* Integer division\n* Accidental null statements\n* Not using compound statement when one is required\n\n## Detecting and handling errors\n\nMost errors occur due to faulty assumptions made by the programmer and/or lack of proper error detection/handling:\n\n* Assume about return value\n* Assume that user give correct input\n* Assume that function is called correctly\n\nThus, we need to learn about error handling strategies (what to do when things go wrong) inside a function.\n\nFunctions may fail for many reasons and there is no best way to handle an error. There are 4 general strategies that can be used:\n\n### Handling the error within the function\n\nWe correct the error in the same function which the error occurred so that the error can be contained and corrected without impacting any code outside function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid printDivision(int numerator, int demonator)\n{\n\tif (demonator != 0)\n\t\tstd::cout << static_cast<double>(numerator) / demonator << '\\n';\n\telse\n\t\tstd::cerr << \"Error: Could not divide by zero\\n\";\n}\n```\n:::\n\n\n:::{.callout-note}\n\nThe handling print the error message out, and then the program continue to run the next statements in the caller.\n\nWhen we added a halt, it stops entire program.\n\n:::\n\n### Passing error back to the caller\n\nAs the above handling, the called function does not return anything to the calling function. If we want to pass the error to caller function, we should create a handling that return a value so that the caller function knows whether the called function runs correctly or not.\n\n### Fatal errors\n\nIn some case, the error is severe that we have to stop the program (*non-recoverable*), we can use the halt statement such as `std::exit()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid printDivision(int numerator, int demonator)\n{\n\tif (demonator != 0)\n\t\tstd::cout << static_cast<double>(numerator) / demonator << '\\n';\n\telse\n\t{\n\t\tstd::cerr << \"Error: Could not divide by zero\\n\";\n\t\tstd::exit(1);\n\t}\n}\n```\n:::\n\n\n## `std::cin` and handling invalid input\n\nA **robust** program anticipate the misuse from users and provide way to handle those program at the first place.\n\n#### `std::cin`, buffers, and extraction\n\n`std::cin` let user enter a value. This value is then stored temporarily inside of `std::cin` and waits for extracting to a variable. They call it **buffer**. The `operator>>` is an extraction to get the value in buffer into the variable. Normally, a value or a character is taken out, if there is still information in the buffer, that information is still there for the next extraction. \n\nFor example, if there is \"5a\" in buffer and we extract to variable x, then x = '5' and 'a' is in the buffer for the next extraction. \n\nWe write a program to illustrate the following error cases:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\ndouble getDouble()\n{\n    std::cout << \"Enter a double value: \";\n    double x{};\n    std::cin >> x;\n    return x;\n}\n\nchar getOperator()\n{\n    std::cout << \"Enter one of the following: +, -, *, or /: \";\n    char op{};\n    std::cin >> op;\n    return op;\n}\n\nvoid printResult(double x, char operation, double y)\n{\n    switch (operation)\n    {\n    case '+':\n        std::cout << x << \" + \" << y << \" is \" << x + y << '\\n';\n        break;\n    case '-':\n        std::cout << x << \" - \" << y << \" is \" << x - y << '\\n';\n        break;\n    case '*':\n        std::cout << x << \" * \" << y << \" is \" << x * y << '\\n';\n        break;\n    case '/':\n        std::cout << x << \" / \" << y << \" is \" << x / y << '\\n';\n        break;\n    }\n}\n\nint main()\n{\n    double x{ getDouble() };\n    char operation{ getOperator() };\n    double y{ getDouble() };\n\n    printResult(x, operation, y);\n\n    return 0;\n}\n```\n:::\n\n\n#### Error case 1: Input extraction succeeds but the input is meaningless to the program\n\nFor example, users enter x = 5, y = 2 and operator = 'k'. These inputs are attracted successfully to variable but we cannot operate the function.\n\nWe solve this case by doing input validation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhar getOperator()\n{\n\twhile (true)\n\t{\n\t\tstd::cout << \"Enter one of the following: +, -, *, or /: \";\n\t\tchar op{};\n\t\tstd::cin >> op;\n\n\t\tswitch (op)\n\t\t{\n\t\tcase '+':\n\t\tcase '-':\n\t\tcase '*':\n\t\tcase '/':\n\t\t\treturn op;\n\t\tdefault:\n\t\t\tstd::cerr << \"Error: Operator is not valid. Please try again.\\n\";\n\t\t}\n\t}\n}\n```\n:::\n\n\n#### Error case 2: Extraction succeeds but with extraneous input\n\nFor example, user enters `5*7`, the programs run and return 35 but does not lead user continue enter the input because `*7\\n` is stored in buffer for the following `operator>>`.\n\nTo solve this error, we have to tell the program **ignore** all the following character until the next `\\n`. In C++, we use the function `std::cin.ignore(num_char_to_ignore, \\n)` or better is `std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid ignoreLine()\n{\n\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n}\n```\n:::\n\n\nThen call the function in get input function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble getDouble()\n{\n\tstd::cout << \"Enter a double: \";\n\tdouble x{};\n\tstd::cin >> x;\n\tignoreLine();\n\t\n\treturn x;\n}\n```\n:::\n\n\n#### Error case 3: Extraction fails\n\nThis case happens when we enter a double value by a value with different type eg.: a. The `operator>>` cannot cover it to a double, so it let `a` in the buffer and goes into *fail mode*. Then, further requests for input extraction will silently fail. Thus, the output prompt still prints, but the input prompt is skipped, and we get stuck in infinite loop.\n\nWe solve the problem by:\n\n*   Test whether the `std::cin` is fail: `!std::cin`\n*   If it is fail, put it back to *normal* state: `std::cin.clear()`\n*   Flush the buffer so we can enter the new value: `ignoreLine()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!std::cin)\n{\n    std::cin.clear();   #// put back to normal mode\n    ignoreLine();       #// and remove bad input\n}\n```\n:::\n\n\n#### Error case 4: Extraction succeeds but the user overflows a numeric value\n## Assert and static_assert\n\nReturn to the program:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid printDivision(int numerator, int demonator)\n{\n\tif (demonator != 0)\n\t\tstd::cout << static_cast<double>(numerator) / demonator << '\\n';\n\telse\n\t{\n\t\tstd::cerr << \"Error: Could not divide by zero\\n\";\n\t}\n}\n```\n:::\n\n\nThe program checks whether we divide a number by a zero. This is a semantic error and will cause the program to crash down.\n\nWe link to the session @sec-halts for ideas on `std::exit()` and `std//abort()`. \n\n*   If we skip the offending statements, the error fails **silently**. This is bad for programming because we do not know where the error message is and how the conditions that triggered the error message.\n\n*   If we terminate the program by `std::exit()`, we loses our call stack and any debugging information. `std::abort()` is a better option for such cases when the we can start debugging at the point where the program aborted.\n\n#### Precondition, Invariant, Postcondition\n\nIt is any condition that must always be true prior to the execution of codes' component.\n\n**Invariant** is a condition must be true while some component is executing\n\n**Postcondition** is something that must be true after the execution of some component of code.\n\n### Assertions\n\nAn *assertion* is an expression that will be true unless there is a bug in a program.  If the expression is true, the assertion statement does nothing, otherwise, an error message is displayed and the program is terminated (via `std::abort()`). The error message contains: failed as text, name of code file, and the line number of the assertion.\n\nTo use assertion, we include header `assert`. Let look at the following codes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <cassert>\n#include <cmath>\n#include <iostream>\n\n\tdouble calculateTimeUntilObjectHitsGround(double initialHeight, double gravity)\n\t{\n\t\tassert(gravity > 0.0);\n\n\t\tif (initialHeight <= 0.0)\n\t\t{\n\t\t\treturn 0.0;\n\t\t}\n\n\t\treturn std::sqrt((2.0 * initialHeight) / gravity);\n\t}\n```\n:::\n\n\n* Make the assert statements be descriptive:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nassert(found && \"Car could not be found in database\")\n\n#// If `found == false`, then FALSE && TRUE is FALSE,  this trigger assert\n```\n:::\n\n\n#### Asserts and Error handling\n\nAssertions: to catch the programming errors by documenting something that should never happen. If it does happen, the the programmer made an error somewhere, it identifies and fixes. It does not allow recovery from errors.\n\nError handling: gracefully handle case that could happen (rarely). There may or may not be *recoverable*, but the program's users may encounter them.\n\n#### `static_assert`\n\nA `static_assert` checks the condition at the compile-time. It formula is `static_assert(condition, diagnostic_message)`.\n\n## Introduction to random numer generation\n\nComputer are generally incapable of generating truly random numbers. It simulates randomness using an algorithm.\n\n### Algorithms and state\n\n**Algorithm**:\n\n*   It is an instruction's sequence to solve a demand and provide useful results.\n*   It is reusable\n*   In C++, algorithms are typically implemented as reusable functions.\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint plusOne()\n\t{\n\t\tstatic int s_state{ 3 };\n\n\t\t++s_state;\n\n\t\treturn s_state;\n\t}\n```\n:::\n\n\nAn algorithm is **stateful** if it retains some information across calls. A **stateless** algorithm does not store any information. Our `plusOne()` is stateful because it creates a *static variable* that is used through its call.\n\nThe `plusOne()` is **deterministic**: given input, it will always produce **the same output**.\n\n### Pseudo-random number generators (PRNGs)\n\nThis is a very simple PRNGs:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include \"random.h\"\n\nint LCG16()\n{\n\tstatic int s_state{ 5323 };\n\ts_state = 8253729 * s_state + 2396403;\n\n\treturn s_state % 32768;\n}\n```\n:::\n\n\nThis function returns the same random sequence.\n\n#### Seeding a PRNG\n\nThe sequence of \"random number\" is not random. It is based on the initial state. The same initial state will generate same output sequence.\n\nWhen PRNG is instantiated, an initial value called a **random seed** can be provided to the initial state of the PRNG.\n\n#### What makes a good PRNG?\n\n* The PRNG should generate each number with approximately same probability.\n* The method by which the next number in the sequence should be  **unpredictable**.\n* It should represent the distribution of number\n* It should have a high period for all seed\n    - All PRNG are periodic: the sequence of numbers will repeated itself. The length of sequence before a PRNG begins to repeat itself is known as the **period**.\n* It should be efficient\n    \n   \n\n\n### Randomization in C++\n\nWe use via `<random>` header with the following PRNG families:\n\n![PRNG families in C++](figure/prng_cpp.PNG){width=120%}\n\n### Generating random numbers using Mersenne Twister\n\nWe use the `<ramdon>` header. There are two Mersenne Twister types:\n\n* `mt19937`: generates 32-bit unsigned integer\n* `mt19937_64`: generates 64-bit unsigned integer\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <random>\n\nint randomMT()\n{\n\tstd::mt19937 mt{};\n\n\tfor (int count{ 1 }; count <= 40; ++count)\n\t{\n\t\tstd::cout << mt() << '\\t';\n\n\t\tif (count % 5 == 0)\n\t\t\tstd::cout << '\\n';\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n\n#### Rolling a dice using MT\n\nWe use the **uniform distribution** that produces output between two numbers X and Y with equal probability.\n\nHere is the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <random>\n#include <iostream>\n\nvoid dice()\n{\n\tstd::mt19937 mt{};\n\n\tstd::uniform_int_distribution die6{ 1, 6 };\n\n\tfor (int count{ 1 }; count <= 40; ++count)\n\t{\n\t\tstd::cout << die6(mt) << '\\t';\n\n\t\tif (count % 5 == 0)\n\t\t\tstd::cout << '\\n';\n\t}\n}\n```\n:::\n\n\nThe dice sequence is not random. If we ran many times, we see that it is the same because we initialized our MT so it has the same seed every time the program is run.\n\nTo deal with this we usually use the seed from:\n\n* The system clock\n* The system's random device\n\n#### Seeding with the system clock\n\nWe use the system clock to initialize the seed for PRNG. This is from the `<chrono>` header and the function `static_cast<unsigned int>(std::chrono::steady_clock::now().time_since_epoch().count())`. Let see the example below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid diceSystemClock()\n{\n\tstd::mt19937 mt{ static_cast<unsigned int>(\n\t\tstd::chrono::steady_clock::now().time_since_epoch().count()\n\t\t) };\n\n\tstd::uniform_int_distribution die6{ 1, 6 };\n\n\tfor (int count{ 1 }; count <= 40; ++count)\n\t{\n\t\tstd::cout << die6(mt) << '\\t';\n\n\t\tif (count % 10 == 0)\n\t\t\tstd::cout << '\\n';\n\t}\n}\n```\n:::\n\n\n#### Seeding with the random device\n\nWe use the code `std::random_device()`. It will ask the OS for a random number. One potential *problem* is that it it not required to be non-deterministic. But, the lasted version support proper implementation of `std::random_device()`.\n\n:::{.callout-tip}\n\nUse `std::random_device()` to seed PRNGs.\n\nOnly seed a given PRNG once, do not reseed it.\n\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint getCard()\n{\n\tstd::mt19937 mt{ std::random_device{}() };\n\tstd::uniform_int_distribution card{ 1, 52 };\n\n\treturn card(mt);\n}\n```\n:::\n\n\nEverytime we call `getCard()`, the program creates a new seed. This is inefficient at best and cause poor random results.\n\n#### Random numbers across multiple functions\n\nTo use this, we create an `std::mt19937` object with `std:random_device()` in a namespace. This is an exception that we use non-const global variables.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <random>\n#include <iostream>\n\nnamespace Random\n{\n    std::mt19937 mt{std::random_device{}()};\n    \n    int get(int min, int max)\n    {\n        std::uniform_int_distribution die{min, max};\n        return die(mt);\n    }\n    \n    \n}\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}