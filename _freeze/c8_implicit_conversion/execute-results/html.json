{
  "hash": "3cee2ea2fe56c9ae63fa5109cb844752",
  "result": {
    "markdown": "---\ntitle: \"Type conversion and Funcion Overloading\"\n---\n\n\n## Type conversion\n\nThe compiler coverts from one data type to another data type. This si **type conversion**. For example, `float f{ 3 }`.\n\n### Implicit type conversion\n\nThis is also called **automatic type conversion** or **coercion**: the compiler coverts implicitly when we require one type of data but different type of data is supplied.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' covert from int to double\n\n#double fa {3}; \nd = 6;\n\n#' non-Boolean\nif (5)\n{\n    \n}\n```\n:::\n\n\nThe compiler will find the how to convert from current data type to the desired data type. If it can find, it will covert. Otherwise, it returns compile error.\n\n### The standard conversions\n\nC++ defines the **standard conversion** rules:\n\n* Numeric promotions: Floating-point and integral promotion\n* Numeric conversions\n* Arithmetic conversions\n* Other conversions\n\n#### Floating-point and integral promotion\n\nFloating-point and integral promotion are two types of **numeric promotion**. **Numeric promotion** is the conversion of a narrower numeric type (`char`) to a wider numeric type (`int` or `double`).\n\nAll numeric promotion are **value-preserving** and it helps to reduce redundancy.\n\n**Floating-point promotions**: value from `float` to `double`.\n\n**Integral promotions**:\n\n* signed char or signed short can be converted to int.\n* unsigned char, char8_t, and unsigned short can be converted to int if int can hold the entire range of the type, or unsigned int otherwise.\n* If char is signed by default, it follows the signed char conversion rules above. If it is unsigned by default, it follows the unsigned char conversion rules above.\n* bool can be converted to int, with false becoming 0 and true becoming 1.\n\n#### Numeric conversions\n\n* Convert an integral type to any other integral type (excluding integral promotions)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshort s = 3; # int to short\nlong l = 3; # int to long\nchar ch = s; # short to char\n```\n:::\n\n\n* Converting a floating point type to any other floating point type\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfloat f = 3.0;  # convert double to float\nlong double ld = 3.0    # covert double to long double\n```\n:::\n\n\n* Converting a floating  point type to any integral type\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint d = 3.5;\n```\n:::\n\n\n* Converting an integral type to any floating point type\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndouble d = 3;\n```\n:::\n\n\n* Converting an integral type or a floating point type to a bool\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbool b1 = 3;     # convert int to bool\nbool b2 = 3.0;   # convert double to bool\n```\n:::\n\n\nNumeric conversion sometimes causes the loss of data (from floating type to int, from wider type to narrower type,...).\n\nIf we want the conversion, it is better to explicit by using `static_cast<type>(var)`.\n\n**Narrowing conversion does not allow to use brace initialization**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main()\n{\n    int i {3.5};    # won't be compile\n}\n```\n:::\n\n\n#### Arithmetic conversion\n\nWhat type of the following:\n\n* `int x{2 + 3}`: both operands are int, so it is int\n* `??? y{2 + 3.5}`: one is int and one in floating type. So, compiler use **usual arithmetic conversions**\n\n##### The usual arithmetic conversion rules\n\nThe compiler has a prioritized list of types:\n\n* long double (highest)\n* double\n* float\n* unsigned long long\n* long long\n* long\n* unsigned int\n* int (lowest)\n\nThere are two rules:\n\n*  If the type of at least one of the operands is on the priority list, the operand with lower priority is converted to the type of the higher\n* Otherwise, both operands use **numeric promotions**\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\tint i{ 2 };\n\tdouble d{ 3.5 };\n\tstd::cout << typeid(i + d).name() << ' ' << i + d << '\\n';\n\n\tshort a{ 4 };\n\tshort b{ 5 };\n\tstd::cout << typeid(a + b).name() << ' ' << a + b << '\\n';\n```\n:::\n\n\nAvoid using unsigned integer.\n\n### Explicit type conversion\n\nWhen we want to covert from one type to wider type, implicit type conversion is fine.\n\nIn the case the like `double d = 10 / 4` will give the result is `2.0`. We can change like this `double d = 10.0 / 4.0`, but if we have \n\n\n::: {.cell}\n\n```{.r .cell-code}\nint x{10};\nint y{4};\n\ndouble d = x / y;\n```\n:::\n\n\nHow do we tell the compiler to use floating type instead of integer. In C++, we use **type casting operators** to request it. This is usually called **explicit type conversion**.\n\n#### Type casting\n\n##### C-style cast\n\nIn C programming, cast are done via `()operator`, with name of type to convert the value placed inside the parentheses\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|label: c-style\n\nint main()\n{\n    int x {10};\n    int y {4};\n    \n    double d { (double)x / y};  #convert x to double\n}\n```\n:::\n\n\nBut c-style cast can create some risk: it includes `static cast`, `const cast`, and `reinterpret cast`. Thus, **avoid using C-style cast**.\n\n##### static_cast\n\nWe should use this to convert a value from one type to another type.\n\nUse `static_cast` to make the narrowing conversions explicit.\n\n### Typedefs and type aliases\n\nHere is an example of type aliases:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusing Distance = double;\nDistance mile{3.0};\n\n## Using fo legibility\n\nint gradeTest();\n### Or\nusing TestScore = int;\nTestScore gradeTest();\n\n## For easier code maintenance\n\nUsing StudentID = short\n## Then, we want to change\nusing StudentID = long\n```\n:::\n\n\nType aliases should be used if there is clear benefit to code readability and code maintenance.\n\n### Type deduction for object using the auto keyword\n\n**Type deduction** allows the compiler to deduce the object's type basing on its initializer. We use the code `auto`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nauto d{ 5.0 };\nauto i{ 1 + 2 };\nauto x{ i };\n\nint add(int x, int y)\n{\n\treturn x + y;\n}\n\nint main()\n{\n\tauto sum{ add(5, 6) }; # add() returns an int, so sum's type will be deduced to int\n\n\treturn 0;\n}\n\n#> Type deduction drop the `const`\n\n    const int x { 5 };  # x has type const int\n    auto y { x };       # y will be type int (const is dropped)\n\n    const auto z { x }; # z will be type const int (const is reapplied)\n    \n#!!! Attention to string types\n    \n    const int x { 5 };  // x has type const int\n    auto y { x };       // y will be type int (const is dropped)\n\n    const auto z { x }; // z will be type const int (const is reapplied)\n```\n:::\n\n\nType deduction has some advantages:\n\n*   Two or more variables are defined in sequential lines\n*   It only works on variables that have initializers, so it helps to avoid unintentionally uninitialized variables.\n\nBut, still have some downsides\n\n* Something does not deduce as we expected `auto y { 5 };` give int not double.\n\n:::{.callout-tip}\n\nUse type deduction for your variables, unless you need to commit to a specific type.\n\n:::\n\n### Type deduction for functions\n\nWe can also use type deduction for function but it requires more concensus:\n\n* All statements `return` in the body has to return the same type, otherwise, there is error\n* Function has to be defined before its forward declaration\n\n:::{.callout-tip}\n\nFavor explicit return types for function over return type deduction for normal functions.\n\n:::\n\n:::{.callout-note}\n\nType deduction cannot be used for function's parameters prior to C++20.\n\n:::\n\n## Introduction to function overloading\n\n**Function overloading** allow us to create multiple functions with the same name, so long as each functions has **different parameters types** or can be differentiated by the compiler. \n\nEach function sharing a name is called an overloaded function or overload. For example, we can simply define two `add()` functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <typeinfo>\n#include <string_view>\n#include <iostream>\n\nint add(int x, int y)\n{\n\treturn x + y;\n}\n\ndouble add(double x, double y)\n{\n\treturn x + y;\n}\n\nint main()\n{\n\t\n\treturn 0;\n}\n```\n:::\n\n\n:::{.callout-tip}\n\nUse function overloading to make your program simpler\n\n:::\n\n## Function overload differentiation\n\nIn this section, we learn how the compiler differentiates overloaded functions.\n\n![How overloaded functions are differentiated](figure/differ_overloaded_function.PNG)\n\nA function's **signature** is defined as the part of the function including function's name, parameter's parameter, parameter's types, and function-level qualifiers. **Not** return type.\n\n### Function overload resolution and ambiguous matches\n\nHow to match a function call for overloaded functions? The compiler has to find the best match, this is **overload resolution**.\n\nThe compiler applies a bunch of different type conversions to the arguments, then checks if any of the overloads match. There are three possibilities:\n\n    1. No matching functions were found. Move to the next steps in the sequence\n    2. A single matching functions was found. The matching process is complete, no further steps.\n    3. More than one matching functions. The compiler return error.\n\n#### The argument matching sequence\n\n1. Try to find an exact match\n2. If not, apply **trivial conversions**: non-const type to const-type\n3. If not, apply numeric promotion\n4. If not, apply numeric conversion\n5. If not, find user-defined type\n6. If not, give up and error.\n\n#### Ambiguous match\n\nOne or more overloads are possible to match\n\n## Default arguments\n\nA **default argument** is a default value provided for a function parameter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid print(int x, int y = 10)\n{\n    std::cout << \"x: \" << x << '\\n';\n    std::cout << \"y: \" << y << '\\n';\n}\n```\n:::\n\n\nThere are some rules\n\n* Default argument can only be supplied for the rightmost parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid print(int x=10, int y); # not allowed\n```\n:::\n\n\n* Default argument can not be re-declared\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid print(int x, int y=4); // forward declaration\n\nvoid print(int x, int y=4) // error: redefinition of default argument\n{\n    std::cout << \"x: \" << x << '\\n';\n    std::cout << \"y: \" << y << '\\n';\n}\n```\n:::\n\n\n* Best practice is to declare default argument in **forward declaration**, not in function definition.\n\n* Can be use in overloaded functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid print(int x);\nvoid print(int x, int y = 10);\nvoid print(int x, double y = 20.5);\n\nprint(1, 2);        # will resolve to print(int, int)\nprint(1, 2.5);      # will resolve to print(int, double)\nprint(1);           # ambiguous function call\n```\n:::\n\n\n## Function template\n\n:::{.callout-important}\n\n### Problems:\n\nHow can we write a function `max(x, y)` to find the greater value between two variables and this function applies to type int, double, long int, long double so that we do not need to have overloaded function?\n\n:::\n\nWelcome to the world of C++ templates!\n\n### Introduction to C++ templates\n\nWe create a **template** to describe how a function or a class looks like. In the template, we have placeholders represents some unknown types that is replaced later.\n\nThen, compiler uses defined template to generate the overloads (or classes) using different actual types.\n\nTemplates work with types did not even exist when the template was written, thus it is flexible and future proof.\n\n### Function templates\n\n**Function template** is a function-like definition to generate overloaded functions.\n\nWe use placeholder types (type template parameters) for any parameter types, return types or types in the functio body.\n\nWe create a template function `max` as an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemplate <typename T>\nT max(T x, T y)\n{\n\treturn (x < y) ? y / x;\n}\n```\n:::\n\n\nCreating a function from template function is **function template instantiation**\n\nWe can also use deduction for calling a template function.\n\nThere are also template parameters and non-template parameters in template function.\n\n:::{.callout-tip}\n\nWe place templates in the header file to use in multiple fine by `#include`. This allow the compiler to see full template function and instantiate.\n\nUse function templates to write generic code that can work with a wide variety of types whenever you have the need.\n\n:::\n\n### Function templates with multiple template types\n\nIn one template type parameters, why does the compiler use numeric conversion for two types? \n\n**Answer:** type conversion is only when resolving function overloads, not performing template argument deduction.\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\ntemplate <typename T, typename U>\t// multiple template types\nauto max(T x, U y)\t\t// auto for deduction the return type.\n{\n\treturn (x < y) ? y : x;\n}\n\nint main()\n{\n\tstd::cout << max<int>(2, 3) << '\\n';\n\tstd::cout << max<double>(2, 3) << '\\n';\n\tstd::cout << max(2, 3) << '\\n';\n\tstd::cout << max(2, 3.5) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nFrom C++20:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nauto maxAuto(auto x, auto y)\n{\n\treturn (x < y) ? y : x;\n}\n```\n:::\n\n\nPlease read this Chapter's summary [Here](https://www.learncpp.com/cpp-tutorial/chapter-8-summary-and-quiz/).\n\n",
    "supporting": [
      "c8_implicit_conversion_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}