{
  "hash": "7c671bf09fcbfb641f34cb21904ab475",
  "result": {
    "markdown": "---\ntitle: \"Introduction to compound data types\"\n---\n\n\n**Question:** How can we write a function taking two fraction numbers and then multiply them?\n\nWith the fundamental data types, it is not easy to have a nice solution. Thus, C++ provide a tool: **compound data types**.\n\n## Compound data types\n\nThey are constructed from fundamental data types. Each of them has its own unique properties. In the following sessions, we will learn many compound data types.\n\n## Value categories (lvalues and rvalues)\n\nAll expressions in C++ have **a type and a value category**. \n\n**Type**: Compiler will see whether the expression's type is valid in a given context.\n\n**Value category** of an expression indicates whether an expression resolves to a value, a function, or an object of some kind.\n\nThere are two value categories: `lvalue` and `rvalue`.\n\n* `lvalue` is an expression that evaluates to an identifiable object or function\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#int x{5};\n#int y{x};   # x is modifiable lvalue expression\n\nconst double d{};\nconst double e{d};  # d is non-modifiable lvalue expr\n```\n:::\n\n\n* `rvalue` is expression that is not `lvalue` such as literals, return of functions or operators.\n\nFrom this we can understand why `x = 5` is valid, but not `5 = x`. `=assignment` requires the left operand is modifiable `lvalue` and right operand is `rvalue`.\n\n:::{.callout-note}\n\n`lvalue` can be implicitly converted to `rvalue`. Thus, `x = y` or `x = x + 1` are valid.\n\n:::\n\n## lvalue reference\n\nIn C++, **reference** is an alias to an object. We can modify the object that are referenced (called *referent*) through its alias.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tint x{ 5 };\n\tint& ref{ x };      # We use (&) to define reference to x\n\n\treturn 0;\n}\n```\n:::\n\n\nIn the above code, `ref` is bound to `x`. \n\n:::{.callout-note}\n\nWe cannot bind lvalue reference to non-modifiable lvalue. We need the const reference in preceding session.\n\nThe type of reference must match the type of the referent.\n\nReferences are not objects in C++.\n\nReferences **cannot be reseated** to other lvalue.\n\n:::\n\n## Lvalue reference to const\n\nWe can do this by `const int& ref{x}`. `ref` binds to non-modifiable lvalue `const int x`. `ref` can access its referent, but cannot modify the value being referenced:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tconst int x{ 5 };\n\tconst int& ref{ x };\n\n\tstd::cout << ref << '\\n';\n\tref = 6;    #!!! Error: cannot assign to const lvalue ref\n\n\treturn 0;\n}\n```\n:::\n\n\nVariable `x` does not need to be const to have const reference\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main()\n{\n\tint x{ 5 };\n\tconst int& ref{ x };\n\n\tstd::cout << ref << '\\n';\n\t//ref = 6; error\n\n\tx = 6;\n\tstd::cout << ref << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n:::{.callout-tip}\n\nFavor `lvalue references to const` over `lvalue references to non-const`\n\n:::\n\nWith `lvalue reference to const`, we can bind to `rvalue` too: `const int& ref{ 5 };`.\n\nThe program creates a **temporary object**^[Temporary object or anonymous object is created temporarily within a single expression. It does not have any scope] as a referent. However, lifetime of temporary object extends to the lifetime of its references.\n\n## Pass by lvalue reference\n\nWhy does C++ allow to bind to `rvalue` object ?\n\nIn function, when we pass by value to parameters, C++ copies argument's value to the function to use and destroys at the end of called function. Sometimes, it is not efficient for other data types.\n\nTo avoid this, C++ uses `pass by reference` instead of `pass by value`. To do that, we declare functions' parameters as a reference type rather than a normal type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <string>\n\nvoid printValue(std::string& y)\n{\n\tstd::cout << y << '\\n';\n}\n\nint main()\n{\n\tstd::string x{ \"Hello world!\" };\n\tprintValue(x);\t// x is now passed by reference into reference parameter y\n\n\treturn 0;\n}\n```\n:::\n\n\n:::{.callout-warning}\n\n`pass by reference` to non-const allows us to write functions that **modify value** of arguments passed in\n\n:::\n\nWe use const reference to avoid this. And const reference can refer to modifiable lvalue, non-modifiable lvalue and rvalue too.\n\n:::{.callout-tip}\n\nFunction with multiple parameters can have both `pass by value` and `pass by reference`\n\nFor fundamental types, `pass by value`\n\nFor class types, `pass by reference`\n\n:::\n\n### The cost of pass by value vs pass by reference\n\nWhy do not we always use pass by reference?\n\nFirst, cost of copying an object depends on: \n\n* The size of object\n* Additional set up\n\nIn this view, pass by reference is faster.\n\nSecond, assessing an object through a reference is slightly more expensive than a normal variable identifier. In this view, pass by value is better.\n\n## Introduction to pointer\n\n> Pointers are one of C++'s historical boogeymen.\n>\n> <footer>--- Alex</footer>\n\nWhen we define a variable, RAM assigns a piece of memory to this object. For example,  define `char x{}`, and then RAM allocate it to address `140`. Anytime, we call `x`, RAM will go to `140` to extract its value.\n\nThis is true with reference too. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main()\n{\n    char x{};\n    char& ref{x};\n    \n    return 0;\n}\n```\n:::\n\n\nAnytime we call `ref`, the program goes to the memory address `140`.\n\n### The address-of operator (&)\n\nThe **address-of operator (&)** returns the memory address of operand.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tint x{ 5 };\n\tstd::cout << x << '\\n';\n\tstd::cout << &x << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nThe **dereference operator (\\*)** returns the value at a given memory address as an lvalue.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd::cout << *(&x) << '\\n';\n```\n:::\n\n\n### Pointers\n\nA **pointer** is an object that holds a *memory address* (typically of another variable) as its value.\n\nLike reference to lvalue uses `(&)`, the pointer use an asterisk `*`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint* ptr;\n```\n:::\n\n\nLike normal variable, pointers are not initialized by default. If not initialized, we call it **wild pointer**. We should always initialize pointers to a *known value*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint x{ 5 };\nint& ref{ x };\nint* ptr;\t        # wild pointer\nint* ptr2{};        # null pointer\nint* ptr3{ &x };\t# a pointer bind to address of x\n```\n:::\n\n\n:::{.callout-note}\n\n* \"X pointer\" is a short hand for \"pointer to an X\".\n\n:::\n\nMuck like a reference, type of reference has to match type of object referred, type of pointer has to match the type of the object of being pointed to.\n\nInitializing a pointer with a literal value is **disallowed**.\n\n### Pointer and assignment\n\nWe use assignment to change the pointer points to address of other object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main()\n{\n\tint x{ 5 };\n\tint* ptr{ &x };\n\n\tstd::cout << *ptr << '\\n';\n\n\tint y{ 10 };\n\tptr = &y;\n\tstd::cout << *ptr << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nWe use the assignment to change the value of object that a pointer is pointing to\n\n### Pointer and reference\n\nPointer and reference has some similarly. But they are different:\n\n* For pointer, we must use address-of and dereference explicitly. They are implicit for reference\n* Reference must be initialized, pointer are not required (risk of undefined behaviors)\n* Reference is not an object, pointer is an object\n* Reference cannot be reseated, pointer can be reseated\n* References must always be bound to an object, point can point to nothing (null pointer)\n* References are safe, pointers are inherently dangerous.\n\nThe address-of operator returns a pointer, not as a literal.\n\nThe size of pointers are the same regardless of size of object being pointed to\n\n### Dangling pointers\n\nLike dangling reference, **dangling pointer** is a pointer that is holding the address of an object that is no longer valid.\n\n### Conclusion\n\nPointers are both more flexible than references and more dangerous.\n\n\n## Null pointers\n\n**Null pointers** point to nothing; it holds null value. We can assign null pointer to an object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint* ptr0{};\t\t\t// null pointer\nptr0 = &x;\t\t\t   // null pointers point to an object\n```\n:::\n\n\nIn C++, we use `nullptr` to initialize, assign, pass null pointer to pointer or function.\n\nDereferencing a null pointer may lead to *undefined behavior* or crash the program.\n\n:::{.callout-warning}\n\nWhenever we use a pointer, we must guarantee that there does not have any dereferencing null or dangling pointers.\n\n:::\n\nWe can use the `if statement` to test whether a pointer is null or not.\n\n:::{.callout-tip}\n\nAny pointer should either hold a valid object's address or be set to `nullptr`. Thus, we can test for the pointer's nullity and assume any non-null pointer is valid.\n\n:::\n\nWe should favor references over pointers unless the additional capabilities provided by pointer are needed.\n\nThe code for this session\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <typeinfo>\n\nint main()\n{\n\tint x{ 5 };\n\tint* ptr0{ nullptr };// null pointer\n\tint* ptr{ &x };\n\n\tif (ptr == nullptr)\n\t{\n\t\tstd::cout << \"ptr is null\\n\";\n\t}\n\telse\n\t{\n\t\tstd::cout << \"ptr is non-null\\n\";\n\t}\n\n\tptr0 = &x;\t\t\t   // null pointers point to an object\n\tptr = nullptr;\n\n\tstd::cout << typeid(&x).name() << '\\n';\n\tstd::cout << ptr << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n## Pointer and const\n\nA normal pointer cannot point to a const object, we need a **pointer to a const value** by adding `const` at the start of pointer's definition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconst int x{5};\nconst int* ptr{ &x };\t# we use the pointer to const, but it is not const itself\n```\n:::\n\n\nFrom its definition, `ptr` point to const `x`. That pointer cannot change the value of `x` through assignment, but it can pointer to other object (either const or not-const). Thus, pointer is **not constant itself** but it cannot change the value of object pointed.\n\nTo create a constant pointer that it cannot point to other object, we use the code `int* const ptr{ &y }`. Thus, the const pointer cannot point to other object, but it can change object's value.\n\nFinally, we can define **const pointer to const value** by using two `const` before the type and after the asterisk.\n\nLet look at the following code as a summary this session\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <typeinfo>\n\nint main()\n{\n\tconst int x{ 5 };\n\n\t//int* ptr{ &x };\t\t\t\t# compile error: cannot initialize with const\n\tconst int* ptr{ &x };\t\t   # we use the pointer to const, but it is not const itself\n\n\t//*ptr = 6;\t\t\t\t     # error: cannot change value of const var\n\t\n\tint y{ 7 };\n\tptr = &y;\t\t\t\t  # can change the address to point to\n\n\tconst int* ptr2{ &y };  # const pointer to a non-const var\n\t//*ptr2 = 6;\t\t   # not allowed\n\ty = 6;\t\t\t\t  # ok\n\n\tint z{ 10 };\n\tint* const ptr3{ &y };\t\t\t # const pointer\t\n\n\tptr3 = &z;\t\t\t\t\t\t# const pointer cannot pointer to other object\n\t*ptr3 = 500;\n\n\tconst int* const ptr4{ &x };\t  # const pointer to const value\n\n\treturn 0;\n}\n```\n:::\n\n\n\n## Pass by address\n\nWe start by looking at the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#label: print-function\n\n#include <iostream>\n#include <string>\n\n# Function use pass by value\nvoid printValue(std::string val)\n{\n\tstd::cout << val << '\\n';\n}\n\n# Function use pass by reference\nvoid printByReference( const std::string& ref)\n{\n\tstd::cout << ref << '\\n';\n}\n\nint main()\n{\n\tstd::string val{ \"Hello world!\" };\n\n\tprintValue(val);\t\t\t# it copies the val's value to pass to called function\n\tprintByReference(val);\t   # it does not copies, make a reference to function\n\n\treturn 0;\n}\n```\n:::\n\n\nWe learned about `pass by value` and `pass by reference`. Let recall where we use either of them.\n\nWe now also use `pass by address` as follow code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid changeValue(int* ptr)\n{\n\t*ptr = 6;\n}\n\nint main()\n{\n\tstd::string val{ \"Hello world!\" };\n\n\tprintValue(val);\t# it copies the val's value to pass to called function\n\tprintByReference(val);\t   # it does not copy, make a reference to function\n\tprintByAddress(&val);\t  # pass by address, does not copy val\n\n\treturn 0;\n}\n```\n:::\n\n\nWe can modify the object's value through pass by address\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid changeValue(int* ptr)\n{\n\t*ptr = 6;\n}\n```\n:::\n\n\nMake sure not to pass null pointer. We can test and handle it\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid print(int* ptr)\n{\n\tassert(ptr && \"Pointer must be not null\");\n\t\n\tif (!ptr)\t// if ptr is null pointer, return\n\t{\n\t\treturn;\n\t}\n\n\tstd::cout << *ptr << '\\n';\n}\n```\n:::\n\n\nPass by address can only use for lvalue, not for rvalue. Pass by const reference can use for both and avoids the null problem.\n\n:::{.callout-tip}\n\nFavor pass by reference over pass by address.\n\n:::\n\n\n## Pass by address 2\n\nPass by address can use for default (optional) arguments. But sometimes, we can use the overloaded functions.\n\n### Changing what a pointer parameter points at\n\nPass by address **copies** the address to the parameters, so we change the pointing in the function does not change the pointing of pointer outside function.\n\nTo do this, we pass **pointer by reference** to the parameter.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid printByReference( const std::string*& ref)\n{\n\tstd::cout << ref << '\\n';\n}\n```\n:::\n\n\n### There is only pass by value\n\nCompiler implement pass by reference by using pointers. Behind the scenes, pass by reference is just pass by address with implicit dereference.\n\nWhen pass by address make a copies of address from caller to the called function, it is also an type of pass by value.\n\nWe conclude that C++ really passes everything by value!\n\n\n## Return by reference and return by address\n\nCompiler copies function's return to pass back to caller. This sometimes expensive.\n\n### Return by reference\n\nWe may use **return by reference** to avoid this. **Return by reference** returns a reference that is bound to object being returned. Here is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <string>\n\nconst std::string& getProgramName()\n{\n\tstatic const std::string s_programName{ \"Calculator\" };\n\t\n\treturn s_programName;\n}\n\nint main()\n{\n\tstd::cout << \"Program's name is \" << getProgramName() << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n`getProgramName()` return a const reference. When the return is executed, `getProgramme()` return a const reference to `s_programName`.\n\nThe object returned by reference must exit after the function returns. We cannot use the **local variable** for return by reference.\n\nAvoid returning references to non-const local static variables. The code below shows the problem:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconst int& getId()\n{\n\tstatic int id{ 0 };\n\t++id;\n\n\treturn id;\n}\n\nint main()\n{\n\t//std::cout << \"Program's name is \" << getProgramName() << '\\n';\n\n\tconst int& id1{ getId() };\n\tconst int& id2{ getId() };\n\n\tstd::cout << id1 << id2 << '\\n';\n\n\treturn 0;\n}\n\n#>22\n```\n:::\n\n\nTwo ids value are the same because we generate non-const static variable.\n\nWhen we assign or initialize a  **normal variable** by a return by reference function, compiler makes a **copies** of the value return by reference:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconst int& getId()\n{\n\tstatic int id{ 0 };\n\t++id;\n\n\treturn id;\n}\n\nint main()\n{\n\t//std::cout << \"Program's name is \" << getProgramName() << '\\n';\n\n\tconst int id1{ getId() };  #id1 and id2 are normal variable\n\tconst int id2{ getId() };\n\n\tstd::cout << id1 << id2 << '\\n';\n\n\treturn 0;\n}\n\n#>12\n```\n:::\n\n\n**Notice that the reference is left dangling before the copy is made.**\n\nIt is fine to return reference parameters by reference\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconst std::string& firstAlphabetical(const std::string& a, const std::string& b)\n{\n\treturn (a < b ? a : b);\n}\n\nint main()\n{\n\tconst std::string a{ \"Hello\" };\n\tconst std::string b{ \"World\" };\n\n\tstd::cout << firstAlphabetical(a, b) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nThe caller can modify the return by reference for non-const reference.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint& max(int& x, int& y)\n{\n\treturn (x > y ? x : y);\n}\n\n\nint main()\n{\n\tint a{ 100 };\n\tint b{ 200 };\n\n\tmax(a, b) = 1;\n\n\tstd::cout << b << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n## Type deduction with pointers, references, and const\n\nRecall about type deduction for object and function by using `auto`. Remember that `auto` remove `const`, if we want to keep it, then use `const auto`. Let look at the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint getVal()\n{\n\treturn 1;\n}\n\nconst double foo()\n{\n\treturn 5.6;\n}\n\nint main()\n{\n\tauto val{ getVal() };\t# val deduced as type int\n\n\tauto x{ foo() };\t    # double, dropped const\n\tconst auto y{ foo() }; # const double\n\n\treturn 0;\n}\n```\n:::\n\n\nType deduction also drops **reference**, thus we need to add again to the definition:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd::string& getRef()\n{\n\tstatic std::string s_getString{ \"Hello\" };\n\n\treturn s_getString;\n}\n\nint main()\n{\n\tauto ref1{ getRef() };\t# std::string, dropped reference\n\tauto& ref2{ getRef() };\t# std::string&\n\n\treturn 0;\n}\n```\n:::\n\n\n### Top-level const and low-level const\n\nA **top-level const** is a const qualifier that applies to an object itself:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconst int x{};  # this const applies directly to x\nint* const ptr{}; # this const applies directly to ptr\n```\n:::\n\n\nA **low-level const** is a const qualifier that applies to the object being referenced or pointed to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconst int& ref{x};  # this const applies to the object being referenced\nconst int* ptr{};   # this const applies to the oject being pointed to\n```\n:::\n\n\nA reference is not an object, so there are no top-level- const for reference.\n\nPointer may have both top and low level const\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconst int* const ptr{};\n```\n:::\n\n\nType deduction only drops **top-level const**.\n\nIf the initializer is a reference to const, the reference is dropped first, and then any top-level const is dropped from the result:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconst std::string& getRef()\n{\n\tstatic const std::string s_getString{ \"Hello\" };\n\n\treturn s_getString;\n}\n\nint main()\n{\n\tauto ref1{ getRef() };\t\t# std::string: dropped reference, then dropped const\n\tconst auto ref2{ getRef() }; # const std::string: dropped reference\n\n\tauto& ref3{ getRef() };\t\t# const std::string&\n\tconst auto& ref4{ getRef() }; # const std::string&\n\n\treturn 0;\n}\n```\n:::\n\n\n### Type deduction and pointers\n\nUnlike reference, type deduction does not drop pointer, thus the two codes below have the same results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <string>\n\nstd::string* getPtr(std::string* str)\n{ \n\treturn str;\n}\n\nint main()\n{\n\tstd::string str{ \"Hello\" };\n\n\tauto ptr3{ getPtr(&str) };  # std::string*\n\tauto* ptr4{ getPtr(&str) }; # std::string*\n\n\tstd::cout << *ptr3  << ' ' << *ptr4 << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nBut there are difference betwwen `auto` and `auto*`\n\n* `auto` deduces including pointer\n* `auto*` deduces not including pointer, and then reapplied the pointer.\n* `auto*` must resolve to a pointer initialzer, otherwise, there is error\n\n\n::: {.cell}\n\n```{.r .cell-code}\nauto* ptr4{ *getPtr() };     # does not compile (initializer not a pointer)\n```\n:::\n\n\nWe can see the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd::string* getPtr(); # some function that returns a pointer\n\nint main()\n{\n    const auto ptr1{ getPtr() };  # std::string* const\n    auto const ptr2 { getPtr() }; # std::string* const\n\n    const auto* ptr3{ getPtr() }; # const std::string*\n    auto* const ptr4{ getPtr() }; # std::string* const\n\n    return 0;\n}\n```\n:::\n\n\nAnd a more complicated one:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <string>\n\nconst std::string* const getConstPtr(); # some function that returns a const pointer to a const value\n\nint main()\n{\n    auto ptr1{ getConstPtr() };  # const std::string*\n    auto* ptr2{ getConstPtr() }; # const std::string*\n\n    auto const ptr3{ getConstPtr() };  # const std::string* const\n    const auto ptr4{ getConstPtr() };  # const std::string* const\n\n    auto* const ptr5{ getConstPtr() }; # const std::string* const\n    const auto* ptr6{ getConstPtr() }; # const std::string*\n\n    const auto const ptr7{ getConstPtr() };  # error: const qualifer can not be applied twice\n    const auto* const ptr8{ getConstPtr() }; # const std::string* const\n\n    return 0;\n}\n```\n:::\n\n\nPlease read the Chapter's summary [here](https://www.learncpp.com/cpp-tutorial/chapter-9-summary-and-quiz/).",
    "supporting": [
      "c9_intro_compound_data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}