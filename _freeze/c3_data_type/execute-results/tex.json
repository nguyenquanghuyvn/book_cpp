{
  "hash": "0686a7da92489328619fd984d719f8f6",
  "result": {
    "markdown": "# Fundamental Data Types\n\n## Introduction to fundamental data types\n\n:::{.callout-note}\n\n### Recall\n\nVariable is a names of a piece of memory that we will store a certain type of information (data) into.\n\n:::\n\nAll data on a computer is just a sequence of bits, we use a **data type** to tell the compiler **how to interpret** the contents of memory in some meaningful way. \n\nWhen we give an object a value, the compiler and CPU covert it to bit and store in a memory; when we consult the value, the bit is recovered to the human-readable format.\n\n### Fundamental data types\n\nTable belows summray the **data types** in C++:\n\n![Data types](figure/dataTypes.PNG){#fig-dataTypes}\n\n### Void\n\n**Void** means no type. Then, a variables cannot be defined with a type of void.\n\n`void` uses with function does not return value.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include<iostream>\n\nvoid writeValue(int x)\n{\n  std::cout << \"The value is: \" << x << '\\n';\n}\n```\n:::\n\n\nIf we return value, compiler returns error.\n\n### Object sizes and the size of operator\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| label: typeSize\n\n#include <iostream>\n\nint main()\n{\n    std::cout << \"bool:\\t\\t\" << sizeof(bool) << \" bytes\\n\";\n    std::cout << \"char:\\t\\t\" << sizeof(char) << \" bytes\\n\";\n    std::cout << \"wchar_t:\\t\" << sizeof(wchar_t) << \" bytes\\n\";\n    std::cout << \"char16_t:\\t\" << sizeof(char16_t) << \" bytes\\n\";\n    std::cout << \"char32_t:\\t\" << sizeof(char32_t) << \" bytes\\n\";\n    std::cout << \"short:\\t\\t\" << sizeof(short) << \" bytes\\n\";\n    std::cout << \"int:\\t\\t\" << sizeof(int) << \" bytes\\n\";\n    std::cout << \"long:\\t\\t\" << sizeof(long) << \" bytes\\n\";\n    std::cout << \"long long:\\t\" << sizeof(long long) << \" bytes\\n\";\n    std::cout << \"float:\\t\\t\" << sizeof(float) << \" bytes\\n\";\n    std::cout << \"double:\\t\\t\" << sizeof(double) << \" bytes\\n\";\n    std::cout << \"long double:\\t\" << sizeof(long double) << \" bytes\\n\";\n\n    return 0;\n}\n```\n:::\n\n\n\n### Signed intgeger\n\n**Signed integer** is integer with sign operator. These are the conventional definition of interger:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshort s;            // short int\nint i;\nlong l;           // long int\nlong long ll;     // long long int \n```\n:::\n\n\n### Floating point numbers\n\nFor floating numbers, we have the appropriate value; `std::cout` displays from 6 to 8 digits. We can override this format by use `std::setprecision(#digits)` from headers `iomanip`. \n\nThe precision does not only impact the fractional number, they impact any number with too many significant digits:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iomanip>\t\t// for std::setprecision()\n\nint main()\n{\n\tfloat f{ 123456789.0f };\n\tstd::cout << std::setprecision(9);\n\tstd::cout << f << '\\n';\n\n\treturn 0;\n}\n\n#> 123456792\n```\n:::\n\n\nIn the example, 1234567892 is greater than 123456789. The value of 123456789.0 has 10 significant digits, but float values typically have 7 digits of precision, then we lost precision\n\n:::{.callout-tip}\n\n#### Best practice\n\nFavor double over float type.\n\n:::\n\n### Rounding errors makes floating point comparision tricky\n\nFloating point numbers are tricky to work due to non-obvious differences between binary and decimal. The fraction 0.1, in binary, 0.1 represented by *infinite* sequence 0.00011001100110011... Thus, we assign 0.1 to floating point number, we run into **rounding errors**.\n\nLet see the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iomanip>\t\t// for std::setprecision()\n\nint main()\n{\n\tdouble d{ 0.1 };\n\tstd::cout << d << '\\n';\t// use default cout precision of 6\n\tstd::cout << std::setprecision(17);\n\tstd::cout << d << '\\n';\n\n\treturn 0;\n}\n\n#> 0.1\n#> 0.10000000000001\n```\n:::\n\n\nThe `double` type guarantee precision for 16 digits, when there are more than that, there is not precision. Another one\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iomanip>\t\t// for std::setprecision()\n\nint main()\n{\n\tstd::cout << std::setprecision(17);\n\n\tdouble d1{ 1.0 };\n\tstd::cout << d1 << '\\n';\n\n\tdouble d2{ 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 + 0.1 };\t// should equal 1.0\n\tstd::cout << d2 << '\\n';\n\n\treturn 0;\n}\n\n#> 1\n#> 0.999999999999999999999999\n```\n:::\n\n\n### Boolean values\n\nBoolean type takes only two value: 'true' or 'false'. In C++, the system represents it as an integer which 0 for 'false' and 1 for 'true'. If we want to print the values rather than number, we have to use the function `std::boolalpha`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iomanip>\t\t// for std::setprecision()\n\nint main()\n{\n\tstd::cout << true << '\\n';\n\tstd::cout << false << '\\n';\n\n\tstd::cout << std::boolalpha;\n\n\tstd::cout << true << '\\n';\n\tstd::cout << false << '\\n';\n\n\treturn 0;\n}\n\n#> 1\n#> 0\n#> true\n#> false\n```\n:::\n\n\nThis is similar to the get information from user:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iomanip>\t\t// for std::setprecision()\n\nint main()\n{\n\tstd::cout << \"Enter a boolean value: \";\n\t\n\tbool b{};\n\tstd::cin >> b;\n\t\n\tstd::cout << \"You enter: \" << b << '\\n';\n\n\treturn 0;\n}\n\n#> Enter a Boolean value: true\n#> You entered: 0\n```\n:::\n\n\nWe can do:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iomanip>\t\t// for std::setprecision()\n\nint main()\n{\n\tstd::cout << \"Enter a boolean value: \";\n\t\n\tbool b{};\n\tstd::cin >> std::boolalpha;\n\tstd::cin >> b;\n\t\n\tstd::cout << \"You enter: \" << b << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n#### Boolean return value\n\nWe can create a function that return boolean value:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iomanip>\t\t// for std::setprecision()\n\nbool isEqual(int x, int y) {\n\treturn (x == y);\n}\n\nint getInteger() {\n\tstd::cout << \"Enter an integer: \";\n\tint x{};\n\tstd::cin >> x;\n\n\treturn x;\n}\nint main() {\n\t\n\tint x{ getInteger() };\n\tint y{ getInteger() };\n\n\tstd::cout << std::boolalpha;\n\tstd::cout << \"Does \" << x << \" equal \" << y << \"?\\n\";\n\tstd::cout << isEqual(x, y) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n## Introduction to `if` statement\n\n*Conditional statement* is common in programming language; they allow us to implement conditional behavior into our programs.\n\nThe simplest type of conditional statement in C++ is *if statement*, following the form:\n\n> if (condition) true_statement;\n\n:::{.callout-warning appearance=\"simple\"}\n\nIf statements only conditionally execute a single statement. We talk about how to conditionally execute multiple statements in lesson 7.2 -- If statements and blocks.\n\n:::\n\n## Chars\n## An introduction to explicit type conversion via the `static_cast` operator\n\nIf we want to explicitly change the type of data, we can use\n`static_cast<new_type>(expression)`.^[We see similar term in R: `vctrs::vec_cast()` function that change the type of vector.]\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid print(int x)\n{\n\tstd::cout << x;\n}\n\nint main()\n{\n\tprint( static_cast<int>(5.5) ); // explicitly convert double value 5.5 to an int\n\n\treturn 0;\n}\n```\n:::\n\n\nWe can use this to covert `chart` to `int`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main() {\n\t\n\tchar ch{ 'a' };\n\tstd::cout << ch << '\\n';\n\n\tstd::cout << ch << \" has value \" << static_cast<int>(ch) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nAnother exercise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main() {\n\t\n\tstd::cout << \"Please enter a single character: \";\n\tchar ch{};\n\tstd::cin >> ch;\n\n\tstd::cout << \"You entered '\" << ch << \"'\" << \", which has ASCII code \" << static_cast<int>(ch);\n\n\treturn 0;\n}\n```\n:::\n\n\n\n## Const variables and symbolic constants\n\n**Const variable**: initialized variable with value and cannot assign different values later.\n\nLet look the code to create a const variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    const double gravity{ 9.8 };\n    gravity = 9.9;\n\n    return 0;\n}\n\n#> Error\tC3892\t'gravity': you cannot assign to a variable that is const\n```\n:::\n\n\nAge example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main() \n{\n  std::cout << \"Enter your age: \";\n  \n  int age{};\n  std::cin >> age;\n  \n  const int constAge { age };\n  \n  age = 5         //okie\n  constAge = 6    // error: constAge is constant\n  \n  return 0;\n}\n```\n:::\n\n\nWe can set the const for parameter, but do not prefer to do that.\n\n## Compile-time constants, constant expressions, and constexpr\n\n**Constant expression** is an expression that can be evaluated by the compiler at **compile time**. \n\n**Compile-time constant**: a **constant** whose value is known at compile-time.\n\n:::{.callout-note}\n\nA const variable is a compile-time constant if its initializer is a *constant expression*.\n\nEvaluating const expression takes longer at compile time, but saves time at \nruntime.\n\n:::\n\n**Runtime const**: every const variable initialized with a non-constant expression is a *runtime constant*. Runtime constants are constants whose initialization values are not known until runtime.\n\n### The `constexpr` keyword\n\nCompile always implicitly keep track of const variables to know whether it's a runtime or compile-time const. A \\textbf{constexpr} variable can **only** be compile-time const.\n\nLet read the example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n// constexpr uses\n\tconstexpr double gravity{ 9.8 };\t// ok: 9.8 is a const expression\n\tconstexpr int sum{ 4 + 5 };\t\t\t//ok\n\tconstexpr int something{ sum };\t\t// ok: sum is const expression\n\n\tstd::cout << \"Enter you age: \";\n\tint age{};\n\tstd::cin >> age;\n\n\tconstexpr int myAge{ age };\t\t// compile error: age is not const expression\n\tconstexpr int f{ five() };\t\t// compile error: return value of five() is not constant expression\n```\n:::\n\n\n:::{.callout-tip}\n\n#### Best practice\n\n* Any variable that *should not be modifiable* after initialization and whose initializer is **known** at compile-time should be declared as constexpr.\n* Any variable that *should not be modifiable* after initialization and whose initializer is **not** known at compile-time should be declared as const.\n\n:::\n\n## Literals\n\n**Literals** are unnamed values inserted directly into the code. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreturn 5;\nboot myNameIsAlex{ true };\nstd::cout << 3.4;\n```\n:::\n\n\nLike objects, all literals have type. There type is in\n\n## String\n\nAn example of string is `\"Hello world?\\n\"`; a sequence of characters. String is not natural in C++ language. We use `std::string` to work with string by including the header `<string>` in the header\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <string>\n#include <iostream>\n\nint main()\n{\n\t//std::string name{};\t\t// empty string\n\tstd::string name{ \"Huy\" };\t\t// initialized with value\n\tname = \"Quang\";\n\n\tstd::string myID{ \"45\" };\n\n\tstd::cout << \"My name is \" << name << '\\n';\n\n\tstd::string empty{};\n\tstd::cout << '[' << empty << ']';\n\n\treturn 0;\n}\n```\n:::\n\n\n### String input with std::cin\n\nUsing strings with `std::cin` my yield some surprises. Let see the example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <string>\n#include <iostream>\n\nint main()\n{\n\tstd::cout << \"Enter your full name: \";\n\tstd::string name{};\n\tstd::cin >> name;\n\n\tstd::cout << \"Enter your age: \";\n\tstd::string age{};\n\tstd::cin >> age;\n\n\tstd::cout << \"Your name is \" << name << \" and your age is \" << age << '\\n';\n\n\treturn 0;\n}\n\n#> Input: Quang Huy\n#> Your name is Quang and your age is Huy\n```\n:::\n\n\nNormally, the `>>operator` only extract the string before first space, and the rest is stored for the next `>>operator`.\n\nTo get the full string input, it is better to use `std::getline()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <string>\n#include <iostream>\n\nint main()\n{\n\tstd::cout << \"Enter your full name: \";\n\tstd::string name{};\n\tstd::getline(std::cin >> std::ws, name);\n\n\tstd::cout << \"Enter your age: \";\n\tstd::string age{};\n\tstd::getline(std::cin >> std::ws, age);\n\n\tstd::cout << \"Your name is \" << name << \" and your age is \" << age << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nThe input manipulator `std::ws` tells `std::in` ignore any leading whitespace (spaces, tabs, newlines) in the string. Here is another example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <string>\n#include <iostream>\n\nint main()\n{\n\tstd::cout << \"Pick 1 or 2: \";\n\tint choice{};\n\tstd::cin >> choice;\n\n\tstd::cout << \"Now enter your name: \";\n\tstd::string name{};\n\tstd::getline(std::cin >> std::ws, name);\t\t// no std::ws here\n\tstd::cout << \"Hello \" << name << \", you chose \" << choice << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n:::{.callout-tip}\n\n#### Best practice\n\nIf using `std::getline()` to read strings, use `std::cin >> std::ws` input manipulator to ignore leading whitespace.\n\n:::\n\n### String length\n\nWe use the `length()` function to return the string's length. In C++, the length function is nested in `std::string`, it is written as `std::string::length()` in documentation. Thus, `length()` is not normal standalone function, it is called *member function*.\n\n:::{.callout-note}\n\n#### Key insight\n\nWith normal function, we call `function(object)`. With member function, we call `object.function()`.\n\n:::\n\n`length()` return unsigned integral value, to assign it to integer value, we have to use `static_cast<type><name.length()>`. We can also use `ssize(name)` to get the length as a signed integer.[^1]\n\n[^1]: this function does not exist in our Visual Studio yet.\n\n:::{.callout-tip}\n\n#### Best practice\n\nDo not pass `std::string` by value, as making copies of `std::string` is expensive. Prefer `std::string_view` parameters.\n\n:::\n\n### Literals for `std::string`\n\nWe can create string literals with type `std::string` by using `s` suffix after the double-quote string literal.\n\nHere is the exercise from this session:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <string>\n#include <string_view>\n\nint main()\n{\n\tstd::cout << \"Enter your full name: \";\n\tstd::string name{};\n\tstd::getline(std::cin >> std::ws, name);\n\n\tstd::cout << \"Enter your age: \";\n\tint age{};\n\tstd::cin >> age;\n\n\t//std::cout << \"Your age + length of your name is: \" << age + static_cast<int>(name.length());\n\n\tint letters{ static_cast<int>(name.length()) };\n\tstd::cout << \"Your age + length of your name is: \" << age + letters << '\\n';\n\t\n  return 0;\n}\n```\n:::\n\n\n## Introduction to `std::string_view`\n\nWhen use `std:string`, it creates a copy of the string, this is inefficient. Thus, from C++ 17, there is `std::string_view` from string_view header that provide **read-only access** to an existing string, not a copy of a string.\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <string>\n#include <string_view>\n\nvoid printSV(std::string_view str)\n{\n\tstd::cout << str << '\\n';\n}\nint main()\n{\n\tstd::string_view s{ \"Hello world!\" };\n\tprintSV(s);\n\n\treturn 0;\n}\n```\n:::\n\n\nUnlike `std::string`, `std::string_view` support `constexpr`:\n\n:::{.callout-note}\n\n* Returning a `std::string_view` from a function is usually a bad idea. We will explore why in lesson 11.7 -- std::string_view (part 2). For now, avoid doing so.\n\n* The chapter summary can be found at <https://www.learncpp.com/cpp-tutorial/chapter-4-summary-and-quiz/>\n\n:::\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}