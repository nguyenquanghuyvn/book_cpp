{
  "hash": "4a8641bcc5508b7b168f730f9a75af7f",
  "result": {
    "markdown": "# Operators\n\n## Introduction\n\nAn **operation** is an mathematical calculation involving zero or more input values (called **operand**) to produce a new value. The specific operation to be performed is denoted by a construct (symbol or pair of symbols: +, -, \"\\*\", \"/\", ....) called an **operator**.\n\n**Operator precedence:**\n\n-   In the compound expression (including more than 1 operators), C++ use the rule of **operator precedence**. Each operator is assigned one level, the higher level operator will be evaluate first.\n\n-   When the operators have the same level, C++ uses **operator associativity** that indicates whether the it analyzes from left-to-right or right-to-left.\n\n-   We can use the pasteurization for explicitly say the order of the operator\n\n::: callout-tip\n### Best practice\n\nUse parentheses to make it clear how a non-trivial expression should evaluate (even if they are technically unnecessary).\n:::\n\nFor example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = (y + z + w);   // instead of this\nx = y + z + w;     // it's okay to do this\n\nx = ((y || z) && w); // instead of this\nx = (y || z) && w;   // it's okay to do this\n\nx = (y *= z); // expressions with multiple assignments still benefit from parenthesis\n```\n:::\n\n\n::: {.callout-warning style=\"color: orange\"}\nIn many cases, the operands in a compound expression may evaluate **in any order**. This includes function calls and the arguments to those function calls.\n:::\n\nWe can have the mistakes that the compiler chooses the order differs from what we want:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint getValue()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    return x;\n}\nint main()\n{\n    std::cout << getValue() + (getValue() * getValue());\n\n    return 0;\n}\n```\n:::\n\n\n::: callout-tip\n### Best practice {style=\"color: green\"}\n\nOutside of the operator precedence and associativity rules, assume that the parts of an expression could evaluate in any order. Ensure that the expressions you write are not dependent on the order of evaluation of those parts.\n:::\n\nExample for best practice:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint getValue()\n{\n    std::cout << \"Enter an integer: \";\n    int x{};\n    std::cin >> x;\n\n    return x;\n}\nint main()\n{\n    int a{ getValue() };\n    int b{ getValue() };\n    int c{ getValue() };\n\n    std::cout << a + (b * c);\n\n    return 0;\n}\n```\n:::\n\n\n## Arithmetic operators\n\nThere are two unary arithmetic operators:\n\n![Unary Arithmetic](figure/uniArithmetic.PNG){fig-align=\"left\"}\n\nThe binary arithmetic operators:\n\n![Binary Arithmetic](figure/binaryAri.PNG){fig-align=\"left\"}\n\nArithmetic assignment operators\n\n![Arithmetic Assignment operators](figure/assignArithmetic.PNG)\n\n## Increment/decrements operators, and side effects\n\n![Increment/decrement operators](figure/increment_decrement_operators.PNG)\n\nLet have an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    int x{ 5 };\n    int y{ 5 };\n\n    std::cout << x << ' ' << y << '\\n';\n    std::cout << ++x << ' ' << --y << '\\n'; // prefix make the calculation \n                                           //  and assign directly\n    std::cout << x << ' ' << y << '\\n';\n\n    std::cout << x++ << ' ' << y-- << '\\n'; // postfix creates a copy, calcul, \n                                            // and return the copy\n    std::cout << x << ' ' << y << '\\n';\n\n    return 0;\n}\n```\n:::\n\n\n::: callout-tip\n#### Best practice\n\nStrongly favor the prefix version.\n:::\n\n### Side effects can cause undefined behavior\n\n> A function or expression is said to have a **side effect** if has some obervable effect beyond producing a return value.\n\nCommon examples are assignment value of objects, doing input, output,... Most of the time, side effects are useful:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx = 5;\n++x;\nstd::cout << x\n```\n:::\n\n\nHowever, side effects can also lead to unexpected results:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint add(int x, int y)\n{\n    return x + y;\n}\n\nint main()\n{\n    int x{ 5 };\n    \n    int value{ add(x, ++x) };\n    std::cout << value << '\\n'; // value depends on how the above line evaluates\n\n    return 0;\n}\n```\n:::\n\n\n::: callout-warning\n-   C++ does not define the order of evaluation for function arguments or the operands of operators.\n\n-   Don't use a variable that has a side effect applied to it more than once in a given statement. If you do, the result may be undefined.\n:::\n\n## Comma and conditional operators\n\n![Comma operator](figure/commaOperator.PNG)\n\nThe comma operator allows us to evaluate multiple expressions wherever a single expression is allowed.\n\nIn almost every case, a statement written using the comma operator would be better written as a separate statements.\n\n::: callout-tip\n### Best practice\n\nAvoid using the comma operator, except within `for` loops\n:::\n\n### Comma as a separator\n\nIn C++, comma symbol is often used as a separator, and does not invoke the comma operator:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid foo(int x, int y) // Comma used to separate parameters in function definition\n{\n    add(x, y); // Comma used to separate arguments in function call\n    constexpr int z{ 3 }, w{ 5 }; // Comma used to separate multiple variables being defined on the same line (don't do this)\n}\n```\n:::\n\n\n### Conditional operator\n\n![Conditional operator](figure/conditionalOperator.PNG)\n\nAlways parenthesize the conditional part of the conditional operator, and consider parenthesizing the whole thing as well.\n\n#### The conditional operator evaluates as an expression\n\nBecause the conditional operator operands are expressions rather than statements, the conditional operator can be used in some places where `if/else` cannot.\n\n::: callout-warning\nThe type of expressions in conditional operator must match or be convertible.\n:::\n\nThe conditional operator gives us a convenient way to compact some if/else statements. It's most useful when we need a conditional initializer (or assignment) for a variable, or to pass a conditional value to a function.\n\n## Relational operators and floating point comparisons\n\n![Relational Operators](figure/relationalOperator.PNG)\n\nComparison of **calculated** floating point values can be problematic.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n    double d1{ 100.0 - 99.99 }; // should equal 0.01 mathematically\n    double d2{ 10.0 - 9.99 }; // should equal 0.01 mathematically\n\n    if (d1 == d2)\n        std::cout << \"d1 == d2\" << '\\n';\n    else if (d1 > d2)\n        std::cout << \"d1 > d2\" << '\\n';\n    else if (d1 < d2)\n        std::cout << \"d1 < d2\" << '\\n';\n\n    return 0;\n}\n#> d1 > d2  : error\n```\n:::\n\n\nAvoid using operator== and operator!= to compare floating point values if there is any chance those values have been calculated.\n",
    "supporting": [
      "c5_operators_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}