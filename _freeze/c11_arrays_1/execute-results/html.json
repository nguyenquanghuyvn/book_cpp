{
  "hash": "fb781467114f21533ea791c937e3c9cb",
  "result": {
    "markdown": "---\ntitle: \"Arrays (Part 1)\"\n---\n\n\n:::{.callout-note}\n\nThis chapter is a bit harder than the previous ones. If you feel a little discouraged, stick with it. The best stuff is yet to come!\n\n:::\n\nAn **array** is an aggregate data type that we can access many variables of the same type through a **single** object.\n\nThis is an example definition of **fixed array** (fixed length/size): `int test_score[30]{};`.\n\nEach variables in an array is called **element** which does not their unique name.\nWe access the element by giving use **subscript operator ([])** and its **index** start from `0`.\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tint prime[5]{};\n\tprime[0] = 2;\n\tprime[1] = 3;\n\tprime[2] = 5;\n\tprime[3] = 7;\n\tprime[4] = 11;\n\n\tstd::cout << \"The lowest prime number is: \" << prime[0] << '\\n';\n\tstd::cout << \"The sum of the first 3 primes is: \" << prime[0] + prime[1] + prime[2] << '\\n';\n\t\n\treturn 0;\n}\n```\n:::\n\n\nArray can made from **any** data type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstruct Rectangle\n{\n\tint length{};\n\tint width{};\n};\n\n\tdouble battery_life_hour[3]{};\n\tbattery_life_hour[0] = 2.0;\n\tbattery_life_hour[1] = 3.0;\n\tbattery_life_hour[2] = 4.3;\n\n\tRectangle rects[2]{};\n\trects[0].length = 24;\n\trects[0].width = 10;\n\t\n\trects[1].length = 30;\n\trects[1].width = 20;\n```\n:::\n\n\n#### Array subscripts\n\nWe can use the following ways for array's index\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\tint array[5]{};\n\n\tenum Animals\n\t{\n\t\tanimal_cat = 2,\n\t};\n\n\tarray[animal_cat] = 2;\n\n\tint index{ 3 };\n\tarray[index] = 4;\n\n\tarray[1 + 2] = 5;\n```\n:::\n\n\n#### Fixed-array declaration\n\nThe array's length must be a compile-time constant, known at compile-time:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\tint number_days_in_week[7]{};\n\n\tconstexpr int days_per_week{ 7 };\n\tint numbers_day_in_week_2[days_per_week]{};\n\n\tenum DaysOfWeek\n\t{\n\t\tmonday,\n\t\ttuesday,\n\t\twednesday,\n\t\tthursday,\n\t\tfriday,\n\t\tsaturday,\n\t\tsunday,\n\n\t\tmaxDaysOfWeek\n\t};\n\tint numberOfLessonsPerDay[maxDaysOfWeek]{};\n```\n:::\n\n\nBut, we cannot use the following ways:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# using a non-const variable\nint daysPerWeek{};\nstd::cin >> daysPerWeek;\nint numberOfLessonsPerDay[daysPerWeek]{}; #!!! Not ok -- daysPerWeek is not a compile-time constant!\n\n// using a runtime const variable\nint temp{ 5 };\nconst int daysPerWeek{ temp }; #!!! the value of daysPerWeek isn't known until runtime, so this is a runtime constant, not a compile-time constant!\n\nint numberOfLessonsPerDay[daysPerWeek]{}; #!!! Not ok\n```\n:::\n\n\n#### Enum and array\n\nWe use data type `enum` as the array's length. This helps us have meaning full variable name instead of **magic numbers**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\n#' We put it in  a namespace\nnamespace student_names\n{\n\tenum Student_names\n\t{\n\t\tkenny,\n\t\tkyle,\n\t\tstan,\n\t\tbutters,\n\t\tcartman,\n\t\twendy,\n\n\t\tmax_students\n\t};\n}\n\nint main()\n{\n\tint test_scores[student_names::max_students]{};\n\ttest_scores[student_names::stan] = 76;\n\n\treturn 0;\n}\n```\n:::\n\n\n#### Passing array to functions\n\nC++ **does not copy** an array passed to a function. Instead, an actual array is passed => function can change array's elements.\n\nIf we do not that function change array, we put an array as const: `const int array[5]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid pass_array(int array[2])\n{\n\tarray[0] = 2;\n\tarray[1] = 5;\n}\n\nint main()\n{\n\tint test_scores[student_names::max_students]{};\n\ttest_scores[student_names::stan] = 76;\n\n\t// Pass array to function\n\tint array[2]{ 1, 2 };\n\n\tstd::cout << \"Before pass: \";\n\tfor (int i = 0; i <=  1; i++)\n\t{\n\t\tstd::cout << array[i] << ' ';\n\t}\n\n\tpass_array(array);\n\tstd::cout << \"\\nAfter pass: \";\n\tfor (int i = 0; i <= 1; i++)\n\t{\n\t\tstd::cout << array[i] << ' ';\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n\n#### Size of array\n\nWe use `std::size()` to get the length of array (number of its elements). \n\n`std::size()` will get error if we want to use it in a fixed array that passed to a function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid somefunc(int* array) #// Later, actually, array is pass to address\n{\n    std::size(array) #!!! compile error.\n}\n\nint main()\n{\n    int array[]{1, 2, 3};\n    \n    std::cout << \"Array's length: \" << std::size(array) << '\\n'; #\\\\ okie\n    \n\n    \n}\n```\n:::\n\n\nOther function is `sizeof()`, but this returns to whole size of array (elements * size per elements).\n\n## Loop and arrays\n\nWe can always use array with loop\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iterator>\n\nint main()\n{\n\tconstexpr int scores[]{ 84, 92, 76, 81, 56 };\n\tconstexpr int number_students{ static_cast<int>(std::size(scores)) };\n\n\tint total_scores{ 0 };\n\n\tfor (int i = 0; i < number_students; i++)\n\t{\n\t\ttotal_scores += scores[i];\n\t}\n\n\tauto average_scores{ static_cast<double>(total_scores) / number_students };\n\n\treturn 0;\n}\n```\n:::\n\n\nAn example that use loop to find the max in an array:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\tint max_scores{ 0 };\n\n\tfor ( int i = 0; i < number_students; i++)\n\t{\n\t\tif (scores[i] > max_scores)\n\t\t\tmax_scores = scores[i];\n\t}\n\n\tstd::cout << \"The best score was \" << max_scores << '\\n';\n```\n:::\n\n\nHere is from exercise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iterator>\n#include <random>\n\n// Create random generators\n\nstd::mt19937 mt{ std::random_device{}() };\nstd::uniform_int_distribution array10{ 1, 9 };\n\nvoid get_array(int array[10])\n{\n\tfor (int counter{ 0 }; counter < 10; ++counter)\n\t{\n\t\tarray[counter] = array10(mt);\n\t}\n}\n\nvoid print(int array[10])\n{\n\tfor (int counter = 0; counter < 10; counter++)\n\t{\n\t\tstd::cout << array[counter] << ' ';\n\t}\n\n\tstd::cout << '\\n';\n}\nint get_index()\n{\n\twhile (true)\n\t{\n\t\tstd::cout << \"Enter an integer between 1 and 9: \";\n\t\tint index{};\n\t\tstd::cin >> index;\n\t\tif (std::cin.fail())\n\t\t{\n\t\t\tstd::cin.clear();\n\t\t\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\t\t}\n\t\telse\n\t\t\treturn index;\n\t}\n}\n\nint search_index(int array[10], int number)\n{\n\tfor (int index{ 0 }; index < 10; ++index)\n\t{\n\t\tif (number == array[index])\n\t\t\treturn index;\n\t}\n\n\tstd::cout << \"There does not exit  your number in our array.\\n\";\n}\n\nint main()\n{\n\t\n\tint array[10]{ 4, 6, 7, 3, 8, 2, 1, 9, 5 };\n\t//get_array(array);\n\tprint(array);\n\t\n\tint number{ get_index() };\n\n\t//std::cout << \"The index \" << index << \" has number \" << array[index] << '\\n';\n\t\nstd::cout << \"The number \" << number << \" has index \";\n\tstd::cout << search_index(array, number) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n## Sorting an array using selection sort\n\nIn this session, we can use the function `std::swap()` from header `utility` to swap the positions of two variables.\n\n### Selection sort\n\nThis is the easy method, but lowest one:\n\n1. Starting at array index 0, search the entire array to find the smallest value\n2. Swap the smallest value found in a array with the value at index 0\n3. Repeat step 1 and 2 starting from the next index\n\nHere is an example selection sorting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iterator>\n#include <utility>\n#include <random>\n\nvoid sort(int array[], int length)\n{\n\tfor (int start_index{ 0 }; start_index < length; ++start_index)\n\t{\n\t\tint smallest_index{ start_index };\n\n\t\tfor (int current_index{ start_index + 1 }; current_index < length; ++current_index)\n\t\t{\n\t\t\tif (array[current_index] < array[smallest_index])\n\t\t\t\tsmallest_index = current_index;\n\t\t}\n\n\t\tstd::swap(array[start_index], array[smallest_index]);\n\t}\n}\n\nvoid print(int array[], int length)\n{\n\tfor (int index{ 0 }; index < length; ++index)\n\t{\n\t\tstd::cout << array[index] << ' ';\n\t}\n\n\tstd::cout << '\\n';\n}\n\nvoid random_array(int array[], int length)\n{\n\tstd::mt19937 mt{ std::random_device{}() };\n\n\tstd::uniform_int_distribution value{ 1, 100 };\n\n\tfor (int index{ 0 }; index < length; ++index)\n\t{\n\t\tarray[index] = value(mt);\n\t}\n}\n\nint main()\n{\n\tint array[20]{};\n\tconstexpr int length{ static_cast<int>(std::size(array)) };\n\n\trandom_array(array, length);\n\tstd::cout << \"Array before sorting: \\n\";\n\tprint(array, length);\n\n\tsort(array, length);\n\tstd::cout << \"Array after sorting: \\n\";\n\tprint(array, length);\n}\n```\n:::\n\n\nHere is an example of bubble sorting:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemplate <typename T>\nvoid sort_bubble(T array[], int length)\n{\n\tfor (int start_index{ 0 }; start_index < length - 1; ++start_index)\n\t{\n\t\tint count_swap{ 0 };\n\t\tfor (int index{ 0 }; index < length - start_index - 1; ++index)\n\t\t{\n\t\t\tif (array[index] > array[index + 1])\n\t\t\t{\n\t\t\t\tstd::swap(array[index], array[index + 1]);\n\t\t\t\t++count_swap;\n\t\t\t}\n\t\t}\n\n\t\tif (count_swap == 0)\n\t\t{\n\t\t\tstd::cout << \"\\nEarly termination on interation \" << start_index << '\\n';\n\t\t\tbreak;\n\t\t}\n\t}\n}\n```\n:::\n\n\n### std::sort\n\nWe can use `std::sort` from the `algorithm` header.\n\n## Multidimensional Arrays\n\nAn array can include any data type, even an **array** too. We can create a multidimensional array:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\tint array[3][5]\n\t{\n\t\t{1, 2, 3, 4, 5 },\n\t\t{6, 7, 8, 9, 10},\n\t\t{11, 12, 13, 14, 15},\n\t};\n```\n:::\n\n\nWe can ommit the left-most length, but not the rightmost; we can use zero initializer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\tint array2[][3]\n\t{\n\t\t{1, 2, 3},\n\t\t{4, 5, 6},\n\t}\n\n\t// Zero initializer\n\tint array3[3][3]{};\n```\n:::\n\n\nPrint array:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemplate <typename T>\nvoid print(T array[][3])\n{\n\tfor (int row{ 0 }; row < 2; ++row)\n\t{\n\t\tfor (int column{ 0 }; column < 3; ++column)\n\t\t{\n\t\t\tstd::cout << array[row][column] << ' ';\n\t\t}\n\n\t\tstd::cout << '\\n';\n\t}\n}\n```\n:::\n\n\n## C-style string\n\nA **C-style string** is simply an array of characters that uses **null terminator** `\\0`.\n\nThis is an example of C-Style string:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iterator>\n\nint main()\n{\n\tchar myString[]{ \"string\" };\n\tconst int length{ static_cast<int>(std::size(myString)) };\n\n\tstd::cout << myString << \" has \" << length << \" characters.\\n\";\n\n\treturn 0;\n}\n```\n:::\n\n\n`std::cout` only print the string until encountering `\\0`, the rest of array are ignored.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main()\n{\n    char name[20]{ \"Alex\" }; // only use 5 characters (4 letters + null terminator)\n    std::cout << \"My name is: \" << name << '\\n';\n\n    return 0;\n}\n\n#> Alex\n```\n:::\n\n\n:::{.callout-tip}\n\nDo not use C-style string. Use `std::string` or `std::string_view`.\n\n:::\n\n#### C-style strings and `std::cin`\n\nSome cases that we do not know in advance how long our string is going to be. To cope with this, we use the code `getline(name, std::size(name))`. \n\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <iterator> // for std::size\n\nint main()\n{\n    char name[255] {}; // declare array large enough to hold 254 characters + null terminator\n    std::cout << \"Enter your name: \";\n    std::cin.getline(name, std::size(name));\n    std::cout << \"You entered: \" << name << '\\n';\n\n    return 0;\n}\n```\n:::\n\n\n## `std::string_view` (part 2)\n\n`std::string` make a copy for the string created:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main()\n{\n\n\tchar text[]{ \"Hello\" };\n\tstd::string str{ text };\n\tstd::string more{ str };\n\n\n\n\treturn 0;\n}\n```\n:::\n\n\nIn the above example, there are 4 copies `Hello`. First, the literal string store in the binary as the compile-time. Second is when we create `char[]` and the other two from `std::string`.\n\nThe `std::string_view` provides a *view* of a string defined elsewhere: it does not copy the string.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    using namespace std::literals # using the prefix `sv`    \n\n\tconst char text[]{ \"Hello\" };\n\tstd::string_view str{ text };\n\tstd::string_view more{ str };\n\t\n\tauto str2{\"Hello\" sv};\n```\n:::\n\n\nThere are useful operations (functions) to use for `string_view` that can be found at <https://en.cppreference.com/w/cpp/string/basic_string_view>.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\tauto str2{ \"Today is sunny\"sv };\n\n\tstd::cout << str2.length() << '\\n';\n\tstd::cout << std::boolalpha;\n\tstd::cout\n\t\t<< str2.starts_with(\"Today\") << '\\n'\n\t\t<< str2.starts_with(\"Yesterday\") << '\\n'\n\t\t<< str2.substr(0, str2.find(' ')) << '\\n';\n```\n:::\n\n\nNotice that if we change the `text`, then the string_view `str` changes too.\n\n#### `std::string_view` works with non-null-terminated strings\n\n`std::string_view` does not use null terminators to mark the end of the string. It keeps track of its length to know the string ends.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\tchar vowel[]{ 'a', 'e', 'i', 'o', 'u' };\n\tstd::string_view str3{ vowel, std::size(vowel) };\n\n\tstd::cout << str3 << '\\n';\n```\n:::\n\n\n### Why are `std::string_view` parameters more efficient than `const std::string&`?\n\nThe figure below summaries our answer:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninclude.graphic\n```\n:::\n\n\nWe can use `str.data()` to access the string that is viewed. This function return a C-style string.\n\nAs I understand, when we create a string_view object, the viewed object is as `C-style string` (literal initializer) or `std::string` with null terminator. It is fine to use `data()` to point to the first character of viewed object. But, when we use `str.remove_suffix()`, it remove null terminator. The use of `data()` results undefined behavior.\n\n## Array and pointer\n\nWhen a fixed array is used as an **expression**, it will **decay** into a pointer that points to the first element of the array.\n\nBut array and pointer are **not** identical. Array is of type `int[]`, pointer is of type `int*`. \n\nWe can access the array's element value through the pointer. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tint array[5]{ 1, 2, 3, 4, 5 };\n\n\tstd::cout \n\t\t<< \"First element of array has address: \" \n\t\t<< &array[0] \n\t\t<< '\\n';\n\n\tstd::cout\n\t\t<< \"The array decays to a pointer holding address: \"\n\t\t<< array\t// array as an expression\n\t\t<< '\\n';\n\n\t# Access element's value by pointer\n\tstd::cout << *array << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nWe can assign a pointer to point at the array:\n\n::: {.cell}\n\n```{.r .cell-code}\n    int array[5]{ 1, 2, 3, 4, 5 };\n\tint* ptr{ array };  # point to the first element\n```\n:::\n\n\nArray and pointer have some differences:\n\n* The fixed array knows how long the array it is pointing to is. A pointer to the array does not.\n* Taking the address of a pointer yields the memory address of the pointer variable. Of an array return pointer to the entire array.\n    * Type of `&array` is `int(*)[]`\n    \n#### Revisiting passing fixed arrays to functions\n\nWhen passing an array as an argument to a function, a fixed array **decays into a pointer**, and the pointer is passed to the function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid print_size(int* array)\n{\n\tstd::cout << sizeof(array) << '\\n';\n}\n#// the size of a pointer, not an array\n\n#// If the parameter is int array, C++ implicitly converses to pointer\n```\n:::\n\n\nThe two functions are the same: `void print_size(int* array)` and `void print_size(int array[])`.\n\n## Pointer arithmetic and array indexing\n\n### Pointer arithmetic\n\nIf `ptr` points to an integer, then `ptr + 1` is the address of the next integer in memory after `ptr`; similar to `ptr - 1`.\n\n`ptr + 1` does not return to *memory address* after `ptr`, but the memory address of *next object of the type* the `ptr` points to.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tint value{ 7 };\n\tint* ptr{ &value };\n\n\tstd::cout\n\t\t<< ptr << '\\n'\n\t\t<< ptr + 1 << '\\n'\n\t\t<< ptr + 2 << '\\n'\n\t\t<< ptr + 3 << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nArray's elements are in sequence in memory. We know that fixed array return a pointer to an address of first element. Thus, adding 1 to an array `array + 1`, should point to the second element of the array.\n\nLet look at the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbool is_vowel(char ch)\n{\n\tswitch (ch)\n\t{\n\tcase 'A':\n\tcase'a':\n\tcase 'E':\n\tcase 'e':\n\tcase 'I':\n\tcase 'i':\n\tcase 'O':\n\tcase 'o':\n\tcase 'U':\n\tcase 'u':\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\nint main()\n{\n\tchar name[]{ \"Phuong\" };\n\tint array_length{ static_cast<int>(std::size(name)) };\n\tint number_vowel{ 0 };\n\n\tfor (char* ptr{ name }; ptr != (name + array_length); ++ptr)\n\t{\n\t\tif (is_vowel(*ptr))\n\t\t{\n\n\t\t\t++number_vowel;\n\t\t}\n\t}\n\n\tstd::cout << name << \" has \" << number_vowel_func(name) << \" vowels.\\n\";\n\n\treturn 0;\n}\n```\n:::\n\n\nWe can use `std::count_if` from `algorithm` header:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use the function std::count_if from algorithm header\nauto number_vowel_std{ std::count_if(std::begin(name), std::end(name), is_vowel) };\nstd::cout << name << \" has \" << number_vowel_std << \" vowels.\\n\";\n```\n:::\n\n\n## Dynamic memory allocation with new and delete\n\n**Static variable** and **local variable** has static allocation and auto allocation respectively. These allocation is on the **stack** memory which is size limited. They also require that the compiler knows the size at their definition.\n\nThe allocations invoke some limitation in programing if we need the size change frequently or big size memory.\n\nTo solve that, C++ has **dynamic memory allocation**; it requests memory from the memory pool in system (**heap**) when it needs.\n\n### Single variable's dynamic allocation\n\nWe use the keyword `new` to tell the program create a dynamic allocation. The computer returns a pointer to the address of the memory allocated.\n\nWe need to create a pointer to keep track of that memory.\n\nTo release the memory back to the computer we use `delete ptr`; this does not delete the `ptr`, so that pointer is dangling pointer and may cause undefined behavior. We can assign that pointer to `nullptr`, a null pointer.\n\nHere is an example code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\nint* ptr{ new int };\n*ptr = 7;\n\t\ndelete ptr;\t\n#' return the memory back to the computer, ptr is dangling pointer\n\nstd::cout << *ptr << '\\n';  \ndelete ptr;\t\n#' try to deallocate the memory again lead to undefined behavior\n\nreturn 0;\n}\n```\n:::\n\n\n#### Operator `new` can fail\n\nWe can add `std::nothrow` between the `new` keyword and the allocation type such as `int* ptr{new (std::nothrow) int};`. Using this code, if the operator fail, it returns a null pointer.\n\n#### Null pointer and dynamic allocation\n\nNull pointer is very useful to work with dynamic memory allocation. It says \"no memory has been allocated to this pointer\". It allows us to do things like conditionally allocate memory\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (!ptr)\n    ptr = new int;\n```\n:::\n\n\n#### Memory leak\n\nThe pointer to a dynamic allocation memory is a normal variable so its scope follows the normal rule. The dynamic allocation object is only return to operate when we call `delete` keyword. There are some cases that the pointer to it goes out of scope without call `delete`. From that fact, our operate system still keep that memory for the program but we neither access it nor delete it because we do not know its address. We call it **memory leak**.\n\n## Dynamic allocation arrays\n\nWe use the following code to create and delete dynamic allocation arrays:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tstd::cout << \"Enter a positive integer for array's length: \";\n\tint length{};\n\tstd::cin >> length;\n\n\tint* array{ new int[length] {} };\n\tstd::cout << \"I just allocated an array of integers of length \" << length << '\\n';\n\n\tarray[0] = 5;\n\n\tdelete[] array;\t\t \n    #//use array delete[] to deallocate array\n\t#// array is going out of scope inmmeidately after this anyway\n\n\treturn 0;\n}\n```\n:::\n\n\nRemember using `delete[]` not `delete`.\n\nDynamic array are almost identical to fixed arrays:\n\n* It decays to pointer to the first element\n* It does not know  its length or size (return from std::size is a pointer size; return from sizeof is pointer size * number of element).\n\nDynamic array allows us to set the array's length at the time of allocation, but C++ does not allow us to resize it.\n\nTo do this, we can use a resizable array called `std::vector`.\n\nHere is the code for the exercise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nauto get_number_name()\n{\n\tstd::cout << \"How many names would you like to enter?: \\n\" << \"Your repsonse: \";\n\tint number_name{};\n\tstd::cin >> number_name;\n\n\treturn number_name;\n}\n\nauto enter_name()\n{\n\t\tstd::string name{};\n\t\tstd::getline(std::cin >> std::ws, name);\n\t\n\t\treturn name;\n}\n\nvoid assign_array_value(std::string* array, int length)\n{\n\tfor (int index{ 0 }; index < length; ++index)\n\t{\n\t\tstd::cout\n\t\t\t<< \"Enter name #\"\n\t\t\t<< index + 1\n\t\t\t<< \" : \";\n\t\tstd::getline(std::cin >> std::ws, array[index]);\n\t}\n}\n\nvoid print(std::string* array, int length)\n{\n\tfor (int index{ 0 }; index < length; ++index)\n\t{\n\t\tstd::cout\n\t\t\t<< \"Enter name #\"\n\t\t\t<< index + 1\n\t\t\t<< \" : \"\n\t\t\t<< array[index]\n\t\t\t<< '\\n';\n\t}\n}\n\nint main()\n{\n\tint number_name{ get_number_name() };\n\tstd::string* array_name{ new std::string[number_name]{} };\n\n\tstd::cout << \"\\nPlease enter the names: \\n\";\n\tassign_array_value(array_name, number_name);\n\n\tstd::sort(array_name, array_name + number_name);\n\t\n\tstd::cout << \"\\nHere is your sorted list: \\n\";\n\tprint(array_name, number_name);\n\n\tdelete[] array_name;\n\n\treturn 0;\n}\n```\n:::\n\n\n## For-each loop\nThe *for-each* statement has the syntax:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (element_statment: array)\n    statement;\n```\n:::\n\n\nThe loop will iterate through each element in array, assigning the value of the current array element to the variable declared in element_declaration:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconstexpr int scores2[]{ 1, 2, 3, 4, 5 };\n\n#// Print the array\nfor (int score : scores2)\n{\n\tstd::cout << score << ' ';\n}\n\nstd::cout << '\\n';\n```\n:::\n\n\n#### For-each loops and the `auto` keyword\n\nThe type of element_statement is the same type of array's element, so we can use the `auto` keyword.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconstexpr int scores2[]{ 1, 2, 3, 4, 5 };\n\n#// Print the array\nfor (auto score : scores2)\n{\n\tstd::cout << score << ' ';\n}\n\nstd::cout << '\\n';\n```\n:::\n\n\n#### for-each loops and references\n\nIn for-each loops, the statement_element copies the element's value. This is expensive. To avoid this, we can create the statement_element that **refer** to the array's element value\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (auto& score : scores2)\n\t{\n\t\tstd::cout << score << ' ';\n\t}\n```\n:::\n\n\nWe can also make it *constant*, if we just want to read only it.\n\n:::{.callout-note}\n\nTo use for-each, the array:\n\n* Not to be decayed to a pointer\n* Have size information\n\n:::\n\n#### For-each and non-arrays\n\nFor-array can work with other types of data like vector\n\n## Void pointer\n\nWe can create a void pointer that can point to any type of data. But the void pointer does not know the data type that it is pointing to, we cannot dereference it to get value.\n\nIf we want to dereference, we create another pointer which initialize by the cast the void pointer to the true type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <cassert>\n\nint nValue{};\nfloat fValue{};\n\nstruct Something\n{\n\tint n;\n\tfloat f;\n};\n\n\nint main()\n{\n\tvoid* ptr;\n\n\tSomething sValue{0, 2.0};\n\tint value{ 5 };\n\n\tptr = &nValue;\t#// valid\n\tptr = &fValue;\t#// valid\n\tptr = &sValue;\t#// valid\n\tptr = &value;\n\n\tstd::cout << *ptr << '\\n';\t#// illegal: dereference of void pointer\n\n\tint* intPtr{ static_cast<int*>(ptr) };\n\n\tstd::cout << *intPtr << '\\n';\t#// valid\n\n\treturn 0;\n}\n```\n:::\n\n\nThis is impossible to do **pointer arithmetic** on void pointer because the pointer has to know what size object it is pointing to.\n\n## An introduction to `std::array`\n\nBuild-in array has limitations:\n\n* Decay to pointer when we pass it to a function's parameter, so it does known its size\n* Problem of dealloation of dynamic allocation array\n\nThus, there is `std::array` in the `array` header. Here the code to create it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <array>\n\nint main()\n{\n\tstd::array<int, 5> array1{ 1, 2, 3, 4, 5 };\n\tstd::array array2{ 1, 2, 3 };\t// From C++17, allow to omit both type and length\n\n\t#// Use function `at()` or `[]` to access the array's element\n\t#// But at() does the boundary check to avoid out-of-bound program at runtime\n\tarray2.at(1) = 3;\t#// Equivalent to array2[1] = 3\n}\n```\n:::\n\n\nWe can use `at()` to access array's element. It is slower than `[]`, but is safer.\n\n### Size and sorting\n\nUse `myArray.size()` to get the array's size. The `std::array()` does not decay to pointer when we pass it to function, so we can use `size()` inside a called function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid print_length(const std::array<int, 5>& my_array) #// why have to put int, 5\n{\n\tstd::cout << \"Length: \" << my_array.size() << '\\n';\n}\n```\n:::\n\n\n:::{.callout-tip}\n\nAlways pass `std::array` object by reference or `const` reference to function's parameter\n\n:::\n\n### Passing `std::array` of different length to a function\n\nWe use the template for array type (`typename T`) and array size (`std::size_t`):\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <array>\n#include <cstddef>\t// for std::size_t\n#include <iostream>\n\n//array_print() is a template function\ntemplate <typename T, std::size_t size>\nvoid array_print(const std::array<T, size>& array)\n{\n\tfor (auto element : array)\n\t\tstd::cout << element << ' ';\n\t\n\tstd::cout << '\\n';\n}\n\nint main()\n{\n\tstd::array my_array{ 9.0, 7.2, 3.6, 1.8 };\n\tarray_print(my_array);\n\n\tstd::array my_array2{ 1, 3, 4, 2, 6 , 5, 9 ,7 };\n\tarray_print(my_array2);\n\n\treturn 0;\n}\n```\n:::\n\n\nWith std::array, the element type and array length are part of type information, thus we have to specify them as a function parameter.\n\nWe use `template <typename T, std::size_t size>` to create a function work with `std::array`.\n\n#### `size_t`\n\nIn `std::array`, the function `size()` and the operator`[]` return the object type `size_t`, thus we intitialize `std::size_t` in for loops.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\t#// Use std::array with for loops\n\tfor (std::size_t index{ 0 }; index < my_array2.size(); ++index)\n\t\tstd::cout << my_array2.at(index) << ' ';\n```\n:::\n\n\n### Array of struct\n\nWe can have a `std::array` of struct:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntruct House\n{\n\tint number{};\n\tint stories{};\n\tint room_per_story{};\n};\n\nint main()\n{\n\t#// Array of struct\n\tstd::array<House, 3> houses{};\n\thouses[0] = { 14, 3, 30 };\n\thouses[1] = { 14, 3, 10 };\n\thouses[2] = { 15, 3, 40 };\n\n\t#// Other way to initialize array of struct\n\tstd::array<House, 3> houses2{\n\t\t{\n\t\t\t{14, 3, 30},\n\t\t\t{14, 3, 10},\n\t\t\t{15, 3, 40},\n\t\t}\n\t};\n\n\treturn 0;\n}\n```\n:::\n\n\n## Introduction to std::vector\n\n`std::vector` provides dynamic array functionality that handles its own memory management. We can create an array that have its length set at *run-time*, without using `new` and `delete`.\n\nWe use `std::vector` from header `vector`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <cstddef>\n#include <vector>\n\nint main()\n{\n\tstd::vector<int> v1;\n\tstd::vector<int> v2 = { 9, 7, 5, 3, 1 };\n\tstd::vector<int> v3{ 9, 7, 5, 3, 1 };\n\t\n\t#// From C++17:\n\tstd::vector v4{9, 7, 5, 3, 1};\n    \n    #// Declare a vector size\n    std::vector<TYPE> v6(vector_size);\n\n\tint vec_length{};\n\tstd::cout << \"Enter the vector's length: \";\n\tstd::cin >> vec_length;\n\n\tstd::vector<int> v5(vec_length);\n\n\tfor (int index{ 0 }; index < vec_length; ++index)\n\t{\n\t\tstd::cout << \"Enter value #\" << index + 1 << \": \";\n\t\tstd::cin >> v5.at(index);\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n\nWe use operator `[]` and also function `at()` to access vector's elements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#// Assign value to vector's element\nv4[1] = 2;\nv4.at(3) = 4;\n```\n:::\n\n\nBuilt-in dynamics array does not know its length they are pointing to, `std::vector` keeps track of its length and can extract from `size()`. Notice that `size()` always returns object type `size_type`, full type `std::vector<int>::size_type`, which is an unsigned integer.\n\nWe can resize a vector by `resize()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv4.resize(6);\n```\n:::\n\n\n## Introduction to iterators\n\nAn **iterator** is an object designed to traverse through a *container*, providing *access to each element* along the way.\n\n#### Pointer as an iterator\n\nThe simplest kind of iterators is a pointer that work for data stored sequentially. We can use the pointer and pointer arithmetic to access the element and use in loops.\n\nThe `std::array` provides functions `begin()` and `end()` to access the pointer to the begin and end of an array.\n\nHere is an example code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#//Pointer as an iterators\n\nstd::array arr{ 1, 3, 4, 7, 8, 5, 9 };\t\n\nstd::cout << \"Use pointer: \\n\";\nauto begin{ arr.begin()};\nauto end{ arr.end()};\n\nfor (auto ptr{ begin }; ptr != end; ++ptr)\n{\n\tstd::cout << *ptr << ' ';\n}\n\nstd::cout << '\\n';\n\n#// Use the iterator header\n\nbegin = std::begin(arr);\nend = std::end(arr);\n```\n:::\n\n\n#### Invalidated iterators\n\nIf iterated elements are deleted or changed the address, the iterators to that element is **invalidated**; this iterator has undefined behaviors:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\t#// Invalidated iterators\n\tstd::vector v{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n\t\n\tauto it{ v.begin() };\n\t++it;\n\tstd::cout << *it << '\\n';\n\tv.erase(it);\t#// ecrease element currently being iterated over\n\n\t++it;\t#// undefined behavior\n\tstd::cout << *it << '\\n'; \n```\n:::\n\n\n## Introduction to standard library algorithm\n\nHeader `algorithm` contains the functions help us work with data efficiently and safely. \n\n### `std::find` to find an element by a value\n\nThe function takes three parameters: an iterator to the starting element, an iterator to the end of element, and the value to search for.\n\n`std::find` returns a pointer to the element found.\n\nFor example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <array>\n#include <algorithm>\n\nvoid handle_cin_fail()\n{\n\t\tstd::cin.clear();\n\t\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n}\n\nint get_input()\n{\n\tint input{};\n\tstd::cin >> input;\n\n\twhile (std::cin.fail())\n\t{\n\t\thandle_cin_fail();\n\n\t\tstd::cout << \"Invalid value. Enter again: \";\n\t\tstd::cin >> input;\n\t}\n\n\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n\treturn input;\n}\n\nbool confirm()\n{\n\tchar c{};\n\tstd::cin >> c;\n\tstd::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n\tswitch (c)\n\t{\n\tcase 'y':\n\t\treturn true;\n\tcase 'n':\n\t\treturn false;\n\tdefault:\n\t\tstd::cerr << \"Invalid response!\";\n\t\tstd::abort();\n\t}\n}\n\n\nint main()\n{\n\t#// This program such a value in an array and replace it by a user's value\n\tstd::array arr{ 13, 20, 25, 32, 100, 56, 30, 14, 32 };\n\n\tint search{};\n\tint replace{};\n\n\twhile (true)\n\t{\n\t\tstd::cout << \"Please enter the value which you want to search, and then a new replaced value: \";\n\t\tsearch = get_input();\n\t\treplace = get_input();\n\n\t\tstd::cout << \"Your search value: \" << search << '\\n';\n\t\tstd::cout << \"Replace by: \" << replace << '\\n';\n\n\t\tstd::cout << \"Do you confirm? (y or n): \";\n\t\tbool con{ confirm() };\n\t\tif (con)\n\t\t\tbreak;\n\t\telse\n\t\t{\n\t\t\tstd::cout << \"You chose 'n', do you want to re-enter? (y or n): \";\n\t\t\tcon = confirm();\n\t\t\tif (!con)\n\t\t\t{\n\t\t\t\tstd::cout << \"You decided to end. Thank you! Exiting...\\n\";\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\t\n\t\t}\n\t}\n\n\tauto found{ std::find(arr.begin(), arr.end(), search) };\n\n\tif (found == arr.end())\n\t{\n\t\tstd::cout << \"Could not find \" << search << \" in the array.\\n\";\n\t}\n\telse\n\t{\n\t\t*found = replace;\n\t}\n\n\tfor (int i : arr)\n\t{\n\t\tstd::cout << i << ' ';\n\t}\n\n\tstd::cout << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n### `std::find_if` to find an element that matches some condition\n\nThis function finds the element that return true in a predicate function. There are 3 parameters in this function: the start position, the end position, and a `bool` function.\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <algorithm>\n#include <array>\n#include <iostream>\n#include <string>\n#include <string_view>\n\nbool str_exit(const std::string_view str)\n{\n\treturn (str.find(\"nut\") != std::string_view::npos);\n}\n\nint main()\n{\n\tstd::array<std::string_view, 5> str{ \"apple\", \"banananut\", \"walnut\", \"lemon\" };\n\n\t#//std::string str_chose{};\n\t#//std::cout << \"What string do you want to find?: \";\n\t#//std::cin >> str_chose;\n\n\tauto found{ std::find_if(str.begin(), str.end(), str_exit) };\n\n\tif (found == str.end())\n\t{\n\t\tstd::cout << \"Cannot find your string\\n\";\n\t}\n\telse\n\t{\n\t\tstd::cout << \"Found: \" << *found << '\\n';\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n\n### Using `std::for_each` to do something to all elements of a container\n\n`std::for_each` takes a list as input and applies a *custom* function to every element.\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid double_number(int& i)\n{\n\ti *= 2;\n}\n\nint main()\n{\n\t#// std::for_each\n\tstd::array arr{ 1, 2, 3 };\n\tstd::for_each(arr.begin(), arr.end(), double_number);\n\n\tfor (auto i : arr)\n\t{\n\t\tstd::cout << i << ' ';\n\t}\n\n\tstd::cout << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nHere is chapter's summary: <https://www.learncpp.com/cpp-tutorial/chapter-11-comprehensive-quiz/>.\n\n## Further from the exercises\n\n### Using name alias for non-fundamental data type\n\nHere is the code example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstruct Student\n{\n    std::string name{};\n    double grade{};\n}\n\nusing Students = std::vector<Student>;\n\nenum Item_types\n{\n    health,\n    torchs,\n    arrows,\n    max_numbers,\n};\n\nusing Items = std::array<Item_types, max_numbers>\n```\n:::\n\n\nWhen use for-each loop with `struct` data type, we can access its member\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(auto& student: Students)\n{\n    std::cin >> student.name;\n    std::cin >> student.grade;\n}\n```\n:::\n\n\n* Remember to avoid the **off-by-one** error when use loop for array.\n\n* Cannot change value of x: `const int* ptr{&x}`\n\n* If `length` is not a compile-time constant, we cannot define `int temp[length]{}`. Ex: length is a parameter in a function. We can use `std::vector`.\n",
    "supporting": [
      "c11_arrays_1_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}