{
  "hash": "ec746435d1f23455aa6cc73976f7af9d",
  "result": {
    "markdown": "# Scope, duration and linkage\n\n## Compound statements\n\n**Compound statement (block)**:\n\n* Zero, one, or more statement that compiler treats as simple statement\n* Between \"{}\", not need semicolon at the and of \"}\"\n* Be anywhere when the single statement is valid\n\nFunction cannot be nested inside other function, but *block* can. Then we have\n\n* Outer block: enclosing one\n* Inner block: nested one\n\nBlock is very useful with `if statements`: replace single statement with a block.\nFor example,\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tstd::cout << \"Enter an integer: \";\n\tint value{};\n\tstd::cin >> value;\n\n\tif (value >= 0)\n\t{\n\t\tstd::cout << value << \" is a positive integer (or zero)\\n\";\n\t\tstd::cout << \"Double this number is \" << value * 2 << '\\n';\n\t}\n\telse\n\t{\n\t\tstd::cout << value << \" is a negative integer\\n\";\n\t\tstd::cout << \"The positive of \" << value << \" is \" << -value << '\\n';\n\t\tstd::cout << \"Then, its double is \" << (-value) * 2 << '\\n';\n\t}\n\n\treturn 0;\n}\n```\n:::\n\n\n**Nesting level** or **nesting depth** is the maximum numbers of nested blocks \ninside at any point in the function. For example,\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{ // block 1, nesting level 1\n    std::cout << \"Enter an integer: \";\n    int value {};\n    std::cin >> value;\n\n    if (value >  0)\n    { // block 2, nesting level 2\n        if ((value % 2) == 0)\n        { // block 3, nesting level 3\n            std::cout << value << \" is positive and even\\n\";\n        }\n        else\n        { // block 4, also nesting level 3\n            std::cout << value << \" is positive and odd\\n\";\n        }\n    }\n\n    return 0;\n}\n```\n:::\n\n\nThere are 4 blocks, and nesting level is 3.\n\n:::{.callout-tip}\n\n### Best practice\n\nKeep the nesting level of our functions to **3 or less**. If greater, think to \nre-factor the function into sub-ones.\n\n:::\n\n## User-defined namespaces and the scope resolution operator\n\nThe better way to solve the name collisions is to put our functions in our \n**own namespaces** eg, standard library moved into `std` namespace.\n\n### Define our own namespaces\n\nWe define namespace by using statement `namespace`\n\nin foo.cpp file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnamespace foo\n{\n\tint doSomething(int x, int y)\n\t{\n\t\treturn x - y;\n\t}\n}\n```\n:::\n\n\nin goo.cpp file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnamespace goo\n{\n\tint doSomething(int x, int y)\n\t{\n\t\treturn x - y;\n\t}\n}\n```\n:::\n\n\nin main.cpp:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint doSomething(int x, int y);\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    std::cout << doSomething(4, 3) << '\\n';\n    \n    return 0;\n}\n```\n:::\n\n\nRunning the program, there is \"LINK ERROR\": cannot find the doSomething in global\nnamespace because it is in either foo or goo namespace.\n\n=> Solve this problem by: `scope resolution` or `using statements`\n\n#### Accessing namespace with the scope resolution operator (::)\n\nWe use the operator (::) to tell exactly whose namespace of the called function.\nFor example in main.cpp\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint doSomething(int x, int y);\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    std::cout << foo::doSomething(4, 3) << '\\n';\n    \n    return 0;\n}\n```\n:::\n\n\nIf an identifier inside a namespace is used, without scope resolution, the\ncompiler finds inside the namespace, if it cannot find, it goes to each containing\nnamespace in sequence to find, the global namespace being checked last.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid print() // this print lives in the global namespace\n{\n\tstd::cout << \" there\\n\";\n}\n\nnamespace foo\n{\n\tvoid print() // this print lives in the foo namespace\n\t{\n\t\tstd::cout << \"Hello\";\n\t}\n\n\tvoid printHelloThere()\n\t{\n\t\tprint(); // calls print() in foo namespace\n\t\t::print(); // calls print() in global namespace\n\t}\n}\n\nint main()\n{\n\tfoo::printHelloThere();\n\n\treturn 0;\n}\n```\n:::\n\n\nIf we define namsepace in different files to main.cpp:\n\n* Create header file for the namespace. For example, namespace foo:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ifndef FOO_H\n#define FOO_H\n\nnamespace foo\n{\n\tint add(int x, int y);\n\n\tint substract(int x, int y);\n\n}\n\n#endif\n```\n:::\n\n\n* Include the header into the namespace file foo.cpp:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include \"foo.h\"\n\nnamespace foo\n{\n\tint add(int x, int y)\n\t{\n\t\treturn x + y;\n\t}\n\n\tint substract(int x, int y)\n\t{\n\t\treturn x - y;\n\t}\n}\n```\n:::\n\n\n* Add header to main.cpp:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include \"foo.h\"\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    std::cout << foo::add(4, 3) << '\\n';\n    std::cout << foo::substract(10, 7) << '\\n';\n    \n    return 0;\n}\n```\n:::\n\n\nNamespace can be nested in other namespace by declaration `namespace foo::goo`.\n\n#### Namespace aliases\n\nFor nested namespace, C++ allow to name the namespace for shortenning:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nnamespace foo::goo\n{\n  int add(int x, int y)\n  {\n    return x + y;\n  }\n}\n\nint main()\n{\n  namespace active = foo::goo;  // active refers to foo::go\n  \n  std::cout << active::add(1, 2) << '\\n'; // This is really foo::goo::add()\n  \n  return 0;\n}\n```\n:::\n\n\n:::{.callout-note}\n\n* In general, we should avoid deeply nested namespaces.\n\n* We can separate application-specific code from code that might be reusable later\n.For example, one namespace for math: `math::`, language and localization: `lang::`\n\n* When sharing the code, should put it in a namespace.\n\n:::\n\n## Local variables\n\nLocal variables have a **block scope**: *in scope* from\npoint of definition to the end of the block they are defined within.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#|label: block-scope\n\n#include <iostream>\n\nint main()\n{\n\tint i{ 5 };\t\t\t// i enters scope\n\tdouble d{ 4.0 };   // d enters scope\n\n\treturn 0;\n}\t// d and i go out of scope here.\n```\n:::\n\n\nAll variable names within a scope must be unique.\n\nA local variable has a lifetime, called storage **duration**. This determine when\nand how a variable will be created and detroyed.\n\nLocal variable has **automatic storage duration**: created and detroyed within \nthe block\n\n=> local variable == **automatic variable**.\n\nWe can define variables inside nested block:\n\n* They enters the scope at time of definition and go out at the end of the nested\nblock. So do their lifetimes.\n\n* Thus, it cannot be found from outer block\n\n* But, variable in outer block can be used inside nested block.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{ // outer block\n\n    int x { 5 }; // x enters scope and is created here\n\n    { // nested block\n        int y { 7 }; // y enters scope and is created here\n\n        // x and y are both in scope here\n        std::cout << x << \" + \" << y << \" = \" << x + y << '\\n';\n    } // y goes out of scope and is destroyed here\n\n    // y can not be used here because it is out of scope in this block\n\n    return 0;\n} // x goes out of scope and is destroyed here\n```\n:::\n\n\nVariable should be defined in the most limited scope: inside the nested block \nthat uses it.\n\n:::{.callout-tip}\n\nDefine variables in the most limited existing scope. Avoid creating new blocks \nwhose only purpose is to limit the scope of variables.\n\n:::\n\n## Introduction to global variables\n\nWe define a variable outside of a function, this one is **global variable**.\nBy convention:\n\n* It is under the `#include` and above any function.\n\n* Consider using prefix 'g' or 'g_' for global variables.\n\nIts properties:\n\n* Has global scope (global namespace scope)\n* Uses anywhere in the file\n* Created when the program starts and detroyed when it ends => **static duration**\nSo, it is **static variable**.\n\n* Zero-initialized by default^[local variables have uninitialized default].\n* Global variable can be defined as constant, but we have to initialize it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconst int g_x;  //error: no default initialized\n\nconst int g_w{1}; // ok\n```\n:::\n\n\n:::{.callout-warning}\n\nWe should avoid to use non-constant global variables.\n\n:::\n\n## Varaible shadowing (name hiding)\n\nWhen outer block and inner block have a variable with same name, the nested\nvariable \"hides\" the outer variable when they are both in scope. This is called\n**name hiding** or **shadowing**.\n\nThe same applies to global variable, but global variable is a part of namespace\nso we can use `::`prefix to indicate using global variable.\n\n:::{.callout-tip}\n\nAvoid variable shadowing\n\n:::\n\n## Internal linkage\n\nAn identifer's linkage determines whether the other declarations of that name\nrefer to the same object or not.\n\n* Local variable does not have linkage.\n* Global variable has internal and external linkage\n\nAn **internal linkage** is seen and used within a single file. \n\nA global variable has external linkage as default, so we define internal linkage by use `static ...`.\n\nBut const global variable or constexpr global variable are internal linkage by default.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstatic int g_x{};\t// internal linkage\nconst int g_y{ 2 };\t// internal linkage by default\nconstexpr int g_z{ 3 };\t//internal linkage by default\n```\n:::\n\n\n### The one-definition rule and internal linkage {.unnumbered}\n\nOne-definition rule says that an object or function cannot have more than \none definition, either within a file or a program. But, internal object are defined in different files are considered to be independent entities.\n\nWe can apply the same to function by using `static`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This function is declared as static, and can now be used only within this file\n# Attempts to access it from another file via a function forward declaration will\n# fail\n\n[[maybe_unused]] static int add(int x, int y)\n{\n    return x + y;\n}\n```\n:::\n\n\n## External linkage and variable forward declarations\n\nIdentifier with **external linkage** can be used and seen from its file and other code files (via a forward declaration).\n\n* Function have *external linkage by default* so we can use a forward declaration\n* Non-const global variable are external by default\n* Const global variable defined through `extern` keyword\n* To use global variable in other file, we also forward declaration like in\nfunction,\n\nThe following code are example of using external linkage for global variable (const and non-const one). First, we have global variable in one source file a.cpp:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint g_x{ 3 };                   #// internal by default\nextern const int g_y { 4 };     #// okie\nextern constexpr int g_z{3};    #// can, but useless\n```\n:::\n\n\nWe use them in the main.cpp by their declarations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint g_x;                   #// internal by default\nextern const int g_y;     #// okie\nextern constexpr int g_z;    #// can, but useless\n\nint main()\n{\n    std::cout << g_x << '\\n'; // prints 2\n\n    return 0;\n}\n```\n:::\n\n\n:::{.callout-warning}\n\nDo not use `extern` keyword if we define an unitialized non-const global variable. C++ will think it is a declaration.\n\n:::\n\nWe should be clear about **file scope** and **global scope**: all global variable can be used within the file that defines them; if it can be seen by other files too, it has global scope (with proper declarations).\n\n## Why (non-const) global variables are evil\n\n* Their values can be changed by any function that is called\n=> Make program state is *unpredictable*.\n\n* A function that utilizes nothing but its parameters and has no side effects is\n*perfectly modular*.\n\n* Modularity helps both in understanding what a program does, as well as\nreusability.\n\n* Global variables make the program less modular.\n\n:::{.callout-tip}\n\nUse local variables instead of global variables whenever possible.\n\n:::\n\n## Sharing global constants across multiple files {#sec-sharConstVar}\n\n1. Create a .cpp file for a constants namespace includes all the const \nglobal variables.\n2. Create a header file for that namespace\n3. Include the header file in other files using the constants\n\nThis solution has downside. The compiler does not evaluate the const global variables at compile-time because it only recognizes the declarations. There may impact the performance maximization. To have a better solution, C++17 introduce a new keyword `inline` that allow an object can be defined in different files without violating the *one definition rule*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#> In constant.cpp\n\n#include \"constant.h\"\n\nnamespace constants\n{\n\textern const double pi{ 3.14159 };\n\textern const double avogadro{ 6.0221413e23 };\n\textern const double myGravity{ 9.2 };\n}\n\n#> In constant.h\n\n#ifndef CONSTANT_H\n#define CONSTANT_H\n\nnamespace constants\n{\n\textern const double pi;\n\textern const double avogadro;\n\textern const double myGravity;\n}\n\n#endif // !CONSTANT_H\n\n#> In main.Cpp\n\n#include \"constant.h\"\n#include <iostream>\n\nint main()\n{\n\tstd::cout << \"Enter a radius: \";\n\tint radius{};\n\tstd::cin >> radius;\n\n\tstd::cout << \"The circumfence is \" << 2.0 * radius * constants::pi << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n### Global constants as inline variables\n\nIn C++, the term `inline` has evolved to mean \"multiple definitions are allowed\". An **inline variable** is one that is allowed to be defined in multiple files without violating one definition rule.\n\nInline variables have **two primary restrictions** that must be obeyed:\n\n1. All definitions of the inline variable must be identical.\n2. The inline variable definitions (not a forward declaration) must be present\n**in any file** that uses the variable.\n\nWe see the differences with the sharing constant global variables mentioned at the session's beginning:\n\n* For inline const var, we do not need to have separate .cpp file for header \nbecause we define (not only declare) all in the header file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# In constants.h\n\n#ifndef CONSTANTS_H\n#define CONSTANTS_H\nnamespace constants\n{\n  inline constexpr double pi{3.14159};\n  inline constexpr double avogadro{6.0221413e23};\n}\n\n#endif\n\n# In main cpp\n\n#include \"constants.h\"\n\n#include <iostream>\n\nint main()\n{\n    std::cout << \"Enter a radius: \";\n    int radius{};\n    std::cin >> radius;\n\n    std::cout << \"The circumference is: \" << 2.0 * radius * constants::pi << '\\n';\n\n    return 0;\n}\n```\n:::\n\n\n:::{.callout-tip}\n\nIf you need global constants and your compiler is C++17 capable, prefer defining \ninline constexpr global variables in a header file.\n\n:::\n\n## Static local variables\n\n**Local variable**, by its definition, has the scope within its block or \n*automatic duration*. When we want a local variable exists in whole the program,\nwe use **static local variables** by adding `static` before local variable's\ndefinition.\n\nLet have the examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid incrementAndPrint()\n{\n\tint value{ 1 };\n\t++value;\n\tstd::cout << value << '\\n';\n}\n\nint main()\n{\n\tincrementAndPrint();\n\tincrementAndPrint();\n\tincrementAndPrint();\n\n\treturn 0;\n}\n\n#> 2\n#> 2\n#> 2\n```\n:::\n\n\nNow, we modify for static local variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#label: static-local-var\n\n#include <iostream>\n\nvoid incrementAndPrint()\n{\n\tstatic int value{ 1 };\n\t++value;\n\tstd::cout << value << '\\n';\n}\n\nint main()\n{\n\tincrementAndPrint();\n\tincrementAndPrint();\n\tincrementAndPrint();\n\n\treturn 0;\n}\n#> 2\n#> 3\n#> 4\n```\n:::\n\n\nWe use static local variable to keep track of variable like IDs for object.\n\n### Static local constants\n\n:::{.callout-tip}\n\nAvoid `static` local variables unless the variable never needs to be reset\n:::\n\n## Using declarations and using directives\n## Inline function\n\nCodes of called function are expanded in caller. Modern compiler decides this.\n\n## Constexpr and consteval functions\n\nA **constexpr function**: can be evaluated at compile-time. Simply by supplying\n`constexpr` keyword in front of the return type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nconstexpr int greater(int x, int y)\n{\n\treturn (x > y ? x : y);\n}\n\nint main()\n{\n\tconstexpr int x{ 5 };\n\tconstexpr int y{ 6 };\n\n\tconstexpr int g{ greater(x, y) };\n\n\tstd::cout << g << \" is greater!\\n\";\n\n\treturn 0;\n}\n```\n:::\n\n\nTo be a constexpr function, a function has to:\n\n* Have a constexpr return type\n* Do not have any non-constexpr functions\n\nConstexpr function can be evaluated at *runtime*.\n\n## Chapter summary\n\nA **compound statement** or **block** is a group of statements is treated as a\nsingle statement by compiler.\n\n",
    "supporting": [
      "c6_scope_duration_linkage_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}