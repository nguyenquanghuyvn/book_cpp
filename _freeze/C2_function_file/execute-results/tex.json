{
  "hash": "7790c88854213dfb9460c6094be5e9cc",
  "result": {
    "markdown": "# Funtions and Files\n\n## Introduction to functions\n\nA **function** is a reusable sequence of statements designed to do a *particular job*. Function allows us to split the program into small, modular chunks which are easier to organize, test, and use. Besides the standard library of C++, we can write our own function, called **user-defined function**.\n\nWhen a program is executing the statements sequentially inside one function and encounters a function call. A **function call** is an expression that tells CPU to **interrupt** the current function and *execute another function*. The CPU put a *bookmark* at the current point of execution, and then **calls** the function.\n\nThe function initiating the function call is the **caller**, the other is **called function**.\n\n### An example of a user-defined function\n\nThe general syntax of function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| label: func_syntax\nreturnType functionName() # This is function header\n{\n  # This is body of the function\n}\n```\n:::\n\n\nThe first line is **function header** telling the compile that the function exists.\n\n* In this session, *returnType* of `int` for `main()` and *void* otherwise.\n* *functionName* is name of user-defined function.\n\nLet see the example function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| label: func_doPrint\n\n#include <iostream>\t\t// for std::cout\n\n// Definition of user-defined function doPrint()\nvoid doPrint()\n{\n\tstd::cout << \"In doPrint() \\n\";\n}\n\nint main()\n{\n\tstd::cout << \"Starting main() \\n\";\n\tdoPrint();\n\tstd::cout << \"Ending main() \\n\";\n\n\treturn 0;\n}\n```\n:::\n\n\n::: {.callout-warning}\n\nDo not forget to include parentheses `()` after the function's name when making a function call.\n\n:::\n\n* Function can be called more than **one** time in a *caller*. \n* Any functions can call any other functions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#| label: func_call_func\n\n#include <iostream>\t\t// for std::cout\n\n// Definition of user-defined function doPrint()\nvoid doB()\n{\n\tstd::cout << \"In doB() \\n\";\n}\n\nvoid doA()\n{\n\tstd::cout << \"Starting doA()\\n\";\n\tdoB();\n\tstd::cout << \"Ending doA()\\n\";\n}\n\nint main()\n{\n\tstd::cout << \"Starting main() \\n\";\n\tdoA();\n\tstd::cout << \"Ending main() \\n\";\n\n\treturn 0;\n}\n```\n:::\n\n\n* **Nested functions** are not supported: we cannot decide a function inside another function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main() \n{\n  void foo()  # Illegal: this function is nested inside function main()\n  {\n    std::cout << \"foo!\\n\";\n  }\n  \n  foo();\n  return 0;\n}\n```\n:::\n\n\nThe right way to write is\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvoid foo() \n{\n    std::cout << \"foo!\\n\";\n}\n\nint main()\n{\n    foo();\n    return 0;\n}\n```\n:::\n\n\n### Function return values (value-returning functions)\n\nIf we want to write a program that get number from user, then double it and return value to the console, we can start with:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\t\t// for std::cout\n\nint main()\n{\n\t// get a value from user\n\tstd::cout << \"Enter an integer: \";\n\tint num{};\n\tstd::cin >> num;\n\n\t// print the value doubled\n\tstd::cout << num << \" doubled is: \" << num * 2 << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nWe can also write a function that get value from user and let `main()` calls that function to double it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\t\t// for std::cout\n\n#| label: cod_problem\nvoid getValueFromUser()\n{\n\tstd::cout << \"Enter an integer: \";\n\tint input{};\n\tstd::cin >> input;\n}\n\nint main()\n{\n\tgetValueFromUser();\n\n\tint num{};\n\n\tstd::cout << num << \" double is: \" << num * 2 << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nWhile this program is a good solution, it always returns 0 because the value from `getValueFromUser()` is not stored. We need that function return a value.\n\nThe function return a value require two conditions:\n\n* Define the **return type** before the name of the function.\n* A **return statement** in the body of the function. The function exits immediately, and a copy of return value backs to the *caller*. This is *return by value* process.\n\nLet look at an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint returnValueFive()\n{\n  return 5;\n}\n\nint main()\n{\n  std::cout << returnValueFive() << '\\n';\n  std::cout << returnValueFive() + 2 << '\\n';\n  \n  returnValueFive();\n  \n  return 0;\n}\n```\n:::\n\n\n::: {.callout-tip}\n\nWhen a called function returns a value, the caller may decide to use that value in an expression or statement(e.g by assigning it to a variable, or sending it to `std::cout`).\n\n:::\n\n### Fixing our challange program\n\nNow, we return to the problem and use the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint getValueFromUser() // this function now returns an integer value\n{\n \tstd::cout << \"Enter an integer: \";\n\tint input{};\n\tstd::cin >> input;\n\n\treturn input; // return the value the user entered back to the caller\n}\n\nint main()\n{\n\tint num { getValueFromUser() }; // initialize num with the return value of getValueFromUser()\n\n\tstd::cout << num << \" doubled is: \" << num * 2 << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n### Revisiting `main()`\n\nWhen we run a program, the operating system calls the function `main()`. It executes the `main()` from the top to bottom sequentially. Finally, `main()` returns an integer value (usually 0), and the program terminates. The return value from `mmain()` is called **status code**, and indicates that the program is successful or fail.\n\n::: {.callout-tip}\n\n#### Best practice\n\n* The `main` function should return the value `0` if the program an normally.\n* Make sure the functions with non-void return types return a value in all cases.\n* Failure to return a value from a value-returning function will cause undefined behavior.\n\n:::\n\n:::{.callout-note}\n\n* Function `main` will implicitly return 0 if no return statement is provided. Thus, it is recommended to explicitly state the return value.\n* Function can only return a **single value**. It can return not only literal, but also a variable or a call to function that return single value.\n* The function author can decide what the return value means (status code, single value). It is good to document the function with a comment indicating what the return values mean.\n\n:::\n\n### Reusing functions\n\nWe can illustrate a good case for function reuse:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\n// Create a function that return an integer value from user's keyboard\nint main()\n{\n\tint x{};\n\tstd::cout << \"Enter an integer: \";\n\tstd::cin >> x;\n\n\tint y{};\n\tstd::cout << \"Enter second integer: \";\n\tstd::cin >> y;\n\n\tstd::cout << x << \" + \" << y << \" = \" << x + y << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nThe central tenets of good programming: **Don't Repeat Yourself** (DRY). Let create a function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\n// Create a function that return an integer value from user's keyboard\nint getValueFromUser()\n{\n\tint input{};\n\tstd::cout << \"Enter an integer: \";\n\tstd::cin >> input;\n\n\treturn input;\n\n}\n\n// main function return the sum of two integers from user\nint main()\n{\n\tint x{ getValueFromUser() };\n\tint y{ getValueFromUser() };\n\n\tstd::cout << x << \" + \" << y << \" = \" << x + y << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n::: {.callout-tip}\n\n#### Best practice\n\n**Don't repeat yourself**. IF you need to do something more than once time, consider how to modify the code to remove as much as redundancy as possible.\n:::\n\n## Void functions\n\nFunctions are not required to return a value to the caller, we use the return type of **void**. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid printHi()\n{\n\tstd::cout << \"Hi!\\n\";\n}\n\nint main()\n{\n\tprintHi();\n\n\treturn 0;\n}\n```\n:::\n\n\nThe function `printHi()` prints \"Hi!\", but does not need to return anything back to the caller. A function that does not return a value is called a **non-value returning function (void-function)**.\n\n::: {.callout-tip}\n\n### Best practice\n\nDo not put a return statement at the end of a non-value returning function.\n\n:::\n\n\n### Void functions can't be used in expression that require a value {.unnumbered}\n\nConsider the following program:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid printHi()\n{\n\tstd::cout << \"Hi!\\n\";\n}\n\nint main()\n{\n\tprintHi();\n\n\tstd::cout << printHi();\n\n\treturn 0;\n}\n```\n:::\n\n\nAn error occurs because the `printHi()` does not return value so it cannot provide the value to `std::cout` to print out.\n\n**Returning a value from a void function is a compile error.**\n\nEarly return\n: a return statement that is not the last statement in a function is called an **early return**. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid print()\n{\n\tstd::cout << \"A\";\n\n\treturn;\n\n\tstd::cout << \"B\";\n}\n\nint main()\n{\n\tprint();\n\n\treturn 0;\n}\n```\n:::\n\n\nThe program returns \"A\" because it does not reach to second statements in ``print()`.\n\n\n## Introduction to function parameters and arguments\n### The problem\n\nWe start by the codes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid print()\n{\n\tstd::cout << \"A\";\n\n\treturn;\n\n\tstd::cout << \"B\";\n}\n\nint main()\n{\n\tprint();\n\n\treturn 0;\n}\n```\n:::\n\n\nWe want to have a function that prints a doubled number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint getValueFromUser()\n{\n\tstd::cout << \"Enter an integer: \";\n\tint input{};\n\tstd::cin >> input;\n\n\treturn input;\n}\n\nvoid printDouble()\n{\n\tstd::cout << num << \" doubled is: \" << num * 2 << '\\n';\n}\n\nint main()\n{\n\tint num{ getValueFromUser() };\n\n\tstd::cout << num << \" doubled is: \" << num * 2 << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nThe compiler does not know the definition of `num` in the function. Then, we can\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint getValueFromUser()\n{\n\tstd::cout << \"Enter an integer: \";\n\tint input{};\n\tstd::cin >> input;\n\n\treturn input;\n}\n\nvoid printDouble()\n{\n\tint num{};\n\tstd::cout << num << \" doubled is: \" << num * 2 << '\\n';\n}\n\nint main()\n{\n\tint num{ getValueFromUser() };\n\n\tprintDouble();\n\n\treturn 0;\n}\n```\n:::\n\n\nThe function run normally, but always returns 0 because function `printDouble()` does not access the input from user. Thus, we need some way to pass the value of variable to `printDouble()`.\n\n### Function parameters and arguments\n\nA **function parameter**: a variable used in header of a function, identically to variables defined inside the function, one difference: *they are initialized with a value provided by the caller of the function.*\n\nAn **argument** is a value that is passed from the *caller* to the function when a function call is made:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main()\n{\n\tdoPrint();\n\tprintValue(10);\n\tadd(2, 3);\n\n\treturn 0;\n}\n```\n:::\n\n\nUse the commas for separation multiple arguments, and parameters.\n\n**Pass by value**: when a function is called, all of the parameters are created as variables, and the value of each of the arguments is copied into the matching parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n// This function takes one parameter named x\n// The caller will supply the value of x\nvoid printValue(int x, int y)\n{\n\tstd::cout << x << '\\n';\n\tstd::cout << y << '\\n';\n}\n\nint main()\n{\n\tprintValue(10, 20);\n\n\treturn 0;\n}\n```\n:::\n\n\nNow, we come back to our challenge program:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint getValueFromUser()\n{\n\tstd::cout << \"Enter an integer: \";\n\tint input{};\n\tstd::cin >> input;\n\n\treturn input;\n}\n\nvoid printDouble(int input)\n{\n\tstd::cout << input << \" doubled is: \" << input * 2 << '\\n';\n}\n\nint main()\n{\n\tint num{ getValueFromUser() };\n\tprintDouble(num);\n\n\t// printDouble(getValueFromUser());\n\n\treturn 0;\n}\n```\n:::\n\n\nThe arguments can be also the expression, the variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint add(int x, int y)\n{\n\treturn x + y;\n}\n\nint multiply(int z, int w)\n{\n\treturn z * w;\n}\n\nint main()\n{\n\tstd::cout << add(5, 6) << '\\n';\n\tstd::cout << add(2 + 3, 3 * 4) << '\\n';\n\n\tint a{ 5 };\n\tstd::cout << add(a, a) << '\\n';\n\n\tstd::cout << add(2, multiply(2, a)) << '\\n';\n\tstd::cout << multiply(add(1, 3), multiply(2, 3)) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n\n## Introduction to local scope {#sec-localScope}\n\n### Local variables {#sec-localVariable}\n\nFunction parameters as well as all variables defined inside the function body, are **local variables**.\n\nLocal variables are *created* at the point of definition and *destroyed* no earlier than the end of the set of the curly braces in which they are defined. We have definition of object's *lifetime* to be the time between its creation and destruction which happen when the program is running (calling runtime), not at compile time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint add(int x, int y)\n{\n    int z{ x + y };\n\n    return z;\n} // z, y, and x destroyed here\n```\n:::\n\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nvoid doSomething()\n{\n\tstd::cout << \"Hello!\\n\";\n}\n\nint main()\n{\n\tint x{ 0 };\n\tdoSomething();\n\n\treturn 0;\n} // x's lifetime ends here\n```\n:::\n\n\n### Local scope\n\nAn identifiers' **scope** determines where the identifier can be accessed within the source code. When an identifiers can be accessed, it is **in scope**, while it we cannot access, it is **out of scope**. Scope is *compile-time* property.\n\nA local variables' scope begins at the point of value definition, and stops at the end of the set of curly braces in which it is defined. Local variables defined in one function are also **not in scope** in other functions that are called.\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\n// x is not in scope anywhere in this function\nvoid doSomething()\n{\n    std::cout << \"Hello!\\n\";\n}\n\nint main()\n{\n    // x can not be used here because it's not in scope yet\n\n    int x{ 0 }; // x enters scope here and can now be used within this function\n\n    doSomething();\n\n    return 0;\n} // x goes out of scope here and can no longer be used\n```\n:::\n\n\n::: {.callout-note}\n\n* *Out of scope*: an identifier cannot be accessed anywhere within the code\n* *Going out of scope*: for objects, an object goes out of the scope at the end of the scope. A local variable's lifetime ends at the point where it goes out of scope.\n* Not all types of variable are destroyed when they go out of scope.\n\n:::\n\nAnother example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint add(int x, int y) // x and y are created and enter scope here\n{\n    // x and y are visible/usable within this function only\n    return x + y;\n} // y and x go out of scope and are destroyed here\n\nint main()\n{\n    int a{ 5 }; // a is created, initialized, and enters scope here\n    int b{ 6 }; // b is created, initialized, and enters scope here\n\n    // a and b are usable within this function only\n    std::cout << add(a, b) << '\\n'; // calls function add() with x=5 and y=6\n\n    return 0;\n} // b and a go out of scope and are destroyed here\n```\n:::\n\n\n::: {.callout-tip}\n\n#### Key insight\n\nNames used for function parameters or variables declared in a function body *only visible within the function that declares them*. Local variables within a function can be named without regard for the names of variables in other functions. This helps keep functions independent.\n\n:::\n\n::: {.callout-tip}\n\n#### Best practice\n\nDefine the local variables as close to their first use as reasonable.\n\n:::\n\n## Why functiona are useful, and how to use them effectively\n\n### Why use functions?\n\n* *Organization*: \n  - Simpler the `main()` function\n  - A function is a mini-program that we can write separately\n  - Help us to have more manageable chunks\n* *Re-usability*:\n  - Function can be called many times within a program\n  - Follow \"Do not repeat yourself\" to minimize the copy/paste error\n  - Can be shared with other program\n* *Testing*:\n  - Functions reduces code redundancy, so less code to test\n  - Function is self-contained, when it is tested, we do not need to test it again unless we change it.\n  - Make easier to find bugs\n* *Extensibility*:\n  - When we need to extend the program to handle case it didn't handle before, function allow us to make change in one place\n* *Abstraction*:\n  - We only need: name, inputs, outputs and where it lives.\n  - Do not need to know how it works, what other code it's dependent\n  - Reduce the amount of knowledge\n  \n### Effectively using functions\n\n* When there are repeated group of statements\n* Generally perform one and only one task\n\n## Forward declarations and definitions\n\nWe start by the simple program:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint main()\n{\n\tstd::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n\treturn 0;\n}\n\nint add(int x, int y)\n{\n\treturn x + y;\n}\n```\n:::\n\n\nThe compiler returns *error*: identifier `add` is not found. In the program, we defined `add` after `main`, and compiler reads the code sequentially so it cannot find `add` in `main`.  There are two ways to address the issu:\n\n### Reorder the function definitions\n\nWe defined `add` before `main`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint add(int x, int y)\n{\n\treturn x + y;\n}\n\nint main()\n{\n\tstd::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n\nIt is good in the program. But in larger program, it is difficult to know which functions call which functions. For example, A calls B and B also calls A; we have trouble to find the appropriate order of functions. The second option will solve this problem.\n\n### Use a forward declaration\n\nA **forward declaration** allows us to tell the compiler about the existence of a function before we define the function's body. The compiler encounter a call to the function, it will understanding and check whether we are calling function correctly, it doesn't know how or where the function is *defined*[^1].\n\n[^1]: There is difference between declaration and definition.\n\nHere is an example of forward function declaration:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint add(int x, int y);\n\nint main()\n{\n\tstd::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n\treturn 0;\n}\n\nint add(int x, int y)\n{\n\treturn x + y;\n}\n```\n:::\n\n\n\nForward declaration also helps to read the code from different files.\n\n### Declaration and definition\n\nA **definition** actually implement (for function or types) or instantiates (for variables) the identifier.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint add(int x, int y)    // implement function add()\n{\n  int x{ }  // instantiates variable\n}\n```\n:::\n\n\nA definition is needed to satisfy the *linker*. The **one definition rule** (ODR):\n\n1.  Within a file, a function, a variable, type, or template can only have one definition.\n2.  Within a given program, a variable or normal function can only have one definition\n3. Types, templates, inline functions, and inline variables are allowed to have identical definitions in different files\n \n\n## Programs with multiple code files\n\nWe can create a another code file in the Solution Explorer. The code file contains the function called in `main` code file. Remember to declare the function in `main` source code so that the compiler checks and passes successfully.\n\nAfter compiling, the program will link on the compiled files in the solution to execute.\n\nIn the project, we created a code file named *Add.cpp* to define the function `add`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# In the add.cpp\nint add(int x, int y)\n{\n\treturn x + y;\n}\n```\n:::\n\n\nTogether with the code file:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# In the main source code\n#include <iostream>\n\nint add(int x, int y);\n\nint main()\n{\n\tstd::cout << \"The sum of 3 and 4 is: \" << add(3, 4) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n:::{.callout-tip}\n\n* Because the compiler compiles each code file individually, each code files that uses `std::cout`, `std::cin` needs to `#include<iostream>`. Similarly, we includes other libraries if we use the functions in them.\n\n* Whenever you create a new code (.cpp) file, you will need to add it to your project so that it gets compiled.\n\n:::\n\n## Naming collisions and an introfuction to namespaces\n\nC++ requires that all identifiers be **non-ambiguous**, otherwise the program produces an error as **name collision**. If the names conflict in the same file, there is a compile error; if it is in the separate files in the same program, there is a linker error.\n\nC++ provides plenty of mechanisms for avoiding naming collisions.\n\n* Local scopes: keep local variables defined inside functions from conflicting with each other\n* But local scopes does not work for function names.\n\n### Namespace\n\n**Namespace** is a region that allows us to declare names inside of it for the purpose of disambiguation; it provides a scope region called **namespace scope**.\n\n:::{.callout-note}\n\n* A name declared in a namespace will not be mistaken for an identical name declared in another scope.\n* Within a namespace, all names are unique.\n* Namespace often groups related identifiers in a large project to avoid collide with other identifiers.\n\n:::\n\n#### The global namespace\n\nAny name that is not defined inside a class, function, or a namespace is considered to be part of an implicitly defined namespace, **global namespace**.\n\nOnly declaration and definition statements can appear in the global namespace. We can define variable in the global namespace, *but this should generally be avoided.*. Let read carefully the example code below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream> // handled by preprocessor\n\n# All of the following statements are part of the global namespace\nvoid foo();    # okay: function forward declaration in the global namespace\nint x;         # compiles but strongly discouraged: uninitialized variable definition in the global namespace\nint y { 5 };   # compiles but discouraged: variable definition with initializer in the global namespace\nx = 5;         # compile error: executable statements are not allowed in the global namespace\n\nint main()     # okay: function definition in the global namespace\n{\n    return 0;\n}\n\nvoid goo();    # okay: another function forward declaration in the global namespace\n```\n:::\n\n\n#### The std namespace\n\nWe usually typed `std::cout`: we tell the compiler to search for the function `cout` inside the namespace `std`. This approach avoid any collide with any functions in other library or namespace.\n\n:::{.callout-tip}\n\nWhen you use an identifier that is defined a namespace (such as the `std` namespace), you have to tell the compiler that the identifier lives inside the namespace.\n\n:::\n\n:::{.callout-warning}\n\nAvoid using-directives (such as `using namespace std;`) at the top of your program or in header files. They vioalate the reason why namespace were added in the firest place.\n\n:::\n\n\n\n## Introduction to the preprocessor\n\nEach code file goes through a preprocessing phase; a program called preprocessor make various changes to the text of the code file.\n\nThis phase works with the `#include`, `#define`. When we use `#include`, the preprocessor copies all the files to the compiler.\n\n## Header files\n\nWhat do we do if we want to store all the declaration in one files? That the important role of **header file** (extension .h).\n\nHeader file contains the function and variable declarations, not *definitions*. We can create our own header file (paired with the function code) and `#include nameOfFile.h` in the `main` and in the functions that declared in the header file.\n\n:::{.callout-tip}\n\n### Best practice\n\n* Use a .h suffix when naming your header files.\n\n* If a header file is paired with a code file (e.g. add.h with add.cpp), they should both have the same base name (add).\n\n* Source files should #include their paired header file (if one exists).\n\n* Use double quotes to include header files that you’ve written or are expected to be found in the current directory. Use angled brackets to include headers that come with your compiler, OS, or third-party libraries you’ve installed elsewhere on your system.\n\n* When including a header file from the standard library, use the version without the .h extension if it exists. User-defined headers should still use a .h extension.\n\n* Each file should explicitly #include all of the header files it needs to compile. Do not rely on headers included transitively from other headers.\n\n* Each header file should have a specific job, and be as independent as possible. For example, you might put all your declarations related to functionality A in A.h and all your declarations related to functionality B in B.h. That way if you only care about A later, you can just include A.h and not get any of the stuff related to B.\n\n* Be mindful of which headers you need to explicitly include for the functionality that you are using in your code files\n\n* Every header you write should compile on its own (it should #include every dependency it needs)\n\n* Only #include what you need (don’t include everything just because you can).\n* Do not #include .cpp files.\n:::\n\nThe author discuss the use of **Header Guard** helps to avoid the problem of collission between files in the program when creating headers.\n\n## How to design your first programs\n\nThe most important to remember is to design the program *before you start coding*. It is like architecture. A little up-front planning saves both time and frustation in th long run.\n\n### Design step 1: Define your goal\n\nShould address the goal in one or two sentences, often useful to express this as a user-facting outcome. Example:\n\n* Allow the user to organize a list of names and associated phone numbers\n* Model how long it takes for a ball dropped off a tower to hit the ground\n\n### Design step 2: Define requirements\n\nThis focuses on the \"what\", not the \"how\". For example:\n\n* Phone numbers should be saved, so they can be recalled later\n* The program should produce results within 10 seconds of the user submitting their request\n\nA single problem may yield many requirements, and the solution is not “done” until it satisfies all of them.\n\n### Design step 3: Define your tools, targets, and backup plan\n\nAs a new programmer, the answers are simple:\n\n* Writing a program for own use\n* On own system\n* Using IDE purchased or downloaded\n\n### Design step 4: Break hard problems down into easy problems\n\nTry split the complex task to sub-task and continuing define smaller sub-task until they are manageable.\n\n### Design step 5: Figure out the sequence of events\n\nThen, we determine how to link all tasks together. For example, if we are writing a calculator, we might do things in this order:\n\n* Get first number from user\n* Recognize the operator from user\n* Get second number from user\n* Calculate result\n* Print result back to user\n\nThen, we can implement them\n\n### Implementation step 1: Outlining the main function\n\nDo not worry about input and outphut for the time being\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint main() {\n  // Get first number from user\n      // getUserNumer();\n  \n  // Recognize the operator from user\n      // getMathOperation()\n  \n  //  Get second number from user\n      // getUserNumer();\n  \n  // Calculate result\n      // calculateResult();\n  \n  //  Print result\n      // printResult();\n  \n  return 0;\n}\n```\n:::\n\n\n### Implementation step 2: Implement each function\n\nIn this step, for each function, we do three things:\n\n* Define the function prototypes (input, output)\n* Write the function\n* Test the function\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nint getUserNumber() {\n\n\tstd::cout << \"Enter an integer: \";\n\t\n\tint number{};\n\tstd::cin >> number;\n\n\treturn number;\n}\n\nint main() {\n\n\t// Get first number from user\n\tint value{ getUserNumber() };\n\tstd::cout << value << '\\n';\t\t//debug code\n\n\t// Recognize the operator from user\n\n\treturn 0;\n}\n```\n:::\n\n\n:::{.callout-warning}\n\nDo not implement your entire program in one go. Work on it in steps, testing each step along the way before proceeding.\n\n:::\n\n### Implementation step 3: Final testing\n\nOnce your program is “finished”, the last step is to test the whole program and ensure it works as intended. If it doesn’t work, fix it.\n\n:::{.callout-tip}\n\n#### Word of advice\n\n* **Keep your programs simple to start**: make your first goal as simple as possible.\n* **Add features over time**: Once you have your simple program working and working well, then you can add features to it\n* **Focus on one area at a time**:  Focus on one task at a time\n* **Test each piece of code as you go.**\n* **Do not invest in perfecting early code**\n\n:::\n\nThe good news is that once you become comfortable with all of these concepts, they will start coming more naturally to you. Eventually you will get to the point where you can write entire functions without any pre-planning at all.",
    "supporting": [
      "C2_function_file_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {
      "knitr": [
        "{\"type\":\"list\",\"attributes\":{},\"value\":[]}"
      ]
    },
    "preserve": null,
    "postProcess": false
  }
}