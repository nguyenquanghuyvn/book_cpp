{
  "hash": "420983823d9eea350c28b718176e5238",
  "result": {
    "markdown": "---\ntitle: \"Compound Types: Enums and Structs\"\n---\n\n\n## Introduction to program-defined (user-defined) types\n\nWe create directly the fundamental types such as `int`, `double` and `bool`. This is true for compound types extended from fundamentals types: functions, pointers, references, and arrays)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nint x;\ndouble y;\n\nvoid fcn(int)   # function type void()(int)\nint* ptr;\nint& ref;\nint arr[5];     # an array of 5 int\n```\n:::\n\n\nWe also have type alias be defined through `using`. If we do not define it before using it, compiler will return error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusing length = int;\n\nint main()\n{\n    length x{5};\n    std::cout << x << '\\n';\n    \n    return 0;\n}\n```\n:::\n\n\n:::\n\nWhat will happen if we need a compound type that does not exit in C++ like fraction type?\n\n:::\n\nC++ allows us to create entirely new, custom types for use in our programs. We call it: **program-defined types** or **user-defined types**.\n\nProgram-defined types must be defined before they are used. This definition is **type definition**.\n\nThis is an example to define a new type named *Fraction*:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstruct Fraction {\n\tint numerator{};\n\tint numerator{};\n};\n\nint main() {\n\t\n\tFraction f{ 3, 4 };\n\n\treturn 0;\n}\n```\n:::\n\n\n:::{.callout-important}\n\nAlways end the program-defined type definitions by a **semicolon**. If not, there will be an error.\n\n:::\n\n:::{.callout-tip}\n\n* Name your program-defined types starting with a capital letter and do not use a suffix.\n\n* A program-defined type used in only one code file should be defined in that code file as close to the first point of use as possible.\n\n* A program-defined type used in multiple code files should be defined in a header file with the same name as the program-defined type and then #included into each code file as needed.\n\n:::\n\nProgram-defined type are partially exempt from the one-definition rule. Because the compiler needs to know the whole definition of type, forward declaration is not enough.\n\n## Enumerations\n\nAn **enumeration** (enumarated type or **enum**) is a compound data type, program-defined type where every possible value is defined as a symbolic constant (**enumerator**).\n\nC++ supports two kinds of enumerations: unscoped enumerations and scoped enumerations.\n\n## Unscoped enumerations\n\nThis is defined via the `enum` keyword. Let learn from the code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenum Color\n{\n\t// Here are enumerators\n\n\tred,\n\tgreen,\n\tblue,\n};\n\nint main() {\n\t\n\tColor apple{ red };\n\tColor shirt{ green };\n\tColor cup{ blue };\n\n\n\treturn 0;\n}\n```\n:::\n\n\nOur enum should start with a capital letter.\n\nEach enum types are distinct types. Thus, enumerators defined as part of one enumerated type cannot be used with object of another enummerated type\n\nEnumerated types are best used when we have a smallish set of related constants.\n\nEnumerators exist in the scope creating the enumeration. For example, `enum Color` defined in global scope, thus all the name `red, green, and blue` are defined in global scope. This sometimes invoke the name collision if there are enumerators with same name but in different enum.\n\nTo deal with this we can:\n\n* Use `Color::green`\n* Or put the `enum Color` in a namespace (**preferred**)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnamespace color\n{\n    enum Color{\n        red,\n        green, \n        blue,\n    };\n}\n```\n:::\n\n\n## Unscoped enumeration input and output\n\nEach enumerator is assigned by computer or by programmer an integral.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenum Color\n{\n        red, # = 1\n        green, # = 2\n        blue, # 3\n};\n\n# we can assigne number too\n\nenum Color\n{\n        red, # = 1\n        green, # = 2\n        blue = 5,\n};\n```\n:::\n\n\nBecause the unscoped enumeration implicitly converses to integer and the `std::cout<<` does not know how to print our define type, program prints unscoped enumration as integer, not its enumerators.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nenum Color\n{\n\tblack, \n\tred,\n\tblue,\n\tgreen,\n\twhite,\n\tcyan,\n\tyellow,\n\tmagenta,\n};\n\nint main()\n{\n\tColor shirt{ blue };\n\t\n\tstd::cout << \"Your shirt is \" << shirt << '\\n';\n\n\treturn 0;\n}\n\n#> Your shirt is 2\n```\n:::\n\n\nTO solve this problem, we can create a function to get enumerators and assign it to string to print out:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nenum Color\n{\n\tblack, \n\tred,\n\tblue,\n\tgreen,\n\twhite,\n\tcyan,\n\tyellow,\n\tmagenta,\n};\n\n#' We create a function helping to print:\nconst std::string_view getColor(Color& color)\t# C++17\n{\n\tswitch (color)\n\t{\n\tcase black:\n\t\treturn \"black\";\n\tcase red:\n\t\treturn \"red\";\n\tcase green:\n\t\treturn \"green\";\n\tdefault:\n\t\treturn \"???\";\n\t}\n}\n\nint main()\n{\n\tColor shirt{ blue };\n\t\n\tstd::cout << \"Your shirt is \" << shirt << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nThe other code we can do it to use `std::ostream`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#label: teach-operator>>\n\nstd::ostream& operator<<(std::ostream& out, Color color)\n{\n\tswitch (color)\n\t{\n\tcase black: \n\t\tout << \"black\";\n\t\tbreak;\n\tcase red:\n\t\tout << \"red\";\n\t\tbreak;\n\tcase blue:\n\t\tout << \"blue\";\n\t\tbreak;\n\tdefault:\n\t\tout << \"???\";\n\t\tbreak;\n\t}\n\n\treturn out;\n}\n```\n:::\n\n\nThis is similar to `std::cin`: it does not know how to input our defined type. We need a function or an overload to teach it:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstd::istream& operator>>(std::istream& in, Pet& pet)\n{\n\tint input{};\n\tin >> input;\n\n\tpet = static_cast<Pet>(input);\n\t\n\treturn in;\n\n}\n\nstd::ostream& operator<<(std::ostream& out, Pet& pet)\n{\n\tswitch (pet)\n\t{\n\tcase cat:\n\t\tout << \"cat\";\n\t\tbreak;\n\tcase dog:\n\t\tout << \"dog\";\n\t\tbreak;\n\tcase pig:\n\t\tout << \"pig\";\n\t\tbreak;\n\tcase whale:\n\t\tout << \"whale\";\n\t\tbreak;\n\t}\n\n\treturn out;\n}\n\n\nint main()\n{\n    std::cout << \"Enter a pet (0=cat, 1=dog, 2=pig, 3=whale): \";\n\n    Pet pet{};\n    std::cin >> pet; // input our pet using std::cin\n\n    std::cout << pet << '\\n'; // prove that it worked\n\n    return 0;\n}\n```\n:::\n\n\n## Scope enumeration (enum class)\n\nWe use `enum class` for scoped enumeration. There are two differences with unscoped enumeration:\n\n* They are strong type: do not implicitly cover to integer\n* They are strongly scoped: enumerators only place in the scope of its enum\n\nHere is an example code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenum class Color\n{\n    red,\n    blue,\n};\n\nenum class Fruit\n{\n    banana,\n    fruit,\n};\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    Color color{ Color::red };\n    Fruit fruit{ Fruit::banana };\n\n    if (color == fruit) # Compile error: can in unscope, but error in scoped enum\n        std::cout << \"color and fruit are equal\\n\";\n    else\n        std::cout << \"color and fruit are not equal\\n\";\n}\n```\n:::\n\n\n:::{.callout-note}\n\nAlthough we use `class` keyword, scope enum are not a *class type* (structs, classes, and unions).\n\n:::\n\nNotice the errors below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    std::cout << red << '\\n';   # red is not in global scope, it is in Color scope\n    std::cout << Color::red << '\\n'; #operator<< does not know how to print Color type\n```\n:::\n\n\nWe can use `using enum Define_type` inside a function to simplify the codes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconstexpr std::string_view getColor(Color color)\n{\n    using enum Color;\n\n    switch (color)\n    {\n    case black:\n        return \"black\";\n    case red:\n        return \"red\";\n    case blue:\n        return \"blue\";\n    default:\n        return \"???\";\n    }\n}\n```\n:::\n\n\nFinally, learn from exercise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenum class Animal\n{\n    pig,\n    chicken,\n    goat,\n    cat,\n    dog,\n    duck,\n    snake,\n};\n\nconstexpr std::string_view get_animal_name(Animal animal)\n{\n    using enum Animal;\n\n    switch (animal)\n    {\n    case pig:\n        return \"pig\";\n    case chicken:\n        return \"chicken\";\n    case cat:\n        return \"cat\";\n    case dog:\n        return \"dog\";\n    case duck:\n        return \"duck\";\n    default:\n        std::cerr << \"Error: cannot find the animal.\\n\";\n    }\n}\n\nint print_number_legs(Animal animal)\n{\n    using enum Animal;\n\n    switch (animal)\n    {\n    case pig:\n    case cat:\n    case dog:\n        return 4;\n    case duck:\n    case chicken:\n        return 2;\n    default:\n        std::cerr << \"Error: cannot find the animal.\\n\";\n        std::abort();\n    }\n}\n\nvoid print_number_legs_ref(Animal animal)\n{\n    using enum Animal;\n\n    switch (animal)\n    {\n    case pig:\n    case cat:\n    case dog:\n        std::cout << 4;\n        break;\n    case duck:\n    case chicken:\n        std::cout << 2;\n        break;\n    default:\n        std::cerr << \"Error: cannot find the animal.\\n\";\n        break;\n    }\n\n    std::cout << \" legs.\\n\";\n}\n\n\nint main()\n{\n    std::cout << \"Hello World!\\n\";\n\n    Color color{ Color::red };\n    Fruit fruit{ Fruit::banana };\n\n    // We can explicitly cover to integer\n    std::cout << static_cast<int>(color) << '\\n';\n\n    //Get animal's name\n\n    Animal animal{ Animal::chicken };\n    std::cout << get_animal_name(Animal::snake) << '\\n';\n    std::cout << \"A \" << get_animal_name(animal) << \" has \" << print_number_legs(animal) << \" legs.\\n\";\n    std::cout << \"A \" << get_animal_name(animal) << \" has \";\n    print_number_legs_ref(animal);\n\n    return 0;\n}\n```\n:::\n\n\n## Introduction to structs, members, and member selection\n\n`struct`(structure) is a keyword that group the related variables into one data types. Each variable defined in `struct` is a **member** of that struct type.\n\nWe can use operator`.` to call each member in the struct and use it as a normal variable for programming.\n\nHere is an example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\nstruct Employee\n{\n\tint id{};\n\tint age{};\n\tdouble wage{};\n};\n\nint main()\n{\n\tEmployee joe{};\n\tjoe.id = 14;\n\tjoe.age = 40;\n\tjoe.wage = 4000.0;\n\n\tEmployee frank{};\n\tfrank.id = 20;\n\tfrank.age = 30;\n\tfrank.wage = 3000.0;\n\n\tstd::cout << \"Joe's earning: \" << joe.wage << '\\n';\n\tstd::cout << \"Frank's earning: \" << frank.wage << '\\n';\n\n\tif (joe.wage > frank.wage)\n\t\tstd::cout << \"Joe earns more than Frank.\\n\";\n\telse if (joe.wage < frank.wage)\n\t\tstd::cout << \"Joe earns less than Frank.\\n\";\n\telse\n\t\t\"They have the same wage.\\n\";\n\n\t// Frank got promotion\n\t++frank.wage;\n\n\t// Today is Joe's birthday\n\t++joe.age;\n\n\treturn 0;\n}\n```\n:::\n\n\n## Struct aggregate initialization\n\nStruct is an **aggregate** so it uses **aggregate initialization** by providing the **initializer list**, a list of valuers separated by comma:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nEmployee joe{14, 32, 4000.0};\n```\n:::\n\n\nIs some values is missing in initialization, it will be 0.\n\nValue of a struct type can be `const` such as `const Employee joe{14, 32, 4000.0};`\n\nWe can add new member (variable) in struct, but should be at the bottom to avoid shift the value.\n\n#### Assignment with an initializer list\n\nWe can use initializer list to assign values to members:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nEmployee joe{14, 32, 4000.0};\n\njoe = {joe.id, 33, 4500.0};\n\njoe = {.id = joe.id, .age = 33, .Wage = 4600.0} # from C++20\n```\n:::\n\n\n:::{.callout-tip}\n\nProvide a default value for all members.\n\nIf no explicit initializer values will be provided for an aggregate, prefer value initialization (with empty braces initializers) to default initialization( with no braces).\n\n:::\n\n## Struct passing and miscellany\n\nThe important advantage of struct is `pass by reference to struct` so that we onmy one variable instead of many member variables in struct for the variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstruct Employee\n{\n\tint id{};\n\tint age{};\n\tdouble wage{};\n};\n\nvoid print_employee(const Employee& employee)\n{\n\tstd::cout << \"ID: \" << employee.id << '\\n';\n\tstd::cout << \"Age: \" << employee.age << '\\n';\n\tstd::cout << \"Wage: \" << employee.wage << \"\\n\\n\";\n}\n\nint main()\n{\n\tEmployee joe{ 10, 25, 3000.00 };\n\tEmployee frank{ 16, 30, 3500.00 };\n\n\tprint_employee(joe);\n\tprint_employee(frank);\n\n\treturn 0;\n}\n```\n:::\n\n\nWe can also `return by struct`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nEmployee get_employee()\n{\n    return {};\n    \n    #or\n    return {0, 0, 0.0};\n    \n    #or\n    return Employee {0, 0, 0.0};\n    \n    #or\n    Employee emp{};\n    return emp;\n}\n```\n:::\n\n\n### Struct with program-defined members\n\nStruct can include member as another struct.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstruct Employee\n{\n\tint id{};\n\tint age{};\n\tdouble wage{};\n};\n\nstruct Company\n{\n\tint number_employees{};\n\tEmployee CEO{};\n};\n\nint main()\n{\n\tCompany my_company{ 10, {1, 30, 230000.00} };\n\tstd::cout << my_company.CEO.age << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n:::{.callout-note}\n\nClass is the heart of C++ and object oriented programming. It is built on top of structs. It is important to understand struct.\n\n:::\n\nGenerally, we use `.` to call members of a struct. If it is a **reference** to a struct, we also use `.`.\n\nFor a **pointer** to a struct, we cannot use `.`, we use operator `->` instead:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <string>\n\nstruct Paw\n{\n\tint claw{};\n};\n\nstruct Animal\n{\n\tstd::string name{};\n\tPaw paw{};\n};\n\nint main()\n{\n\tAnimal puma{ \"Puma\", {5} };\n\tAnimal* ptr{ &puma };\n\n\tstd::cout << (ptr->paw).claw << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\n## Class template\n\nWe come to the property that *type definition* cannot be overloaded like function. We can use `class template`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n\ntemplate <typename T>\nstruct Pair\n{\n\tT first{};\n\tT second{};\n};\n\ntemplate <typename T>\nconstexpr T max(Pair<T> pair)\n{\n\treturn (pair.first > pair.second ? pair.first : pair.second);\n}\n\nint main()\n{\n\tPair<int> p1{ 5, 6 };\n\tstd::cout << p1.first << ' ' << p1.second << '\\n';\n\tstd::cout << max<int>(p1) << '\\n';\n\n\tPair<double> p2{ 3.2, 6.4 };\n\tstd::cout << p2.first << ' ' << p2.second << '\\n';\n\tstd::cout << max(p2) << '\\n';\n\n\treturn 0;\n}\n```\n:::\n\n\nClass template can have normal variable and template variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemplate <typename T>\nstruct Pair\n{\n    T first{};\n    int second{};\n}\n```\n:::\n\n\nClass template can have multiple types:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemplate< typename T, typename U>\nstruct Pair\n{\n    T first{};\n    U second{};\n};\n\ntemplate <typename T, typename U>\nvoid print(Pair<U, T> p)\n{\n    std::cout << '[' << p.first << \" , \" << p.second << ']';\n}\n\nvoid print(Pair2<T, U> pair)\n{\n\tstd::cout << '[' << pair.first << \", \" << pair.second << ']';\n}\n\nint main()\n{\n\tPair<int> p1{ 5, 6 };\n\tstd::cout << p1.first << ' ' << p1.second << '\\n';\n\tstd::cout << max<int>(p1) << '\\n';\n\n\tPair<double> p2{ 3.2, 6.4 };\n\tstd::cout << p2.first << ' ' << p2.second << '\\n';\n\tstd::cout << max(p2) << '\\n';\n\n\tPair2<int, double> p3{ 2, 8.6 };\n\tprint(p3);\n\n\treturn 0;\n}\n```\n:::\n\n\n#### std::pair\n\nC++ provide `std::pair` to work exactly as the pair template that we created above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntemplate <typename T, typename U>\nvoid print2(std::pair<T, U> pair)\n{\n\tstd::cout << '[' << pair.first << \", \" << pair.second << ']' << '\\n';\n}\n\nint main()\n{\n\n\tstd::pair<int, double> p4{ 10, 25.5 };\n\tprint2(p4);\n\n\treturn 0;\n}\n```\n:::\n\n\nWe can put template definition (function, type) and type definition in the header for using in multiple files. They are exempt from one-definition rule.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#ifndef PAIR_H\n#define PAIR_H\n\ntemplate <typename T>\nstruct Pair\n{\n    T first{};\n    T second{};\n};\n\ntemplate <typename T>\nconstexpr T max(Pair<T> p)\n{\n    return (p.first < p.second ? p.second : p.first);\n}\n\n#endif\n```\n:::\n\n\n## Class template argument deduction and deduction guides\n\nFrom C++17, we can define the template, but the compiler need a guide to deduce the member's type, thus we write the **deduction guide**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#include <iostream>\n#include <utility>\n\ntemplate <typename T, typename U>\nstruct Pair\n{\n\tT first{};\n\tU second{};\n};\n\n# Deduction guide\ntemplate <typename T, typename U>\nPair(T, U) -> Pair<T, U>;\n\nint main()\n{\n\tstd::pair<int, int> p1{ 3, 4 };\n\tstd::pair p2{ 1, 2 };\n\n\tPair p2{ 3, 2 }; # need deduction guide\n\n}\n```\n:::\n\n\nThe chapter's summary is [here](https://www.learncpp.com/cpp-tutorial/chapter-10-summary-and-quiz/).\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}